---
layout: default
title: TIL (26-02-26) - 리눅스 시스템 관리 문제풀이
parent: TIL
date: 2026-02-26 14:00:00
---

# Today I Learned - 리눅스 시스템 관리 문제풀이

{: .no_toc }

## 2026.02.26 (WED)

{: .no_toc .txt-delta }

---

## 리눅스 시스템 관리

### fdisk 파티션 시스템 ID (타입 코드)

fdisk에서 파티션 종류(`t` 옵션)를 지정할 때 사용하는 핵심 16진수 코드 번호.

- **`82`**: **Linux swap** (스왑 파티션, 가상 메모리 공간)
- **`83`**: **Linux** (리눅스 기본 파티션 - ext2/3/4, xfs 등 일반적인 데이터용)
- **`8e`**: **Linux LVM** (논리 볼륨 관리를 위한 파티션)
- **`fd`**: **Linux raid auto** (소프트웨어 RAID 구성을 위한 파티션)

### mount 와 -o loop 옵션

`mount`는 디스크나 파티션을 리눅스의 특정 디렉터리에 연결해주는 명령어이다.

**`-o loop` (루프백 마운트)**

- **물리적인 하드 디스크나 CD-ROM 장치가 아닌 "일반 파일"(주로 `.iso` 이미지 파일)을 진짜 디스크인 것처럼 속여서 마운트**할 때 사용하는 필수 옵션.
- 예: `mount -o loop install.iso /mnt/cdrom` (install.iso 파일을 진짜 CD 넣은 것처럼 인식시켜 /mnt/cdrom을 통해 안을 들여다보겠다)

### lsblk (블록 디바이스 목록 출력)

리눅스에 연결된 모든 **저장 장치(하드 디스크, USB, 파티션 등 = 블록 디바이스)의 트리 구조**를 한눈에 보여주는 명령어. (list block)

- `fdisk -l`과 비슷하지만, 텍스트가 줄줄이 나오는 fdisk보다 **어떤 하드가 몇 개의 파티션으로 쪼개져서 어디에 마운트되어 있는지 직관적인 트리 구조로** 보여주어 현업에서 장치 파악할 때 먼저 쳐보는 명령어이다.

**기본 출력 결과 (컬럼 의미)**

- `NAME`: 장치 이름 (예: `sda` 밑에 `sda1`, `sda2` 파티션)
- `MAJ:MIN`: 장치의 주, 부 번호
- `RM`: 이동식 장치 여부 (Removable. 1이면 USB/CD롬, 0이면 고정 하드)
- `SIZE`: 장치의 전체 용량
- `RO`: 읽기 전용 여부 (Read Only. 1이면 읽기 전용)
- `TYPE`: 장치 종류 (하드는 `disk`, 파티션은 `part`, CD롬은 `rom` 등)
- `MOUNTPOINT`: 현재 리눅스의 어느 폴더에 연결(마운트)되어 있는지 경로 표시

### /etc/fstab (파일 시스템 테이블)

fstab = file system table = 디스크 자동 마운트 설정 테이블

컴퓨터가 켜질(부팅될) 때 운영체제가 가장 먼저 이 파일을 읽고 **어떤 디스크를, 어디 폴더에, 어떤 옵션으로 연결(마운트)할지 알아서 세팅**해주는 핵심 설정 파일이다.

**총 6개의 필드 (공백이나 탭으로 구분)**

1. **`장치명`**: 물리적 장치 경로 (`/dev/sdb1` 등) 또는 **UUID**(디스크 고유 번호, 요즘 권장)
2. **`마운트 포인트`**: 실제로 연결되어 데이터가 씌여질 리눅스 디렉터리 경로 (예: `/`, `/home`, `swap` 파티션은 `swap`으로 기재)
3. **`파일 시스템 종류`**: 포맷된 타입 (`ext4`, `xfs`, `swap`, `iso9660`(CD-ROM) 등)
4. **`마운트 옵션`**: 읽기/쓰기 권한 등. 가장 많이 쓰는 건 **`defaults`** (rw, suid, dev, exec, auto, nouser, async의 조합 묶음)
5. **`dump 사용 여부`**: 데이터 백업 도구인 dump를 쓸 거냐. `0`(백업 안함), `1`(백업 함)
6. **`fsck 점검 순서`**: 부팅할 때 디스크 오류 검사를 할 지와 그 순서. `0`(검사 안함), `1`(root 파티션, 1순위), `2`(일반 파티션들)

### df

디스크의 사용가능한 용량을 확인할 때 사용하는 명령어.
디스크의 사용량도 확인 가능

- `df -h` : 사람이 읽기 쉬운 형태로 출력
- `df -T` : 파일 시스템 종류 출력
- `df -a` : 모든 파일 시스템 출력
- `df -i` : 아이노드 사용량 출력

### du

파일이나 디렉터리의 크기를 확인할 때 사용하는 명령어.

- `du -h` : 사람이 읽기 쉬운 형태로 출력
- `du -s` : 합계만 출력
- `du -c` : 전체 합계 출력
- `du -ch` : 전체 합계와 사람이 읽기 쉬운 형태로 출력

### 파일/파티션 생성 시 `dd` 와 `fdisk` 의 차이

- **`fdisk` (파티션 도구)**: 실제 물리적 하드 디스크 장치(예: `/dev/sdb`) 공간을 논리적인 구역으로 쪼개거나 합치는(파티션 테이블 수정) 명령어. 일반적인 '파일'을 만드는 도구가 아니다.
- **`dd` (Data Duplicator, 덤프 도구)**: 블록 단위로 데이터를 바이트 그대로 떠서 복사해 주는 명령어.
  - **파일 생성 기능**: 주로 파티션 대신 가상으로 쓸 빈 파일(예: 가상 스왑이나 디스크 이미지 파일)을 만들 때, 이 `dd` 명령어로 0(제로)값을 쑤셔 넣어서 특정 용량 크기의 파일을 억지로 만들어낼 때 쓴다. (예: `dd if=/dev/zero of=swapfile bs=1M count=1024` $\to$ 1GB짜리 빈 파일 생성)

### `dd if=/dev/zero of=/swapfile bs=1k count=102400` 완벽 해부

스왑(가상 메모리)용 100MB짜리 빈 파일을 생성하라는 의미의 명령어.

1. **`dd`**: 데이터를 블록 단위로 밀어넣어라(복사해라)
2. **`if=/dev/zero`**: **i**nput **f**ile(입력). 끝없이 0(제로)만 내뱉는 리눅스의 특수 장치(`/dev/zero`)에서 데이터를 빨아들일 것. 아무 깡통 데이터(0)나 밀어 넣겠다는 뜻.
3. **`of=/swapfile`**: **o**utput **f**ile(출력). 그 0 데이터를 `/swapfile` 이라는 이름의 파일에다가 뱉어내라.
4. **`bs=1k`**: **b**lock **s**ize(블록 한 칸 크기). 한 번 데이터를 퍼 나를 때의 바가지 크기를 **1KB**(1024바이트)로 설정. (사용자가 적은 `lk`는 `1k`의 오타로 추정)
5. **`count=102400`**: 퍼 나르는 횟수. 그 1KB 바가지로 **102,400번**을 퍼 나르라는 뜻.
   - 결과 계산: `1KB * 102400 = 102,400KB = 100MB`. 즉, 안에 0만 꽉 찬 100MB 크기의 `/swapfile`이 완벽하게 생성됨!
