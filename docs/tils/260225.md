---
layout: default
title: TIL (26-02-25) - 리눅스 시스템 관리 문제풀이
parent: TIL
date: 2026-02-25 22:25:00
---

# Today I Learned - 리눅스 시스템 관리 문제풀이

{: .no_toc }

## 2026.02.25 (WED)

{: .no_toc .txt-delta }

---

## 리눅스 시스템 관리

### /etc/default/useradd

리눅스 시스템에서 `useradd` 명령어를 사용하여 **새로운 사용자 계정을 생성할 때 기본적으로 적용되는 설정값**들을 정의해 놓은 파일이다. (즉, 사용자를 만들 때 별도 옵션을 안 주면 이 파일에 적힌 대로 만들어진다.)

이 파일을 직접 에디터(vi)로 수정할 수도 있고, `useradd -D` 명령어에 옵션을 붙여서 수정할 수도 있다.

### useradd [계정명] 실행 시 기본 그룹 설정

- **기본 동작**: 사용자명과 동일한 이름의 **그룹(`posein`)이 새로 생성되어 해당 계정의 기본 그룹으로 설정**된다. (User Private Group 방식)

### /etc/skel

skel = skeleton = 뼈대

새로운 사용자가 로그인할 때 기본적으로 복사되어 생성되는 파일들이 있는 디렉토리

### /etc/login.defs

메일 디렉터리, 패스워드 관련 설정, UID의 최솟값 및 최댓값, 홈 디렉터리 생성 여뷰 등이 정의되어 있는 파일

### 사용자 아이디 변경

usermode -l hoooon22 jihoon

리눅스는 변경할 것(목적)을 뒤에 적는 거 같기도 하다. 아님 말구

### usermode -e

e = expiredate = 계정 만료일

### passwd -l posein

유저 계정의 패스워드에 잠금을 설정하여 일시적으로 로그인을 막는다.

### /etc/shadow

사용자의 암호화된 실제 패스워드와 패스워드 정책(만료일 등)이 저장되는 파일. (보안상 root만 읽기 가능)

### chage

사용자 패스워드의 만료일, 변경 주기 등(보안 기한)을 설정하고 확인하는 명령어. (change age의 약자)

- `chage -l [계정명]` : 설정된 패스워드 만료 및 상태 정보 확인 (list)
- `chage -M [일수] [계정명]` : 패스워드 최대 사용 가능 일수 지정 (Maximum)

### /etc/shadow 와 chage 의 관계

`chage`는 `/etc/shadow` 파일의 **비밀번호 변경 주기 및 만료일 관련 필드(3~8번째 필드)**를 안전하게 수정해 주는 전용 명령어이다. (즉, `chage` 명령어를 실행하면 실제로는 `/etc/shadow` 파일 속 날짜 숫자값들이 자동으로 계산되어 바뀐다.)

### `grep posein /etc/shadow` 출력문의 숫자(필드) 의미

결과는 콜론(`:`)으로 구분된 **총 9개의 필드**로 나온다. (예: `posein:$6$ab...:19000:0:90:7:14:19500:`)

1. **`사용자명`**: 계정 이름 (`posein`)
2. **`암호`**: 암호화된 기호들 (`$` 표시는 어떤 암호화 알고리즘인지 보여줌)
3. **`최종 변경일`**: 마지막으로 비번을 바꾼 날 (1970년 1월 1일 기준 며칠 지났는지 숫자)
4. **`최소 사용일수`**: 비번을 한 번 바꾸면 무조건 유지해야 하는 며칠 (0이면 언제든 변경 가능)
5. **`최대 사용일수`**: 언제까지 이 비번을 쓸 수 있는지 (`chage -M`으로 설정)
6. **`경고일`**: 만료 며칠 전에 "비번 바꿔라" 경고창을 띄울 것인가
7. **`유예 기간(Inactive)`**: 만료 후 계정 접속이 완전 잠길 때까지 봐주는 며칠
8. **`만료일(Expire)`**: 계정 권한 자체가 완전히 끝나는 날짜 숫자 (보통 비어있음)
9. **`예약 필드`**: 사용 안 함 (무시)

### newgrp

자신이 속해있는 **주 그룹(Primary Group)을 다른 그룹으로 잠시 변경**하는 명령어. (새로운 파일을 만들 때 소유권이 이 새로운 주 그룹으로 들어간다.)

- 조건: 당연히 내가 그 변경하려는 그룹의 멤버로 등록되어 있거나, 그 그룹의 패스워드를 알아야 바꿀 수 있다.

### /etc/gshadow

gshadow = group shadow = 뼈대 보호(숨김) 그룹 암호

그룹의 **암호화된 비밀번호와 관리자 정보**가 저장되는 파일. (보안상 root만 읽고 쓸 수 있다.)
`/etc/shadow`가 개별 '사용자' 암호를 담고 있다면, `/etc/gshadow`는 '그룹'의 암호를 담고 있다.

- 그룹에 암호가 걸려있으면, 해당 그룹에 속하지 않은 사용자(외부인)가 `newgrp` 등을 통해 일시적으로 그룹 권한을 얻으려 할 때 이 암호를 입력해야 한다.

### /etc/gshadow 필드 구조

결과는 콜론(`:`)으로 구분된 **총 4개의 필드**로 나온다. (예: `groupname:password:admin:members`)

1. **`그룹명`**: 그룹 이름
2. **`그룹 패스워드`**: 암호화된 비밀번호 (`*`나 `!`이면 로그인할 수 없는/암호가 설정되지 않은 그룹)
3. **`그룹 관리자`**: 그룹의 패스워드나 멤버를 수정할 수 있는 관리자 계정 이름 (비어있을 수 있음)
4. **`그룹 멤버`**: 이 그룹에 포함된 사용자들의 목록 (콤마 `,`로 구분, 주 그룹으로 설정된 사람은 안 나타날 수 있음)

### 소문자는 '일반', 대문자는 '강력'

많은 경우 대문자 옵션은 소문자보다 더 강력한 제어권을 갖거나 강제성을 띤다.

- ps -f: full format (기본 상세 정보)

- ps -F: Extra Full format (더 상세한 정보)

### chmod (파일 허가권 변경)

파일이나 디렉토리의 접근 권한(읽기/쓰기/실행)을 변경하는 명령어 (change mode).

**1. 숫자 모드 (8진수)**

- 각 권한에 고유 숫자를 부여하고 더해서 사용: **`4`(읽기, r), `2`(쓰기, w), `1`(실행, x)**
- 소유자(u), 그룹(g), 기타(o) 순서로 3자리 숫자를 지정
- 예: `chmod 755 file` (소유자 4+2+1=7(rwx), 그룹 4+1=5(r-x), 기타 4+1=5(r-x))

**2. 기호 모드 (문자)**

- 대상: `u`(소유자), `g`(그룹), `o`(기타), `a`(모두)
- 연산자: `+`(권한 추가), `-`(권한 빼기), `=`(해당 권한으로만 설정)
- 권한: `r`(읽기), `w`(쓰기), `x`(실행)
- 예: `chmod o-w file` (기타 사용자의 쓰기 권한 뺏기)

### 특수 권한 (Set-UID, Set-GID, Sticky-Bit)

일반적인 3자리 읽기/쓰기/실행 권한 외에 맨 앞에 **하나의 숫자(또는 문자 `s`, `t`)**를 더 붙여 활성화하는 강력한 특수 권한이다.

**1. Set-UID (숫자: `4000`, 문자: `s`)**

- 징후: 소유자(User)의 실행 권한 자리가 `x` 대신 **`s`**로 지정됨. (예: `-rwsr-xr-x`)
- 기능: 일반 사용자가 이 파일을 실행하는 순간만큼은, 이 파일의 **"원래 소유자(주로 root)"의 권한**을 빌려서 실행한다.
- 대표 예시: `/usr/bin/passwd` (일반 유저가 자기 비번을 바꿀 때 순간적으로 root 권한을 빌림)

**2. Set-GID (숫자: `2000`, 문자: `s`)**

- 징후: 그룹(Group)의 실행 권한 자리가 `x` 대신 **`s`**로 지정됨. (예: `-rwxr-sr-x`)
- 기능: Set-UID의 그룹 버전. 이 파일을 실행하거나 디렉토리에 접근할 때 파일의 **"설정된 그룹"의 권한**을 빌려서 실행된다. (해당 디렉토리에 만들어진 파일은 부모 디렉토리의 그룹을 상속받음)

**3. Sticky-Bit (숫자: `1000`, 문자: `t`)**

- 징후: 기타 사용자(Others)의 실행 권한 자리가 `x` 대신 **`t`**로 지정됨. (예: `drwxrwxrwt`)
- 기능: **공용 폴더**를 만들 때 쓴다. "모두가 파일을 만들고 쓸 수는 있지만, **삭제나 파일명 수정은 오직 파일을 만든 본인이나 root만**" 할 수 있다.
- 대표 예시: `/tmp` (누구든 잠시 파일을 두는 쓰레기통/임시폴더지만, 남이 내 파일을 지우면 안 되니까)

**💡 특수 권한의 조합 (단순 덧셈)**
기본 권한(r, w, x)처럼 맨 앞자리 특수 권한도 숫자를 더해서 섞어 쓸 수 있다.

- **`2000` (Set-GID) + `1000` (Sticky-Bit) = `3000`**
- 예) `chmod 3770` $\to$ Set-GID와 Sticky-Bit를 동시 적용(`3`) 하고, 그 뒤에 소유자/그룹은 모든 권한(`77`), 기타는 접근 불가(`0`)로 설정하겠다는 뜻!

### chown (파일 소유권 변경)

파일이나 디렉터리의 **주인(소유자, Owner)**과 **소속 그룹(Group)**을 변경하는 명령어 (change owner).

- **기본 사용법 (소유자만 변경)**: `chown [새소유자] [파일명]` (예: `chown posein file.txt`)
- **소유자와 그룹 동시 변경 (`:` 또는 `.` 사용)**: `chown [새소유자]:[새그룹] [파일명]` (예: `chown posein:root file.txt`)
- **그룹만 변경**: `chown :[새그룹] [파일명]` (앞은 비워두고 콜론부터 씀. `chgrp` 명령어와 완전히 동일한 역할)
- **단골 옵션 (`-R`)**: 디렉터리와 그 안의 모든 하위 파일들의 소유권을 **통째로(재귀적으로) 변경**할 때 사용한다. (예: `chown -R posein dir/`)

### umask (기본 허가권 결정)

파일이나 디렉토리를 새로 만들 때 부여되는 **'초기(기본) 접근 권한'을 빼기 연산으로 결정**하는 설정값. (user mask)

- **초기 최대 권한 (기준점)**
  - **파일**: `666` (`rw-rw-rw-`, 파일은 기본적으로 어디서든 실행(`x`) 권한은 빼고 시작함)
  - **디렉토리**: `777` (`rwxrwxrwx`)
- **계산법 (최대 권한 - umask 값)**
  - 예) `umask` 값이 **`022`**라면?
  - 새로 만든 **파일** 권한: `666` - `022` = **`644`** (`rw-r--r--`)
  - 새로 만든 **디렉토리** 권한: `777` - `022` = **`755`** (`rwxr-xr-x`)
- 명령어만 치면(`umask`): 현재 설정된 umask 숫자값을 0000 형태로 보여준다.
- `umask -S`: 권한 숫자가 아니라 `u=rwx,g=rx,o=rx` 와 같이 사용자들이 직관적으로 볼 수 있는 **문자(Symbolic) 형태**로 보여준다.

### ln (링크 생성)

하나의 파일에 대해 새로 이름을 붙이는(링크를 거는) 명령어. (link)

**1. 하드 링크 (`ln 원본 사본`)**

- 원본 파일과 **동일한 inode(파일의 고유 번호)**를 공유한다. (마치 하나의 본체에 이름표만 두 개 붙은 셈)
- 둘 중 하나를 수정하면 같이 변경되지만, **원본을 삭제해도 사본은 안의 내용을 그대로 유지**하며 살아있다.
- 디렉터리(폴더)에는 하드 링크를 설정할 수 없다. (다른 파티션에도 불가)

**2. 심볼릭 링크 / 소프트 링크 (`ln -s 원본 사본`)**

- 원본 파일의 **경로(위치)만 가리키는 윈도우의 '바로가기'**와 같다. (원본과 inode가 다름)
- **원본을 삭제하면 사본(링크)은 길을 잃고 아무 쓸모가 없어져 에러가 난다**. (고아 링크)
- 디렉터리나 다른 파티션/파일 시스템에도 자유롭게 링크를 걸 수 있다. (실제 현업에서 더 많이 쓰임)

### 새로운 하드 디스크 장착 및 사용 절차

새로운 디스크를 리눅스 시스템에 인식시키고 사용할 수 있게 만드는 필수 과정.

0. **디스크 인식 확인**
   - 명령어: **`fdisk -l`** (전체 디스크 목록 출력)
   - 파티션 작업 전, 새로 꽂은 하드 디스크가 리눅스에 어떤 이름(예: `/dev/sdb`, `/dev/nvme0n1`)으로 잘 잡혔는지 확인하는 사전 단계.
1. **파티션 분할 (Partitioning)**
   - 명령어: **`fdisk`** (예: `fdisk /dev/sdb`)
   - 앞서 확인한 물리적인 하드 디스크를 논리적인 구역(파티션)으로 나누는 작업.
2. **파일 시스템 생성 (Formatting)**
   - 명령어: **`mkfs`** (make file system) 또는 `mke2fs` (예: `mkfs.ext4 /dev/sdb1`)
   - 나눈 파티션에 파일 시스템(ext4, xfs 등)을 입혀 데이터를 쓸 수 있게 포맷하는 작업.
3. **디렉토리 마운트 (Mounting)**
   - 명령어: **`mount`** (예: `mount /dev/sdb1 /mnt/newdisk`)
   - 포맷된 파티션을 리눅스의 특정 디렉토리(마운트 포인트)에 연결해서 실제 접근 가능하게 만드는 작업.
4. **자동 마운트 설정 유지 (fstab 등록)**
   - 파일: **`/etc/fstab`**
   - 컴퓨터를 재부팅해도 방금 연결한 마운트 상태가 계속 유지되도록 파일에 등록하는 필수 마무리 작업.
