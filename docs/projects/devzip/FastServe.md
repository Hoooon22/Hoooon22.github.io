---
layout: default
title: 사이드 프로젝트 - FastServe
nav_order: 11
has_children: false
parent: Projects
---

# FastServe: 웹 서버 프레임워크 성능 비교 실험
{: .no_toc }

## Project has been written since April 25, 2023.
{: .fs-4 .fw-300 }

<br>

## 들어가며
{: .fs-5 .fw-500 }

안녕하세요! 오늘은 제가 최근 시작한 흥미로운 개인 프로젝트인 **FastServe**에 대해 소개해 드리려고 합니다. 이 프로젝트는 다양한 프로그래밍 언어와 웹 서버 프레임워크의 성능을 체계적으로 비교하고 분석하는 것을 목표로 합니다.

웹 개발자로서 "어떤 백엔드 기술이 가장 빠를까?", "캐싱은 얼마나 효과적일까?", "HTTP/2는 정말 더 빠를까?" 같은 질문에 데이터 기반의 답을 찾고 싶었습니다. 그래서 직접 실험을 설계하고 다양한 환경에서 테스트해보기로 했죠!

## 📊 프로젝트 목표
{: .fs-5 .fw-500 }

FastServe의 주요 목표는 다음과 같습니다:

1. **다양한 언어와 프레임워크의 성능 특성 이해하기**
   - Java, Node.js, Go, Python, Rust, C++, C# 등 주요 백엔드 기술의 성능 특성을 직접 비교
   - 각 언어/프레임워크의 장단점을 실제 성능 데이터와 함께 문서화

2. **웹 서버 튜닝 요소의 영향 측정하기**
   - gzip 압축, keep-alive, HTTP 버전, 캐시 전략 등 다양한 설정의 영향 확인
   - Nginx 리버스 프록시 설정에 따른 성능 변화 분석

3. **부하 테스트 및 모니터링 환경 구축하기**
   - wrk, k6 등 부하 테스트 도구를 활용한 체계적인 실험 설계
   - Grafana, Prometheus 기반의 모니터링 시스템으로 실시간 성능 지표 시각화

## 🧪 실험 구성
{: .fs-5 .fw-500 }

프로젝트에서 다루는 언어와 프레임워크 조합은 다음과 같습니다:

| 언어 | 프레임워크/서버 | 특징 |
|------|-----------------|------|
| Java | Spring Boot (Tomcat) | 동기 방식, 산업 표준, GC 기반 |
|      | Spring WebFlux (Netty) | 비동기 리액티브 방식 |
| Node.js | Express | 싱글 스레드 이벤트 루프, 인기 높음 |
|         | Fastify | 고성능 지향 설계 |
| Go | net/http (표준) | 고루틴 기반 동시성, 가벼움 |
|    | Fiber | 고성능 지향, Express 스타일 API |
| Python | Flask | 단순한 구조, WSGI 기반 |
|        | FastAPI | 비동기 처리, Starlette 기반 |
| Rust | Actix-web | 높은 성능, 메모리 안전성 |
|      | Axum | Tokio 기반 현대적 설계 |
| C++ | Pistache | 네이티브 성능, 저수준 제어 |
| C# | ASP.NET Core | .NET 플랫폼, GC 기반 |

여기에 Redis 캐시, Nginx 프록시, MySQL/SQLite DB 등을 조합하여 다양한 설정에서의 성능을 측정할 계획입니다.

## 🧩 테스트 API 설계
{: .fs-5 .fw-500 }

성능 비교를 위해 모든 서버에서 구현할 공통 API 엔드포인트를 다음과 같이 설계했습니다:

1. **`GET /api/compute`**: CPU 부하 테스트 (피보나치 계산)
   - 순수 연산 능력 측정
   - 동시 요청 처리 성능 확인

2. **`GET /api/cache`**: 캐시 효과 테스트
   - 첫 요청 시 느린 응답 (DB 조회 흉내)
   - 이후 캐시된 결과 빠르게 반환

3. **`GET /api/db`**: 데이터베이스 I/O 테스트
   - 1000개의 인용구 데이터에서 무작위 조회
   - DB 연결 풀 설정에 따른 성능 변화 확인

4. **`GET /api/health`**: 최소 오버헤드 테스트
   - 단순 "ok" 문자열 반환
   - 프레임워크 자체의 기본 오버헤드 측정

## 🛠 기술 스택 및 환경 구성
{: .fs-5 .fw-500 }

FastServe 프로젝트는 Docker 기반의 일관된 테스트 환경에서 실행됩니다. 각 서버는 독립적인 컨테이너로 구성되며, Nginx 리버스 프록시를 통해 외부로 노출됩니다.

```
FastServe 아키텍처
-----------------
클라이언트 → Nginx 프록시 → 각 언어별 서버
                   ↓
            Prometheus + Grafana (모니터링)
                   ↓
                 Redis (캐싱)
                   ↓
              MySQL/SQLite (DB)
```

이렇게 구성하면 실제 프로덕션 환경과 유사한 구조에서 성능을 측정할 수 있습니다.

## 🔍 초기 가설
{: .fs-5 .fw-500 }

프로젝트를 시작하기 전, 몇 가지 가설을 세워보았습니다:

1. Rust와 Go 기반 서버가 가장 높은 처리량을 보일 것
2. 캐시 사용 시 모든 서버의 성능 차이가 크게 줄어들 것
3. DB I/O 작업에서는 비동기/논블로킹 방식의 서버가 유리할 것
4. HTTP/2 사용 시 동시 요청 처리 성능이 크게 향상될 것

이러한 가설이 실제 테스트 결과와 얼마나 일치하는지 확인하는 것도 이 프로젝트의 흥미로운 부분입니다.

## 📆 진행 계획
{: .fs-5 .fw-500 }

FastServe 프로젝트는 다음과 같은 단계로 진행할 계획입니다:

1. **환경 구성 및 기본 서버 구현** (현재 진행 중)
   - Docker 컨테이너 설정
   - 각 언어별 기본 서버 구현

2. **API 엔드포인트 구현**
   - 모든 서버에 4가지 API 구현
   - 기본 기능 테스트

3. **모니터링 시스템 구축**
   - Prometheus 메트릭 수집
   - Grafana 대시보드 구성

4. **성능 테스트 실행**
   - 다양한 부하 시나리오 테스트
   - 설정 변경에 따른 영향 측정

5. **결과 분석 및 문서화**
   - 테스트 결과 시각화
   - 결론 및 학습 내용 정리

## 🤔 예상되는 도전 과제
{: .fs-5 .fw-500 }

프로젝트를 진행하면서 몇 가지 도전 과제가 예상됩니다:

1. **공정한 비교 환경 구성**: 각 언어/프레임워크의 최적 설정을 찾는 것
2. **동일한 기능 구현**: 모든 서버에서 정확히 같은 기능을 구현하는 것
3. **리소스 제약**: 로컬 환경에서 여러 컨테이너를 동시에 실행하는 하드웨어 한계
4. **데이터 분석**: 수집된 성능 데이터를 의미 있게 해석하는 것

## 🌟 마무리
{: .fs-5 .fw-500 }

FastServe 프로젝트는 단순히 "어떤 기술이 가장 빠른가?"를 넘어, 다양한 상황에서 각 기술의 장단점을 이해하고 적절한 선택을 할 수 있는 통찰력을 얻는 것이 목표입니다.

앞으로 프로젝트 진행 상황과 흥미로운 발견들을 이 블로그에 정기적으로 공유할 예정입니다. 다음 포스트에서는 각 언어별 서버 구현 과정과 초기 벤치마크 결과를 소개해 드리겠습니다.

궁금한 점이나 제안이 있으시면 댓글로 남겨주세요! 함께 더 발전된 실험을 만들어 갈 수 있으면 좋겠습니다.

## Links
{: .fs-4 .fw-300 }

- [FastServe GitHub 저장소](https://github.com/Hoooon22/fastserve-project)
- [성능 대시보드 데모](https://fastserve-dashboard.example.com) 