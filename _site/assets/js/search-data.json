{"0": {
    "doc": "OOP",
    "title": "객체지향 프로그래밍",
    "content": " ",
    "url": "/docs/studies/object/02_OOP/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D",
    
    "relUrl": "/docs/studies/object/02_OOP/#객체지향-프로그래밍"
  },"1": {
    "doc": "OOP",
    "title": "2023.08.08 (TUE)",
    "content": ". ",
    "url": "/docs/studies/object/02_OOP/#20230808-tue",
    
    "relUrl": "/docs/studies/object/02_OOP/#20230808-tue"
  },"2": {
    "doc": "OOP",
    "title": "개요",
    "content": "객체지향은 객체를 지향하는 것이다. 대부분은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 생각한다. 하지만 이는 객체지향의 본질이 아니다. 객체지향은 말 그대로 객체를 지향하는 것이다. 클래스가 아닌 객체에 초점을 맞춰야 한다. 이를 위해선 다음을 중점적으로 살펴봐야 한다. 1️⃣ 어떤 클래스가 필요한지를 고민하기 전에, 어떤 객체들이 필요한지 고민하라. 일단 클래스와 객체의 차이점에 대해 살펴봐야 한다. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 예를 들면, 붕어빵이라는 객체를 만들기 위해 붕어빵 틀이라는 클래스를 구현하였다고 할 수 있다. 클래스를 구현하기 위해서는 어떤 객체들이 어떤 상태와 행동들을 가지는지를 먼저 봐야 한다는 것이다. 2️⃣ 객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원이라고 생각한다. 유지보수 가능한, 유연한 객체지향 코드를 만들기 위해서는 객체들이 다른 객체들에게 도음을 주거나 의존하는 그림이 되어야 한다. 붕어빵과 붕어빵 틀처럼, 붕어빵 기계들의 부품들이 붕어빵 틀이 잘 돌아가게 하고, 그 붕어빵 틀이 질 좋은 붕어빵을 만들게 된다. ",
    "url": "/docs/studies/object/02_OOP/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/object/02_OOP/#개요"
  },"3": {
    "doc": "OOP",
    "title": "도메인",
    "content": "도메인은 [문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야]라고 할 수 있다. ",
    "url": "/docs/studies/object/02_OOP/#%EB%8F%84%EB%A9%94%EC%9D%B8",
    
    "relUrl": "/docs/studies/object/02_OOP/#도메인"
  },"4": {
    "doc": "OOP",
    "title": "OOP",
    "content": " ",
    "url": "/docs/studies/object/02_OOP/",
    
    "relUrl": "/docs/studies/object/02_OOP/"
  },"5": {
    "doc": "1일 1코딩",
    "title": "1일 1코테연습",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/1day1coding/#1%EC%9D%BC-1%EC%BD%94%ED%85%8C%EC%97%B0%EC%8A%B5",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/#1일-1코테연습"
  },"6": {
    "doc": "1일 1코딩",
    "title": "This Page has been written since July 11, 2023.",
    "content": ". | Links | . 이전 코테 연습 풀이 . ",
    "url": "/docs/codingtest/1day1coding/1day1coding/#this-page-has-been-written-since-july-11-2023",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/#this-page-has-been-written-since-july-11-2023"
  },"7": {
    "doc": "1일 1코딩",
    "title": "1일 1코딩",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/1day1coding/",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/"
  },"8": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "Github Actions를 활용한 프로젝트 무중단 배포",
    "content": " ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/"
  },"9": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "2024.10.23 (WED)",
    "content": ". Devzip 프로젝트를 진행하면서, 매번 console에 접속하여 git pull 및 빌드, 재시작하는 것이 굉장히 비효율적으로 느껴졌다. 그 때, 현재 Github.io 블로그에서 깃헙 커밋 변화에 따른 자동 빌드 시스템이 생각나서 이를 활용해보기로 하였다. ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/#20241023-wed",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/#20241023-wed"
  },"10": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "Github Actions",
    "content": "Github Actions는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼이다. GitHub Actions를 사용하면 자동으로 코드 저장소에서 어떤 이벤트(event)가 발생했을 때 특정 작업이 일어나게 하거나 주기적으로 어떤 작업들을 반복해서 실행시킬 수 있다.github/workflows 내부의 나의 설정 파일은 아래와 같다. name: dev branch auto ci process script on: # 아래 job을 실행시킬 상황 push: branches: [ master ] jobs: deploy: name: deploy runs-on: ubuntu-latest # 실행될 인스턴스 OS와 버전 steps: - name: excuting remote ssh commands uses: appleboy/ssh-action@v0.1.6 # ssh 접속하는 오픈소스 with: host: $ # 인스턴스 IP username: $ # 우분투 아이디 key: $ # ec2 instance pem key port: $ # 접속포트 script: | # 실행할 스크립트 # ~~~ . 5번째 줄: push이벤트가 발생할 때, 실행 시킨다. 이외의 코드는 AWS EC2에 접속하고 명령을 실행하는 코드로 이루어져 있다. | push 시, 자동 실행된 모습 | . ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/#github-actions",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/#github-actions"
  },"11": {
    "doc": "TIL (23-06-29)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230629/#til",
    
    "relUrl": "/docs/tils/230629/#til"
  },"12": {
    "doc": "TIL (23-06-29)",
    "title": "2023.06.29 (WED)",
    "content": ". 📌 오늘의 TIL . | 💻 깃허브 블로그 제작 . | just the Docs Theme 적용 및 틀 구현 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 구현 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 가슴 | . ",
    "url": "/docs/tils/230629/#20230629-wed",
    
    "relUrl": "/docs/tils/230629/#20230629-wed"
  },"13": {
    "doc": "TIL (23-06-29)",
    "title": "TIL (23-06-29)",
    "content": " ",
    "url": "/docs/tils/230629/",
    
    "relUrl": "/docs/tils/230629/"
  },"14": {
    "doc": "TIL (23-07-02)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230702/#til",
    
    "relUrl": "/docs/tils/230702/#til"
  },"15": {
    "doc": "TIL (23-07-02)",
    "title": "2023.07.02 (SUN)",
    "content": ". 📌 오늘의 TIL . | 💻 깃허브 블로그 제작 . | 프로젝트 메뉴 생성 및 퐁당 웹매거진 프로젝트 업로드 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 동기화 매뉴얼 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230702/#20230702-sun",
    
    "relUrl": "/docs/tils/230702/#20230702-sun"
  },"16": {
    "doc": "TIL (23-07-02)",
    "title": "TIL (23-07-02)",
    "content": " ",
    "url": "/docs/tils/230702/",
    
    "relUrl": "/docs/tils/230702/"
  },"17": {
    "doc": "제작 일지 <1>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230702/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/pongdang/230702/#퐁당-웹-매거진-프로젝트-제작-일지-1"
  },"18": {
    "doc": "제작 일지 <1>",
    "title": "2023.07.02 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230702/#20230702-wed",
    
    "relUrl": "/docs/projects/pongdang/230702/#20230702-wed"
  },"19": {
    "doc": "제작 일지 <1>",
    "title": "1. 프로젝트 빌드 후, Servlet.service() for sevlet 오류 발생 시",
    "content": "해결법 1. 프로젝트 클린(clean)과 재빌드(rebuild)는 빌드 도구(Maven, Gradle 등)를 사용하여 프로젝트를 초기화하고 의존성을 새롭게 다운로드하여 프로젝트를 다시 빌드하는 작업입니다. 이를 통해 이전에 캐시된 클래스 파일이나 의존성 문제로 인해 발생하는 오류를 해결할 수 있습니다. 아래는 Maven과 Gradle에서 프로젝트 클린과 재빌드를 수행하는 방법입니다: . Maven을 사용하는 경우: . 프로젝트 디렉토리로 이동합니다. 명령줄 또는 터미널에서 다음 명령어를 실행합니다: mvn clean install clean: 이전 빌드에 의해 생성된 클래스 파일과 빌드 아티팩트를 제거합니다. install: 프로젝트를 빌드하고 로컬 Maven 저장소에 라이브러리를 설치합니다. Gradle을 사용하는 경우: . 프로젝트 디렉토리로 이동합니다. 명령줄 또는 터미널에서 다음 명령어를 실행합니다: gradlew clean build clean: 이전 빌드에 의해 생성된 클래스 파일과 빌드 아티팩트를 제거합니다. build: 프로젝트를 빌드하고 필요한 의존성을 다운로드합니다. 프로젝트 클린(clean)과 재빌드(rebuild)를 실행하면 이전에 발생한 빌드 오류와 관련된 문제를 해결할 수 있습니다. 이는 캐시된 클래스 파일이나 의존성이 변경되어 다시 다운로드되고 빌드되기 때문입니다. clean으로 재빌드 하니, 정상 작동한다. ",
    "url": "/docs/projects/pongdang/230702/#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B9%8C%EB%93%9C-%ED%9B%84-servletservice-for-sevlet-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D-%EC%8B%9C",
    
    "relUrl": "/docs/projects/pongdang/230702/#1-프로젝트-빌드-후-servletservice-for-sevlet-오류-발생-시"
  },"20": {
    "doc": "제작 일지 <1>",
    "title": "2. 스프링부트 스냅샷 실행 시",
    "content": "nohup이 작동하지 않는다. java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log . 없이는 정상 작동한다. 3. 동기화 순서 . | ./gradlew clean build | pkill -f Pongdang_Server2-0.0.1-SNAPSHOT.jar | java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log &amp; | . ",
    "url": "/docs/projects/pongdang/230702/#2-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%8B%A4%ED%96%89-%EC%8B%9C",
    
    "relUrl": "/docs/projects/pongdang/230702/#2-스프링부트-스냅샷-실행-시"
  },"21": {
    "doc": "제작 일지 <1>",
    "title": "제작 일지 <1>",
    "content": " ",
    "url": "/docs/projects/pongdang/230702/",
    
    "relUrl": "/docs/projects/pongdang/230702/"
  },"22": {
    "doc": "제작 일지 <2>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;2&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230706/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-2",
    
    "relUrl": "/docs/projects/pongdang/230706/#퐁당-웹-매거진-프로젝트-제작-일지-2"
  },"23": {
    "doc": "제작 일지 <2>",
    "title": "2023.07.06 (THU)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230706/#20230706-thu",
    
    "relUrl": "/docs/projects/pongdang/230706/#20230706-thu"
  },"24": {
    "doc": "제작 일지 <2>",
    "title": "1. 메뉴 ul margin 없애기",
    "content": ".menu ul { width : 100%; list-style-type: none; display: flex; flex-direction: row; justify-content: space-around; padding-inline-start: 0; } .menu li { text-align: center; } . padding-inline-start로 왼쪽의 padding을 없애주었다. ",
    "url": "/docs/projects/pongdang/230706/#1-%EB%A9%94%EB%89%B4-ul-margin-%EC%97%86%EC%95%A0%EA%B8%B0",
    
    "relUrl": "/docs/projects/pongdang/230706/#1-메뉴-ul-margin-없애기"
  },"25": {
    "doc": "제작 일지 <2>",
    "title": "2. 기반 정리",
    "content": ". ",
    "url": "/docs/projects/pongdang/230706/#2-%EA%B8%B0%EB%B0%98-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/projects/pongdang/230706/#2-기반-정리"
  },"26": {
    "doc": "제작 일지 <2>",
    "title": "3. 이후 계획",
    "content": "css or js 라이버리를 사용하여, 슬라이드 및 애니메이션 효과를 적용하도록 한다. ",
    "url": "/docs/projects/pongdang/230706/#3-%EC%9D%B4%ED%9B%84-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/pongdang/230706/#3-이후-계획"
  },"27": {
    "doc": "제작 일지 <2>",
    "title": "제작 일지 <2>",
    "content": " ",
    "url": "/docs/projects/pongdang/230706/",
    
    "relUrl": "/docs/projects/pongdang/230706/"
  },"28": {
    "doc": "TIL (23-07-06)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230706/#til",
    
    "relUrl": "/docs/tils/230706/#til"
  },"29": {
    "doc": "TIL (23-07-06)",
    "title": "2023.07.06 (THU)",
    "content": ". 📌 오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 회의 | 오늘의 제작 일지 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230706/#20230706-thu",
    
    "relUrl": "/docs/tils/230706/#20230706-thu"
  },"30": {
    "doc": "TIL (23-07-06)",
    "title": "TIL (23-07-06)",
    "content": " ",
    "url": "/docs/tils/230706/",
    
    "relUrl": "/docs/tils/230706/"
  },"31": {
    "doc": "과제 진행하기",
    "title": "과제 진행하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230711/",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/"
  },"32": {
    "doc": "과제 진행하기",
    "title": "2023.07.11 (TUE)",
    "content": ". 문제 : 프로그래머스 - LV2. 과제 진행하기 . ",
    "url": "/docs/codingtest/1day1coding/230711/#20230711-tue",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#20230711-tue"
  },"33": {
    "doc": "과제 진행하기",
    "title": "접근법",
    "content": "조건 . | 과제는 시작하기로 한 시각이 되면 시작 | 새로운 과제를 할 시간이면, 기존에 하고 있던 과제를 멈추고 새로운 과제를 시작 . | 만약, 과제를 끝낸 시각에 우선순위는, 새로 시작해야 하는 과제 &gt; 잠시 멈춰둔 과제 | . | 멈춰둔 과제는 가장 최근에 멈춘 과제부터 시작 | . 해결법 . | plans 배열을 시작 시간을 기준으로 정렬한다. | 스택을 활용하여 잠시 멈춘 과제를 넣는다. | 조건 우선순위에 맞게 코드를 구현한다. | . ",
    "url": "/docs/codingtest/1day1coding/230711/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#접근법"
  },"34": {
    "doc": "과제 진행하기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public String[] solution(String[][] plans) { String[] answer = new String[plans.length]; int answer_count = 0; Queue&lt;String&gt; q_name = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; q_time = new LinkedList&lt;&gt;(); // plans 정렬 Arrays.sort(plans, new Comparator&lt;String[]&gt;() { @Override public int compare(String[] arr1, String[] arr2) { String[] time1 = arr1[1].split(\":\"); String[] time2 = arr2[1].split(\":\"); int hourCompare = Integer.parseInt(time1[0]) - Integer.parseInt(time2[0]); int minuteCompare = Integer.parseInt(time1[1]) - Integer.parseInt(time2[1]); return hourCompare != 0 ? hourCompare : minuteCompare; } }); // 시작 시간 정하기 int curTime = toMin(plans[0]); // 현재 시각 String curPlan = plans[0][0]; // 현재 과제명 int remainTime = Integer.parseInt(plans[0][2]); // 현재 과제 남은 시간 int count = 1; // 대기 중인 과제 순서 Stack&lt;String&gt; s_String = new Stack&lt;&gt;(); // 잠시 멈춘 과제명 Stack&lt;Integer&gt; s_Int = new Stack&lt;&gt;(); // 잠시 멈춘 과제 남은 시간 // 진행 while (answer_count &lt; plans.length) { curTime++; remainTime--; if (remainTime == 0) { // 시간이 다 되면 answer[answer_count] = curPlan; answer_count++; curPlan = \"\"; if (curTime == toMin(plans[count])) { // 다음 과제 시간이라면 curPlan = plans[count][0]; remainTime = Integer.parseInt(plans[count][2]); count++; if (count == plans.length) { count = 0; } } else if (!s_String.empty()) { // 잠시 멈춘 과제가 있다면 curPlan = s_String.pop(); remainTime = s_Int.pop(); } } else if (curTime == toMin(plans[count])) { // 다음 과제를 시작해야 한다면 // 저장 if (!curPlan.equals(\"\")) { s_String.push(curPlan); s_Int.push(remainTime); } curPlan = plans[count][0]; remainTime = Integer.parseInt(plans[count][2]); count++; if (count == plans.length) { count = 0; } } } return answer; } public static int toMin(String[] strs) { String[] time = strs[1].split(\":\"); return Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]); } } . ",
    "url": "/docs/codingtest/1day1coding/230711/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#결과-코드"
  },"35": {
    "doc": "TIL (23-07-11)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230711/#til",
    
    "relUrl": "/docs/tils/230711/#til"
  },"36": {
    "doc": "TIL (23-07-11)",
    "title": "2023.07.11 (TUE)",
    "content": ". 📌  오늘의 TIL . | 프로그래머스 자바 코딩테스트 강의 신청 | 😵‍💫 코테 연습 . | 과제 진행하기 | . | . 📔 To Do Plan . | 1일 1코테연습 | 퐁당 매거진 프로젝트 | ? 백엔드 오픈소스 프로젝트 | ? 게임 서버 제작 | . ✏️  오늘의 체크 사항 . | 운동 - 어깨 | . ",
    "url": "/docs/tils/230711/#20230711-tue",
    
    "relUrl": "/docs/tils/230711/#20230711-tue"
  },"37": {
    "doc": "TIL (23-07-11)",
    "title": "TIL (23-07-11)",
    "content": " ",
    "url": "/docs/tils/230711/",
    
    "relUrl": "/docs/tils/230711/"
  },"38": {
    "doc": "제작 일지 <3>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;3&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-3",
    
    "relUrl": "/docs/projects/pongdang/230713/#퐁당-웹-매거진-프로젝트-제작-일지-3"
  },"39": {
    "doc": "제작 일지 <3>",
    "title": "2023.07.13 (THU)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230713/#20230713-thu",
    
    "relUrl": "/docs/projects/pongdang/230713/#20230713-thu"
  },"40": {
    "doc": "제작 일지 <3>",
    "title": "1. Font CSS 적용",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#1-font-css-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/projects/pongdang/230713/#1-font-css-적용"
  },"41": {
    "doc": "제작 일지 <3>",
    "title": "2. 부트스트랩 라이브러리 적용",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#2-%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/projects/pongdang/230713/#2-부트스트랩-라이브러리-적용"
  },"42": {
    "doc": "제작 일지 <3>",
    "title": "제작 일지 <3>",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/",
    
    "relUrl": "/docs/projects/pongdang/230713/"
  },"43": {
    "doc": "TIL (23-07-13)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230713/#til",
    
    "relUrl": "/docs/tils/230713/#til"
  },"44": {
    "doc": "TIL (23-07-13)",
    "title": "2023.07.13 (THU)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 연습 . | 과제 진행하기 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어깨 | . ",
    "url": "/docs/tils/230713/#20230713-thu",
    
    "relUrl": "/docs/tils/230713/#20230713-thu"
  },"45": {
    "doc": "TIL (23-07-13)",
    "title": "TIL (23-07-13)",
    "content": " ",
    "url": "/docs/tils/230713/",
    
    "relUrl": "/docs/tils/230713/"
  },"46": {
    "doc": "제작 일지 <4>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;4&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230717/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-4",
    
    "relUrl": "/docs/projects/pongdang/230717/#퐁당-웹-매거진-프로젝트-제작-일지-4"
  },"47": {
    "doc": "제작 일지 <4>",
    "title": "2023.07.17 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230717/#20230717-mon",
    
    "relUrl": "/docs/projects/pongdang/230717/#20230717-mon"
  },"48": {
    "doc": "제작 일지 <4>",
    "title": "1. 슬라이드",
    "content": ". 구현 코드 . import React, { useState } from 'react'; import \"./Slider.css\"; import Carousel from 'react-bootstrap/Carousel'; export default function Slider() { const [index, setIndex] = useState(0); const handleSelect = (selectedIndex) =&gt; { setIndex(selectedIndex); }; return ( &lt;Carousel activeIndex={index} onSelect={handleSelect}&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;/Carousel&gt; ); } . ",
    "url": "/docs/projects/pongdang/230717/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/projects/pongdang/230717/#1-슬라이드"
  },"49": {
    "doc": "제작 일지 <4>",
    "title": "제작 일지 <4>",
    "content": " ",
    "url": "/docs/projects/pongdang/230717/",
    
    "relUrl": "/docs/projects/pongdang/230717/"
  },"50": {
    "doc": "TIL (23-07-17)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230717/#til",
    
    "relUrl": "/docs/tils/230717/#til"
  },"51": {
    "doc": "TIL (23-07-17)",
    "title": "2023.07.17 (MON)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 연습 . | 과제 진행하기 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230717/#20230717-mon",
    
    "relUrl": "/docs/tils/230717/#20230717-mon"
  },"52": {
    "doc": "TIL (23-07-17)",
    "title": "TIL (23-07-17)",
    "content": " ",
    "url": "/docs/tils/230717/",
    
    "relUrl": "/docs/tils/230717/"
  },"53": {
    "doc": "전력망을 둘로 나누기",
    "title": "과제 진행하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230719/#%EA%B3%BC%EC%A0%9C-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#과제-진행하기"
  },"54": {
    "doc": "전력망을 둘로 나누기",
    "title": "2023.07.19 (WED)",
    "content": ". 문제 : 프로그래머스 - LV2. 전력망을 둘로 나누기 . ",
    "url": "/docs/codingtest/1day1coding/230719/#20230719-wed",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#20230719-wed"
  },"55": {
    "doc": "전력망을 둘로 나누기",
    "title": "접근법",
    "content": "조건 및 설명 . | n개의 송전탑이 하나의 트리 형태로 연결 | 전선들 중 하나를 끊어서, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 한다. | 두 전력망의 송전탑 개수의 차이를 return | . 해결법 . | 모두 탐색을 해도 되는 문제기 때문에, BFS를 사용한다. | 매번 가장 작은 값을 저장한다. | 자른 기준으로, 두 개의 노드를 탐색하여 갯수를 센다. | . ",
    "url": "/docs/codingtest/1day1coding/230719/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#접근법"
  },"56": {
    "doc": "전력망을 둘로 나누기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int solution(int n, int[][] wires) { int answer = -1; public static boolean[] visited = new boolean[n]; for (int i = 0; i &lt; n; i ++) { } return answer; } public static int bfs(int start, boolean[] visited) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(start); // current node visited visited[start] = true; while(!q.isEmpty()) { int x = q.poll(); for (int i = 0; i &lt; visited.length; i++) { // ... } } } } . ",
    "url": "/docs/codingtest/1day1coding/230719/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#결과-코드"
  },"57": {
    "doc": "전력망을 둘로 나누기",
    "title": "전력망을 둘로 나누기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230719/",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/"
  },"58": {
    "doc": "TIL (23-07-20)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230720/#til",
    
    "relUrl": "/docs/tils/230720/#til"
  },"59": {
    "doc": "TIL (23-07-20)",
    "title": "2023.07.20 (THU)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 피드백 . | (!) 경험치 - 정규식 | . | . ✏️  오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230720/#20230720-thu",
    
    "relUrl": "/docs/tils/230720/#20230720-thu"
  },"60": {
    "doc": "TIL (23-07-20)",
    "title": "TIL (23-07-20)",
    "content": " ",
    "url": "/docs/tils/230720/",
    
    "relUrl": "/docs/tils/230720/"
  },"61": {
    "doc": "(!) 경험치 - 정규식",
    "title": "(!)경험치 - 정규식",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230720/#%EA%B2%BD%ED%97%98%EC%B9%98---%EC%A0%95%EA%B7%9C%EC%8B%9D",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#경험치---정규식"
  },"62": {
    "doc": "(!) 경험치 - 정규식",
    "title": "2023.07.20 (THU)",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/230720/#20230720-thu",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#20230720-thu"
  },"63": {
    "doc": "(!) 경험치 - 정규식",
    "title": "코딩 테스트를 보았다.",
    "content": "쉬운 문제에서 나를 붙잡는 이슈가 생겨버렸다. ",
    "url": "/docs/codingtest/1day1coding/230720/#%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%B3%B4%EC%95%98%EB%8B%A4",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#코딩-테스트를-보았다"
  },"64": {
    "doc": "(!) 경험치 - 정규식",
    "title": "정규식…",
    "content": "나는 지금까지 정규식에 대해 그렇게 깊이 알고 있지 않았다. 그 문제 또한, 사실 정규식이 없어도 풀 수 있는 문제라고 생각하고 풀었지만, 나의 엄청난 무지로 인해 계속 집착하게 되었다.. 문제의 코드다. str.split(\".\"); . 내 생각 : 외 않되..? (ㅋㅋ) . 자세히 알아보기 위해서는 split 함수에 대해서 알아보자. public String[] split(String regex) // 옳게된 함수 public String[] split(String string) // 멍청한 나의 머리에서 나온.. 나는 매개변수로 단지 string을 기준으로 나누는 함수 정도로 알고 있었다. 하지만 매개변수는 정규식이었다. 정규식에서의 ”.”은 개행 문자(\\n)을 제외한 모든 문자를 나타내는 메타 문자이다. 그래서 코드가 작동하지 않은건 당연한 것이였다.. 때문에 이스케이프 문자를 사용하여 다음과 같이 수정해야 한다. str.split(\"\\\\.\"); . 이런 사소한 지식들은 경험치처럼 쌓이고 쌓여, 나의 레벨업을 돕는다.. ",
    "url": "/docs/codingtest/1day1coding/230720/#%EC%A0%95%EA%B7%9C%EC%8B%9D",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#정규식"
  },"65": {
    "doc": "(!) 경험치 - 정규식",
    "title": "(!) 경험치 - 정규식",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230720/",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/"
  },"66": {
    "doc": "TIL (23-07-25)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230725/#til",
    
    "relUrl": "/docs/tils/230725/#til"
  },"67": {
    "doc": "TIL (23-07-25)",
    "title": "2023.07.25 (TUE)",
    "content": ". 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230725/#20230725-tue",
    
    "relUrl": "/docs/tils/230725/#20230725-tue"
  },"68": {
    "doc": "TIL (23-07-25)",
    "title": "TIL (23-07-25)",
    "content": " ",
    "url": "/docs/tils/230725/",
    
    "relUrl": "/docs/tils/230725/"
  },"69": {
    "doc": "제작 일지 <5>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;5&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230725/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-5",
    
    "relUrl": "/docs/projects/pongdang/230725/#퐁당-웹-매거진-프로젝트-제작-일지-5"
  },"70": {
    "doc": "제작 일지 <5>",
    "title": "2023.07.25 (TUE)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230725/#20230725-tue",
    
    "relUrl": "/docs/projects/pongdang/230725/#20230725-tue"
  },"71": {
    "doc": "제작 일지 <5>",
    "title": "1. 슬라이드",
    "content": ". 구현 코드 . import React, { useState } from 'react'; import \"./Slider.css\"; import Carousel from 'react-bootstrap/Carousel'; export default function Slider() { const [index, setIndex] = useState(0); const handleSelect = (selectedIndex) =&gt; { setIndex(selectedIndex); }; return ( &lt;Carousel activeIndex={index} onSelect={handleSelect}&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;/Carousel&gt; ); } . ",
    "url": "/docs/projects/pongdang/230725/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/projects/pongdang/230725/#1-슬라이드"
  },"72": {
    "doc": "제작 일지 <5>",
    "title": "제작 일지 <5>",
    "content": " ",
    "url": "/docs/projects/pongdang/230725/",
    
    "relUrl": "/docs/projects/pongdang/230725/"
  },"73": {
    "doc": "TIL (23-07-31)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230731/#til",
    
    "relUrl": "/docs/tils/230731/#til"
  },"74": {
    "doc": "TIL (23-07-31)",
    "title": "2023.07.25 (MON)",
    "content": ". 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230731/#20230725-mon",
    
    "relUrl": "/docs/tils/230731/#20230725-mon"
  },"75": {
    "doc": "TIL (23-07-31)",
    "title": "TIL (23-07-31)",
    "content": " ",
    "url": "/docs/tils/230731/",
    
    "relUrl": "/docs/tils/230731/"
  },"76": {
    "doc": "제작 일지 <6>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;6&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230731/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-6",
    
    "relUrl": "/docs/projects/pongdang/230731/#퐁당-웹-매거진-프로젝트-제작-일지-6"
  },"77": {
    "doc": "제작 일지 <6>",
    "title": "2023.07.31 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230731/#20230731-mon",
    
    "relUrl": "/docs/projects/pongdang/230731/#20230731-mon"
  },"78": {
    "doc": "제작 일지 <6>",
    "title": "1. 슬라이드 재조정",
    "content": "사이드 버튼들을 투명화 시켜, 조금 더 자연스럽게 만들어 준다. ",
    "url": "/docs/projects/pongdang/230731/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%9E%AC%EC%A1%B0%EC%A0%95",
    
    "relUrl": "/docs/projects/pongdang/230731/#1-슬라이드-재조정"
  },"79": {
    "doc": "제작 일지 <6>",
    "title": "제작 일지 <6>",
    "content": " ",
    "url": "/docs/projects/pongdang/230731/",
    
    "relUrl": "/docs/projects/pongdang/230731/"
  },"80": {
    "doc": "TIL (23-08-08)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230808/#til",
    
    "relUrl": "/docs/tils/230808/#til"
  },"81": {
    "doc": "TIL (23-08-08)",
    "title": "2023.08.08 (TUE)",
    "content": ". 📔 To Do . | 1일 1코테연습 | 책 “오브젝트” | 퐁당 매거진 프로젝트 | . 📌  오늘의 TIL . | !! | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230808/#20230808-tue",
    
    "relUrl": "/docs/tils/230808/#20230808-tue"
  },"82": {
    "doc": "TIL (23-08-08)",
    "title": "TIL (23-08-08)",
    "content": " ",
    "url": "/docs/tils/230808/",
    
    "relUrl": "/docs/tils/230808/"
  },"83": {
    "doc": "제작 일지 <7>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;7&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230816/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-7",
    
    "relUrl": "/docs/projects/pongdang/230816/#퐁당-웹-매거진-프로젝트-제작-일지-7"
  },"84": {
    "doc": "제작 일지 <7>",
    "title": "2023.08.16 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230816/#20230816-wed",
    
    "relUrl": "/docs/projects/pongdang/230816/#20230816-wed"
  },"85": {
    "doc": "제작 일지 <7>",
    "title": "1. 메인페이지 1차 완성",
    "content": ". | 퐁당 매거진 홈페이지 | . 전체적으로 사이즈를 키웠고, 요구사항에 맞는 디자인을 하였다. 새롭게 깨달은 점은, 리액트에서 컴포넌트를 모을 때, ClassName을 다른 모듈이더라도 같은 이름을 쓰면 안된다는 것이였다. 이것 때문에 충돌나서 헤맸던 적이.. ",
    "url": "/docs/projects/pongdang/230816/#1-%EB%A9%94%EC%9D%B8%ED%8E%98%EC%9D%B4%EC%A7%80-1%EC%B0%A8-%EC%99%84%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/230816/#1-메인페이지-1차-완성"
  },"86": {
    "doc": "제작 일지 <7>",
    "title": "제작 일지 <7>",
    "content": " ",
    "url": "/docs/projects/pongdang/230816/",
    
    "relUrl": "/docs/projects/pongdang/230816/"
  },"87": {
    "doc": "TIL (23-08-16)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230816/#til",
    
    "relUrl": "/docs/tils/230816/#til"
  },"88": {
    "doc": "TIL (23-08-16)",
    "title": "2023.08.08 (WED)",
    "content": ". 📔 To Do . | 1일 1코테연습 | 퐁당 매거진 프로젝트 | AWS 자격증 시험 | 책 “오브젝트” | . 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 가슴 | . ",
    "url": "/docs/tils/230816/#20230808-wed",
    
    "relUrl": "/docs/tils/230816/#20230808-wed"
  },"89": {
    "doc": "TIL (23-08-16)",
    "title": "TIL (23-08-16)",
    "content": " ",
    "url": "/docs/tils/230816/",
    
    "relUrl": "/docs/tils/230816/"
  },"90": {
    "doc": "TIL (23-08-19)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230819/#til",
    
    "relUrl": "/docs/tils/230819/#til"
  },"91": {
    "doc": "TIL (23-08-19)",
    "title": "2023.08.19 (SAT)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | 숫자 게임 | . | AWS 자격증 시험 | 책 “오브젝트” | 퐁당 매거진 프로젝트 (업로드 사항 있을 경우) | . 😄 Want To Do (하고 싶은 것) . | 게임 서버 개발 . | 프로젝트 계획 | . | 마인크래프트 코드 개조 해보기 | 깃헙 블로그 포트폴리오 | 지원서 넣기 | . ",
    "url": "/docs/tils/230819/#20230819-sat",
    
    "relUrl": "/docs/tils/230819/#20230819-sat"
  },"92": {
    "doc": "TIL (23-08-19)",
    "title": "TIL (23-08-19)",
    "content": " ",
    "url": "/docs/tils/230819/",
    
    "relUrl": "/docs/tils/230819/"
  },"93": {
    "doc": "숫자 게임",
    "title": "숫자 게임",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230819/",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/"
  },"94": {
    "doc": "숫자 게임",
    "title": "2023.08.19 (SAT)",
    "content": ". 문제 : 프로그래머스 - LV3. 숫자 게임 . ",
    "url": "/docs/codingtest/1day1coding/230819/#20230819-sat",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#20230819-sat"
  },"95": {
    "doc": "숫자 게임",
    "title": "조건 및 설명",
    "content": ". | N명의 팀원 | . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#조건-및-설명"
  },"96": {
    "doc": "숫자 게임",
    "title": "접근법",
    "content": ". | 남은 팀원들 중, 최소한의 숫자로 이길 수 있는 사람으로 대려감 | 두 배열을 Sort 후, 앞에서부터 서로 비교하여 count | . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#접근법"
  },"97": {
    "doc": "숫자 게임",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int solution(int[] A, int[] B) { int answer = 0; int count = 0; Arrays.sort(A); Arrays.sort(B); // Game Start for (int i = 0; i &lt; A.length; i++) { for (int j = count; j &lt; A.length; j++) { if (A[i] &lt; B[j]) { // 이기면 answer++; count++; break; } else { // 비기거나 지면 count++; } } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#결과-코드"
  },"98": {
    "doc": "이론 일지 <1>",
    "title": "토이 프로젝트 - 게임 서버 - 이론 일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/230819/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%EC%9D%B4%EB%A1%A0-%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/gameServer/230819/#토이-프로젝트---게임-서버---이론-일지-1"
  },"99": {
    "doc": "이론 일지 <1>",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230819/#20230819-sat",
    
    "relUrl": "/docs/projects/gameServer/230819/#20230819-sat"
  },"100": {
    "doc": "이론 일지 <1>",
    "title": "1. 프로세스",
    "content": "프로그램에 있는 코드와 데이터를 프로세스 메모리로 불러들이는데, 이를 로딩된다고 할 수 있다. 프로세스는 RAM에 있다. 프로세스가 여러 개 실행되고 있는 것을 멀티프로세싱이라고 한다. ",
    "url": "/docs/projects/gameServer/230819/#1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4",
    
    "relUrl": "/docs/projects/gameServer/230819/#1-프로세스"
  },"101": {
    "doc": "이론 일지 <1>",
    "title": "2. 스레드",
    "content": "기본 적으로 서로 다른 프로세스는 상대방의 메모리 공간을 읽고 쓸 수 없다. 하미잔, 한 프로세스 안에 있는 스레드들은, 프로세스 안에 있는 메모리 공간을 같이 사용할 수 있다. 스레드 = 프로그램이 실행되는 기본 단위 . ",
    "url": "/docs/projects/gameServer/230819/#2-%EC%8A%A4%EB%A0%88%EB%93%9C",
    
    "relUrl": "/docs/projects/gameServer/230819/#2-스레드"
  },"102": {
    "doc": "이론 일지 <1>",
    "title": "이론 일지 <1>",
    "content": " ",
    "url": "/docs/projects/gameServer/230819/",
    
    "relUrl": "/docs/projects/gameServer/230819/"
  },"103": {
    "doc": "프로젝트 계획",
    "title": "토이 프로젝트 - 게임 서버 - 프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230819_2/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#토이-프로젝트---게임-서버---프로젝트-계획"
  },"104": {
    "doc": "프로젝트 계획",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230819_2/#20230819-sat",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#20230819-sat"
  },"105": {
    "doc": "프로젝트 계획",
    "title": "프레임워크",
    "content": "서버(스프링부트) + 게임 프레임워크(LibGDX, 일단 써보기) . ",
    "url": "/docs/projects/gameServer/230819_2/#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#프레임워크"
  },"106": {
    "doc": "프로젝트 계획",
    "title": "순서",
    "content": ". | 스프링 부트 프로젝트 생성: 우선 스프링 부트 프로젝트를 생성합니다. Spring Initializr를 이용하면 간단하게 프로젝트를 생성할 수 있습니다. https://start.spring.io/ | 게임 개발 프레임워크 선택: 자바 게임 개발에서는 여러 가지 프레임워크와 라이브러리를 사용할 수 있습니다. 대표적인 예로는 LibGDX, jMonkeyEngine, LWJGL 등이 있습니다. 이 중에서 가장 인기 있는 LibGDX를 선택하고 해당 라이브러리를 스프링 부트 프로젝트에 포함시킵니다. | 게임 API 연결: 선택한 게임 프레임워크의 API를 스프링 부트에 연결합니다. 이를 위해서는 라이브러리를 확인하고 관련 API 연동 방법을 찾아보는 것이 좋습니다. | 게임 서버 개발: 스프링 부트를 이용하여 게임 서버를 구현합니다. 게임 프레임워크에서 제공하는 서버 기능을 활용하여 스프링 부트 서버와 연동합니다. | 게임 클라이언트 개발: 게임 클라이언트에서는 개발한 스프링 부트 서버와 통신하여 게임을 실행합니다. HTTP와 WebSocket을 이용하여 통신할 수 있습니다. | 요청과 응답 처리: 게임 클라이언트에서 서버로 요청을 보내고, 서버에서는 그에 대한 응답을 처리합니다. 스프링 부트에서 HTTP 요청 및 WebSocket 연결을 처리하는 Controller를 개발하면 됩니다. 이러한 방법으로 스프링 부트와 자바 게임 개발을 연결할 수 있습니다. 하지만, 이는 어려운 작업이므로 충분한 경험과 지식이 필요합니다. 또한, 자바 게임 개발과 스프링 부트가 서로 다른 도메인이므로 그에 따른 요구사항과 성능 이슈 등을 고려해야 합니다. | . ",
    "url": "/docs/projects/gameServer/230819_2/#%EC%88%9C%EC%84%9C",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#순서"
  },"107": {
    "doc": "프로젝트 계획",
    "title": "프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230819_2/",
    
    "relUrl": "/docs/projects/gameServer/230819_2/"
  },"108": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "토이 프로젝트 - 게임 서버 - 프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/230822/#토이-프로젝트---게임-서버---프로젝트-계획"
  },"109": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "2023.08.22 (TUE)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230822/#20230822-tue",
    
    "relUrl": "/docs/projects/gameServer/230822/#20230822-tue"
  },"110": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "기본 세팅 끝",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/#%EA%B8%B0%EB%B3%B8-%EC%84%B8%ED%8C%85-%EB%81%9D",
    
    "relUrl": "/docs/projects/gameServer/230822/#기본-세팅-끝"
  },"111": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "개발 순서 설계",
    "content": ". | 맵, 플레이어 만들기 | 서버 연결 (2023.08.24 ~) | . ",
    "url": "/docs/projects/gameServer/230822/#%EA%B0%9C%EB%B0%9C-%EC%88%9C%EC%84%9C-%EC%84%A4%EA%B3%84",
    
    "relUrl": "/docs/projects/gameServer/230822/#개발-순서-설계"
  },"112": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "GDX 프로젝트 생성 및 개발 시작",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/",
    
    "relUrl": "/docs/projects/gameServer/230822/"
  },"113": {
    "doc": "TIL (23-08-24)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230824/#til",
    
    "relUrl": "/docs/tils/230824/#til"
  },"114": {
    "doc": "TIL (23-08-24)",
    "title": "2023.08.24 (SAT)",
    "content": ". 📔 To Do (반드시!!) . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . | 게임 서버 개발 . | 프로젝트 계획 | . | . ",
    "url": "/docs/tils/230824/#20230824-sat",
    
    "relUrl": "/docs/tils/230824/#20230824-sat"
  },"115": {
    "doc": "TIL (23-08-24)",
    "title": "TIL (23-08-24)",
    "content": " ",
    "url": "/docs/tils/230824/",
    
    "relUrl": "/docs/tils/230824/"
  },"116": {
    "doc": "TIL (23-08-30)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230830/#til",
    
    "relUrl": "/docs/tils/230830/#til"
  },"117": {
    "doc": "TIL (23-08-30)",
    "title": "2023.08.30 (WED)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | 입력 할 때는, Scanner보다 BufferedReader가 훨씬 빠르다! . | BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); . | . | . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230830/#20230830-wed",
    
    "relUrl": "/docs/tils/230830/#20230830-wed"
  },"118": {
    "doc": "TIL (23-08-30)",
    "title": "TIL (23-08-30)",
    "content": " ",
    "url": "/docs/tils/230830/",
    
    "relUrl": "/docs/tils/230830/"
  },"119": {
    "doc": "One Walk",
    "title": "One Walk",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230830/",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/"
  },"120": {
    "doc": "One Walk",
    "title": "2023.08.19 (SAT)",
    "content": ". 문제 : 백준 - 29333. One Walk . ",
    "url": "/docs/codingtest/1day1coding/230830/#20230819-sat",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#20230819-sat"
  },"121": {
    "doc": "One Walk",
    "title": "조건 및 설명",
    "content": ". | 무방향 단순 그래프 G | 주어지는 변수 : 정점의 개수 N, 간선의 개수 M, 시작점 번호 S, 도착점 번호 E | 그 다음은 M개의 줄에서 간선으로 연결된 두 정점의 번호(u,v)가 주어진다. | 단 하나가 되도록 만들 수 없다면 -1을 출력, 그렇지 않으면 모든 간선의 방향을 입력된 순서대로 한 줄에 출력 (u -&gt; v : 0, v -&gt; u : 1) | . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#조건-및-설명"
  },"122": {
    "doc": "One Walk",
    "title": "접근법",
    "content": ". | 시작점부터 시작하여, 도착점까지 한 가지만 나오는 경우를 탐색한다. | 이럴 때는, | . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#접근법"
  },"123": {
    "doc": "One Walk",
    "title": "결과 코드",
    "content": "import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { int N, M, S, E; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); M = Integer.parseInt(st.nextToken()); S = Integer.parseInt(st.nextToken()) - 1; E = Integer.parseInt(st.nextToken()) - 1; int[] answer = new int[M]; int[][] edge = new int[M][2]; for (int i = 0; i &lt; M; i++) { st = new StringTokenizer(br.readLine()); edge[i][0] = Integer.parseInt(st.nextToken()) - 1; edge[i][1] = Integer.parseInt(st.nextToken()) - 1; } } } . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#결과-코드"
  },"124": {
    "doc": "TIL (23-09-01)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230901/#til",
    
    "relUrl": "/docs/tils/230901/#til"
  },"125": {
    "doc": "TIL (23-09-01)",
    "title": "2023.09.01 (FRI)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230901/#20230901-fri",
    
    "relUrl": "/docs/tils/230901/#20230901-fri"
  },"126": {
    "doc": "TIL (23-09-01)",
    "title": "TIL (23-09-01)",
    "content": " ",
    "url": "/docs/tils/230901/",
    
    "relUrl": "/docs/tils/230901/"
  },"127": {
    "doc": "TIL (23-09-04)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230904/#til",
    
    "relUrl": "/docs/tils/230904/#til"
  },"128": {
    "doc": "TIL (23-09-04)",
    "title": "2023.09.04 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 - 1 | 기본 요약 - 2 | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230904/#20230904-mon",
    
    "relUrl": "/docs/tils/230904/#20230904-mon"
  },"129": {
    "doc": "TIL (23-09-04)",
    "title": "TIL (23-09-04)",
    "content": " ",
    "url": "/docs/tils/230904/",
    
    "relUrl": "/docs/tils/230904/"
  },"130": {
    "doc": "TIL (23-09-04)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230905/#til",
    
    "relUrl": "/docs/tils/230905/#til"
  },"131": {
    "doc": "TIL (23-09-04)",
    "title": "2023.09.04 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230905/#20230904-mon",
    
    "relUrl": "/docs/tils/230905/#20230904-mon"
  },"132": {
    "doc": "TIL (23-09-04)",
    "title": "TIL (23-09-04)",
    "content": " ",
    "url": "/docs/tils/230905/",
    
    "relUrl": "/docs/tils/230905/"
  },"133": {
    "doc": "제작 일지 <8>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;8&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230906/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-8",
    
    "relUrl": "/docs/projects/pongdang/230906/#퐁당-웹-매거진-프로젝트-제작-일지-8"
  },"134": {
    "doc": "제작 일지 <8>",
    "title": "2023.09.07 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230906/#20230907-wed",
    
    "relUrl": "/docs/projects/pongdang/230906/#20230907-wed"
  },"135": {
    "doc": "제작 일지 <8>",
    "title": "1. 라우팅 처리",
    "content": "스프링부트와 리액트를 함꼐 쓰는 중에, 다른 페이지로 가기 위한 라우팅을 해야할 때가 왔다. 1-1. 리액트 . 리액트에서는 컴포넌트로 나누어 App.js에서 라우팅 처리를 한다. function App() { return ( &lt;BrowserRouter&gt; &lt;div className=\"App\"&gt; &lt;Route path=\"/\" exact component={Main}&gt;&lt;/Route&gt; &lt;Route path=\"/test\" component={Test}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ); } . 1-2. 스프링부트 . 로컬에서는 ‘/’, ‘/test’ 모두 접속이 가능하다. 하지만 스프링부트에 연결한 서버에 접속하면, ‘/test’엔 접속이 되지 않고 404에러가 나온다. Controller를 사용하면 이 문제가 해결된다. 일단 임시로 모든 경로를 연결해준다. @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } } . ",
    "url": "/docs/projects/pongdang/230906/#1-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/projects/pongdang/230906/#1-라우팅-처리"
  },"136": {
    "doc": "제작 일지 <8>",
    "title": "제작 일지 <8>",
    "content": " ",
    "url": "/docs/projects/pongdang/230906/",
    
    "relUrl": "/docs/projects/pongdang/230906/"
  },"137": {
    "doc": "TIL (23-09-11)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230911/#til",
    
    "relUrl": "/docs/tils/230911/#til"
  },"138": {
    "doc": "TIL (23-09-11)",
    "title": "2023.09.11 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 😵‍💫 1일 1코테연습 . | 적록색약 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . 😄 Want To Do (하고 싶은 것) . | AWS 워크샵 강의 . | AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기 | . | . ",
    "url": "/docs/tils/230911/#20230911-mon",
    
    "relUrl": "/docs/tils/230911/#20230911-mon"
  },"139": {
    "doc": "TIL (23-09-11)",
    "title": "TIL (23-09-11)",
    "content": " ",
    "url": "/docs/tils/230911/",
    
    "relUrl": "/docs/tils/230911/"
  },"140": {
    "doc": "적록색약",
    "title": "적록색약",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230911/",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/"
  },"141": {
    "doc": "적록색약",
    "title": "2023.09.11 (MON)",
    "content": ". 문제 : 백준 - 10026. 적록색약 . ",
    "url": "/docs/codingtest/1day1coding/230911/#20230911-mon",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#20230911-mon"
  },"142": {
    "doc": "적록색약",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230911/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#조건-및-설명"
  },"143": {
    "doc": "적록색약",
    "title": "접근법",
    "content": ". | 두 가지(색약, 색약이 아닌)으로 나눈다. | BFS로 한 구역씩 정한다. | . ",
    "url": "/docs/codingtest/1day1coding/230911/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#접근법"
  },"144": {
    "doc": "적록색약",
    "title": "결과 코드",
    "content": "import java.util.*; import java.io.*; public class Main { static char[][] map; static boolean[][] visited; static ArrayDeque&lt;Char&gt; queue = new ArrayDeque&lt;&gt;(); static int no_Cb = 0; static int yes_Cb = 0; public static void main(String[] args) throws Exception { int size; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); size = Integer.parseInt(st.nextToken()); // input size // init map = new char[size][size]; bvisited = new boolean[size][size]; // input for (int i = 0; i &lt; size; i++) { st = new StringTokenizer(br.readLine()); String str = st.nextToken(); for (int j = 0; j &lt; size; j++) { map[i][j] = str.charAt(j); visited[i][j] = false; } } } // 1. no Color blindness public static int bfs_no(int start_x, int start_y char[][] map, boolean[][] visited) { visited[start_x][start_y] = true; queue.add(map[start_x][start_y]); while (!queue.isEmpty()) { char ch = queue.poll(); } } } . ",
    "url": "/docs/codingtest/1day1coding/230911/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#결과-코드"
  },"145": {
    "doc": "TIL (23-09-12)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230912/#til",
    
    "relUrl": "/docs/tils/230912/#til"
  },"146": {
    "doc": "TIL (23-09-12)",
    "title": "2023.09.12 (TUE)",
    "content": ". 📔 To Do (반드시!!) . | AWS 자격증 시험 . | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230912/#20230912-tue",
    
    "relUrl": "/docs/tils/230912/#20230912-tue"
  },"147": {
    "doc": "TIL (23-09-12)",
    "title": "TIL (23-09-12)",
    "content": " ",
    "url": "/docs/tils/230912/",
    
    "relUrl": "/docs/tils/230912/"
  },"148": {
    "doc": "TIL (23-09-13)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230913/#til",
    
    "relUrl": "/docs/tils/230913/#til"
  },"149": {
    "doc": "TIL (23-09-13)",
    "title": "2023.09.13 (WED)",
    "content": ". AWS 자격증 시험 . SAA에서 DA로 변경하였다. 아무래도 지금 프로젝트와 직무 연관성이 DA쪽이 더 높은 것 같다고 판단하였다. 강의는 Udemy에서 제공하는 강사 스테판 마렉 (Stephane Maarek)의 AWS 자격증 강의이다. 평이 매우 좋고, 프리뷰를 봤는데 매우 호감이었다! . 글로벌 서비스는 리전 선택이 나오지 않는 것이 정상. EC2와 같은 서비스는 리전 선택이 필수. 또한, AWS의 모든 서비스는 모든 리전에 존재하는 것이 아니다. ",
    "url": "/docs/tils/230913/#20230913-wed",
    
    "relUrl": "/docs/tils/230913/#20230913-wed"
  },"150": {
    "doc": "TIL (23-09-13)",
    "title": "TIL (23-09-13)",
    "content": " ",
    "url": "/docs/tils/230913/",
    
    "relUrl": "/docs/tils/230913/"
  },"151": {
    "doc": "TIL (23-09-14)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230914/#til",
    
    "relUrl": "/docs/tils/230914/#til"
  },"152": {
    "doc": "TIL (23-09-14)",
    "title": "2023.09.14 (THU)",
    "content": ". IAM: Users &amp; Groups . | IAM에서는 사용자를 생성하고 그룹에 배치하기 때문에, 글로벌 서비스이다. | 루트 어카운트는 기본으로 만들어진다. 이후, 루트는 사용되거나 공유되면 안된다. | 사용자와 그룹을 만들어 사용한다. | . ",
    "url": "/docs/tils/230914/#20230914-thu",
    
    "relUrl": "/docs/tils/230914/#20230914-thu"
  },"153": {
    "doc": "TIL (23-09-14)",
    "title": "TIL (23-09-14)",
    "content": " ",
    "url": "/docs/tils/230914/",
    
    "relUrl": "/docs/tils/230914/"
  },"154": {
    "doc": "ATM",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230915/",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/"
  },"155": {
    "doc": "ATM",
    "title": "2023.09.15 (FRI)",
    "content": ". 문제 : 백준 - 11399. ATM . ",
    "url": "/docs/codingtest/1day1coding/230915/#20230915-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#20230915-fri"
  },"156": {
    "doc": "ATM",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230915/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#조건-및-설명"
  },"157": {
    "doc": "ATM",
    "title": "접근법",
    "content": ". | 그리디를 사용하여 작은 숫자부터 Sort한 후, 계산한다. | . ",
    "url": "/docs/codingtest/1day1coding/230915/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#접근법"
  },"158": {
    "doc": "ATM",
    "title": "결과 코드",
    "content": "/* * Title : ATM * Link : https://www.acmicpc.net/problem/11399 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { int size; int arr[]; int answer = 0; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); size = Integer.parseInt(st.nextToken()); arr = new int[size]; st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; size; i++) { arr[i] = Integer.parseInt(st.nextToken()); } // sort Arrays.sort(arr); // sum for (int i = 0; i &lt; size; i++) { answer += arr[i] * (size - i); } System.out.println(answer); } } . ",
    "url": "/docs/codingtest/1day1coding/230915/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#결과-코드"
  },"159": {
    "doc": "상근이의 여행",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/#atm",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#atm"
  },"160": {
    "doc": "상근이의 여행",
    "title": "2023.09.17 (SUN)",
    "content": ". 문제 : 백준 - 9372. 상근이의 여행 . ",
    "url": "/docs/codingtest/1day1coding/230917/#20230917-sun",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#20230917-sun"
  },"161": {
    "doc": "상근이의 여행",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#조건-및-설명"
  },"162": {
    "doc": "상근이의 여행",
    "title": "접근법",
    "content": "1. 인접리스트로 그래프를 구현하고 2. 신장 트리로 최소 비용을 구한다. | 사실 이 문제는, 입력된 그래프가 항상 연결 그래프이므로 국가 - 1가 정답이다. | . ",
    "url": "/docs/codingtest/1day1coding/230917/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#접근법"
  },"163": {
    "doc": "상근이의 여행",
    "title": "결과 코드",
    "content": "/* * Title : 상근이의 여행 * Link : https://www.acmicpc.net/problem/9372 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; // input int tc = Integer.parseInt(br.readLine()); // each TestCase for (int t = 0; t &lt; tc; t++) { st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // number of countries int M = Integer.parseInt(st.nextToken()); // number of planes for (int i = 0; i &lt; M; i++) { br.readLine(); // we don't need to process the plane information for this problem. } System.out.println(N-1); // the minimum number of planes Sanggeun needs to take is always N-1. } } } . ",
    "url": "/docs/codingtest/1day1coding/230917/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#결과-코드"
  },"164": {
    "doc": "상근이의 여행",
    "title": "상근이의 여행",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/"
  },"165": {
    "doc": "TIL (23-09-17)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230917/#til",
    
    "relUrl": "/docs/tils/230917/#til"
  },"166": {
    "doc": "TIL (23-09-17)",
    "title": "2023.09.17 (SUN)",
    "content": ". 그래프 - 인접 리스트 . /* * Title : 상근이의 여행 * Link : https://www.acmicpc.net/problem/9372 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int result[]; // input int tc = Integer.parseInt(br.readLine()); result = new int[tc]; // each TestCase for (int t = 0; t &lt; tc; t++) { int answer = Integer.MAX_VALUE; st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); // input &amp; 인접 리스트 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= N; i++) graph.add(new ArrayList&lt;&gt;()); // 각 노드 별 리스트를 만든다. for (int i = 0; i &lt; M; i++) { // make graph st = new StringTokenizer(br.readLine()); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); putEdge(graph, x, y); } for (int i = 0; i &lt; N ; i++) { int check = checkEdge(graph, i); if (check &lt; answer) { answer = check; } } result[t] = answer; } for (int r:result) System.out.println(r); } public static void putEdge(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, int x, int y) { graph.get(x).add(y); graph.get(y).add(x); } public static int checkEdge(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, int x) { } } . 그래프를 표현할 때, 가장 효율적인 방법인 듯 . 신장 트리 / 최소 신장 트리 (MST) . 신장 트리란 : 그래프의 모든 정점을 사이클 없이 잇는 트리 . 최소 신장 트리 : 신장 트리에서 간선의 가중치의 합이 최소가 되는 트리 . MST는 내일 다루도록 해보고, 오늘은 신장트리를 구현하였다. | 신장트리 알고리즘 문제 . | 입력된 그래프가 항상 연결 그래프이면 정점 - 1가 정답이다. | . ",
    "url": "/docs/tils/230917/#20230917-sun",
    
    "relUrl": "/docs/tils/230917/#20230917-sun"
  },"167": {
    "doc": "TIL (23-09-17)",
    "title": "TIL (23-09-17)",
    "content": " ",
    "url": "/docs/tils/230917/",
    
    "relUrl": "/docs/tils/230917/"
  },"168": {
    "doc": "TIL (23-09-18)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230918/#til",
    
    "relUrl": "/docs/tils/230918/#til"
  },"169": {
    "doc": "TIL (23-09-18)",
    "title": "2023.09.18 (MON)",
    "content": ". Message Broker . 애플리케이션, 시스템 및 서비스가 서로 간에 통신하고 정보를 교환할 수 있도록 해주는 SW . | 상호 의존적인 서비스들이 서로 다른 언어나 플랫폼으로 개발된 경우에도 통신이 가능해진다. | 메시지를 검증, 저장, 라우팅하고 이를 적절한 대상에 전달할 수 있음 | 메시지 큐를 이용함 | . ",
    "url": "/docs/tils/230918/#20230918-mon",
    
    "relUrl": "/docs/tils/230918/#20230918-mon"
  },"170": {
    "doc": "TIL (23-09-18)",
    "title": "TIL (23-09-18)",
    "content": " ",
    "url": "/docs/tils/230918/",
    
    "relUrl": "/docs/tils/230918/"
  },"171": {
    "doc": "웹 소켓 프로그래밍",
    "title": "웹 소켓 프로그래밍",
    "content": " ",
    "url": "/docs/projects/gameServer/230920/",
    
    "relUrl": "/docs/projects/gameServer/230920/"
  },"172": {
    "doc": "웹 소켓 프로그래밍",
    "title": "2023.09.20 (WED)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230920/#20230920-wed",
    
    "relUrl": "/docs/projects/gameServer/230920/#20230920-wed"
  },"173": {
    "doc": "웹 소켓 프로그래밍",
    "title": "웹 소켓 프로그래밍",
    "content": "P . ",
    "url": "/docs/projects/gameServer/230920/",
    
    "relUrl": "/docs/projects/gameServer/230920/"
  },"174": {
    "doc": "TIL (23-09-21)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230921/#til",
    
    "relUrl": "/docs/tils/230921/#til"
  },"175": {
    "doc": "TIL (23-09-21)",
    "title": "2023.09.21 (THU)",
    "content": ". EC2 접속 시, 타임아웃 . 거의 99확률로, 보안그룹 때문이다. 인바운드 및 아웃바운드 규칙을 확인하자. EC2 콘솔에서 IAM 유저를 확인할 때, . $ aws iam list-users Unable to locate credentials. You can configure credentials by running \"aws configure\". 유저를 확인하려면, ‘aws configure’을 실행시키라고 나온다. 그래서 실행 시켜보면, . $ aws configure AWS Access Key ID [None]: AWS Secret Access Key [None]: Default region name [None]: Default output format [None]: . 라고 나오면서, 비밀 Access 키를 입력하라고 나온다… . ",
    "url": "/docs/tils/230921/#20230921-thu",
    
    "relUrl": "/docs/tils/230921/#20230921-thu"
  },"176": {
    "doc": "TIL (23-09-21)",
    "title": "절대 IAM API 키를 직접 입력하지 않는다.",
    "content": ". | 자격 증명 정보를 누군가 EC2에 접속하여 회수할 수 있다. | . ",
    "url": "/docs/tils/230921/#%EC%A0%88%EB%8C%80-iam-api-%ED%82%A4%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%9E%85%EB%A0%A5%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4",
    
    "relUrl": "/docs/tils/230921/#절대-iam-api-키를-직접-입력하지-않는다"
  },"177": {
    "doc": "TIL (23-09-21)",
    "title": "TIL (23-09-21)",
    "content": " ",
    "url": "/docs/tils/230921/",
    
    "relUrl": "/docs/tils/230921/"
  },"178": {
    "doc": "보디빌딩",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/#atm",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#atm"
  },"179": {
    "doc": "보디빌딩",
    "title": "2023.09.22 (FRI)",
    "content": ". 문제 : 백준 - 27952. 보디빌딩 . ",
    "url": "/docs/codingtest/1day1coding/230922/#20230922-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#20230922-fri"
  },"180": {
    "doc": "보디빌딩",
    "title": "조건 및 설명",
    "content": ". | 루틴을 진행할 떄마다, 몸무게가 Xkg 만큼 빠진다. | 이 루틴을 하루에 여러번 가능 | . | 보디빌딩이 남은 N일 동안, 식단으로 i번째 날에 Bikg만큼 찐다. | 최소 몸무게가 Aikg 이상이어야 한다. | . ",
    "url": "/docs/codingtest/1day1coding/230922/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#조건-및-설명"
  },"181": {
    "doc": "보디빌딩",
    "title": "접근법",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#접근법"
  },"182": {
    "doc": "보디빌딩",
    "title": "결과 코드",
    "content": "/* * Title : 보디빌딩 * Link : https://www.acmicpc.net/problem/27952 */ import java.io.*; import java.util.*; public class Main { private static int N; // 보디빌딩 대회까지 남은 일수 private static int X; // 루틴을 진행할 떄마다 빠지는 몸무게 private static int[] A; // i번째 날 최종 몸무게의 하한 private static int[] B; // i번째 날에 늘어나는 몸무게 public static void main(String[] args) throws Exception { int answer = 0; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int current_weight = 0; // input st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); X = Integer.parseInt(st.nextToken()); A = new int[N]; B = new int[N]; st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; N; i ++) A[i] = Integer.parseInt(st.nextToken()); st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; N; i ++) B[i] = Integer.parseInt(st.nextToken()); // calculation for (int i = 0; i &lt; N; i++) { current_weight += B[i]; int routine = (current_weight - A[i]) / X; // if, he falls down if (current_weight &lt; A[i]) { answer = -1; break; } // if, he can do routine if (routine &gt; 0) { current_weight -= X * routine; answer += routine; } } System.out.println(answer); } } . ",
    "url": "/docs/codingtest/1day1coding/230922/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#결과-코드"
  },"183": {
    "doc": "보디빌딩",
    "title": "보디빌딩",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/"
  },"184": {
    "doc": "TIL (23-09-26)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230926/#til",
    
    "relUrl": "/docs/tils/230926/#til"
  },"185": {
    "doc": "TIL (23-09-26)",
    "title": "2023.09.26 (TUE)",
    "content": ". 자바스크립트의 using . 기존 const와 같은 JS 키워드는 수동으로 변수를 해제/종료시켜줘야 했다. 하지만 using을 사용하면 DB 변수와 같이, 반드시 종료를 시켜줘야 하는 변수들을 종료시켜줄 수 있다. 발동 조건은 using 변수가 범위를 벗어나 더 이상 사용되지 않으면 폐기된다. ",
    "url": "/docs/tils/230926/#20230926-tue",
    
    "relUrl": "/docs/tils/230926/#20230926-tue"
  },"186": {
    "doc": "TIL (23-09-26)",
    "title": "TIL (23-09-26)",
    "content": " ",
    "url": "/docs/tils/230926/",
    
    "relUrl": "/docs/tils/230926/"
  },"187": {
    "doc": "제작 일지 <9>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;9&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231003/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-9",
    
    "relUrl": "/docs/projects/pongdang/231003/#퐁당-웹-매거진-프로젝트-제작-일지-9"
  },"188": {
    "doc": "제작 일지 <9>",
    "title": "2023.10.03 (TUE)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231003/#20231003-tue",
    
    "relUrl": "/docs/projects/pongdang/231003/#20231003-tue"
  },"189": {
    "doc": "제작 일지 <9>",
    "title": "1. 오프라인 회의",
    "content": "오프라인 회의 진행하면서, 개발 진행 . ",
    "url": "/docs/projects/pongdang/231003/#1-%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%ED%9A%8C%EC%9D%98",
    
    "relUrl": "/docs/projects/pongdang/231003/#1-오프라인-회의"
  },"190": {
    "doc": "제작 일지 <9>",
    "title": "2. 11월 14일 전까지 해야 할 업무",
    "content": ". | 검색 DB | 검색 알고리즘 | 인터뷰 페이지 | 수시로 피드백 받은거 바로바로 수정 | . ",
    "url": "/docs/projects/pongdang/231003/#2-11%EC%9B%94-14%EC%9D%BC-%EC%A0%84%EA%B9%8C%EC%A7%80-%ED%95%B4%EC%95%BC-%ED%95%A0-%EC%97%85%EB%AC%B4",
    
    "relUrl": "/docs/projects/pongdang/231003/#2-11월-14일-전까지-해야-할-업무"
  },"191": {
    "doc": "제작 일지 <9>",
    "title": "제작 일지 <9>",
    "content": " ",
    "url": "/docs/projects/pongdang/231003/",
    
    "relUrl": "/docs/projects/pongdang/231003/"
  },"192": {
    "doc": "제작 일지 <_10>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;10&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-10",
    
    "relUrl": "/docs/projects/pongdang/231009/#퐁당-웹-매거진-프로젝트-제작-일지-10"
  },"193": {
    "doc": "제작 일지 <_10>",
    "title": "2023.10.09 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231009/#20231009-mon",
    
    "relUrl": "/docs/projects/pongdang/231009/#20231009-mon"
  },"194": {
    "doc": "제작 일지 <_10>",
    "title": "1. 검색용 DB 생성",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/#1-%EA%B2%80%EC%83%89%EC%9A%A9-db-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/231009/#1-검색용-db-생성"
  },"195": {
    "doc": "제작 일지 <_10>",
    "title": "제작 일지 <_10>",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/",
    
    "relUrl": "/docs/projects/pongdang/231009/"
  },"196": {
    "doc": "TIL (23-10-10)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231010/#til",
    
    "relUrl": "/docs/tils/231010/#til"
  },"197": {
    "doc": "TIL (23-10-10)",
    "title": "2023.10.10 (TUE)",
    "content": ". ",
    "url": "/docs/tils/231010/#20231010-tue",
    
    "relUrl": "/docs/tils/231010/#20231010-tue"
  },"198": {
    "doc": "TIL (23-10-10)",
    "title": "Entity, Repository",
    "content": "Entity . 데이터베이스에 쓰일 필드와 여러 엔티티간 연관관계를 정의한다. Repository . Entity에 의해 생성된 DB에 접근하는 메서드들을 사용하기 위한 인터페이스이다. ",
    "url": "/docs/tils/231010/#entity-repository",
    
    "relUrl": "/docs/tils/231010/#entity-repository"
  },"199": {
    "doc": "TIL (23-10-10)",
    "title": "TIL (23-10-10)",
    "content": " ",
    "url": "/docs/tils/231010/",
    
    "relUrl": "/docs/tils/231010/"
  },"200": {
    "doc": "기지국 설치",
    "title": "기지국 설치",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/231016/",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/"
  },"201": {
    "doc": "기지국 설치",
    "title": "2023.10.16 (FRI)",
    "content": ". 문제 : 프로그래머스 LV.3 - 기지국 설치 . ",
    "url": "/docs/codingtest/1day1coding/231016/#20231016-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#20231016-fri"
  },"202": {
    "doc": "기지국 설치",
    "title": "조건 및 설명",
    "content": ". | N개의 아파트가 일렬로 서있음 | 일부 아파트는 원래 4g 기지국이 설치되어 있었음 | w는 전파의 도달거리 (양 옆) | 설치해야하는 기지국 개수의 최솟값을 구하라. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#조건-및-설명"
  },"203": {
    "doc": "기지국 설치",
    "title": "접근법 1",
    "content": ". | 아파트의 갯수만큼 visited[] 배열을 만든다. | 이미 기지국의 전파 범위안에 있는 아파트를 true로 바꾼다. | 일렬로 세워져있기 때문에, 앞부터 2w+1개씩 세어준다. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A0%91%EA%B7%BC%EB%B2%95-1",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#접근법-1"
  },"204": {
    "doc": "기지국 설치",
    "title": "임시 결과 코드 1번",
    "content": "/* * Title : 기지국 설치 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12979?language=java */ import java.util.*; class Solution { public int solution(int n, int[] stations, int w) { int answer = 0; // 1 . boolean[] visited = new boolean[n]; for (boolean v : visited) { v = false; } // 2. for (int st : stations) { int low = st-1-w; int high = st-1+w &gt; n-1 ? n-1 : st-1+w; for (int i = low; i &lt;= high; i++) visited[i] = true; } // 3. int counter = 0; int range = 2*w+1; for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; counter &lt; range) { counter++; } if (counter == range) { for (int j = i; j &gt; i-range; j--) visited[j] = true; counter = 0; answer++; } else if ((visited[i] &amp;&amp; counter != 0) || (i == n-1 &amp;&amp; counter !=0)) { for (int j = i-1; j &gt; i-counter-1; j--) visited[j] = true; counter = 0; answer++; } } return answer; } } . 채점 결과 정확성: 53.7 효율성: 0.0 합계: 53.7 / 100.0 . 방법은 맞지만, 정확성 채점에서도 런타임 에러가 발생하였다. 더 효율적이여야 한다. 해당 방법 말고, 새로운 접근법으로 가보자. ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%9E%84%EC%8B%9C-%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C-1%EB%B2%88",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#임시-결과-코드-1번"
  },"205": {
    "doc": "기지국 설치",
    "title": "접근법 2.",
    "content": ". | 기지국 전파가 닿지 않는 구간의 개수를 센다. | 그 개수를 range를 이용하여 최소 기지국 설치 개수를 센다. | stations이 한개 이상 있기 때문에, 처음-중간-끝을 나눠서 계산한다. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A0%91%EA%B7%BC%EB%B2%95-2",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#접근법-2"
  },"206": {
    "doc": "기지국 설치",
    "title": "임시 결과 코드 2번",
    "content": "/* * Title : 기지국 설치 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12979?language=java */ import java.util.*; class Solution { public int solution(int n, int[] stations, int w) { int answer = 0; int range = 2*w+1; int empty_num; // 처음 empty_num = stations[0] - w - 1; // ex) 9 - 2 - 1 = 6 if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } // 중간 for (int i = 1; i &lt; stations.length; i++) { empty_num = (stations[i] - w) - (stations[i-1] + w) - 1; // ex) 10 - 5 -1 if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } } // 끝 empty_num = n - (stations[stations.length - 1] + w); if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } return answer; } } . 채점 결과 정확성: 70.5 효율성: 29.5 합계: 100.0 / 100.0 . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%9E%84%EC%8B%9C-%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C-2%EB%B2%88",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#임시-결과-코드-2번"
  },"207": {
    "doc": "TIL (23-10-16)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231016/#til",
    
    "relUrl": "/docs/tils/231016/#til"
  },"208": {
    "doc": "TIL (23-10-16)",
    "title": "2023.10.16 (MON)",
    "content": ". ",
    "url": "/docs/tils/231016/#20231016-mon",
    
    "relUrl": "/docs/tils/231016/#20231016-mon"
  },"209": {
    "doc": "TIL (23-10-16)",
    "title": "코테 연습 팁",
    "content": ". | 노가다는 제일 최후의 수단이다. | 수식을 세울 수 있을 것 같으면, 한번 도전해라!! | . ",
    "url": "/docs/tils/231016/#%EC%BD%94%ED%85%8C-%EC%97%B0%EC%8A%B5-%ED%8C%81",
    
    "relUrl": "/docs/tils/231016/#코테-연습-팁"
  },"210": {
    "doc": "TIL (23-10-16)",
    "title": "TIL (23-10-16)",
    "content": " ",
    "url": "/docs/tils/231016/",
    
    "relUrl": "/docs/tils/231016/"
  },"211": {
    "doc": "제작 일지 <_11>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;11&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231018/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-11",
    
    "relUrl": "/docs/projects/pongdang/231018/#퐁당-웹-매거진-프로젝트-제작-일지-11"
  },"212": {
    "doc": "제작 일지 <_11>",
    "title": "2023.10.18 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231018/#20231018-wed",
    
    "relUrl": "/docs/projects/pongdang/231018/#20231018-wed"
  },"213": {
    "doc": "제작 일지 <_11>",
    "title": "1. 검색용 DB 생성 후, 불러오기 테스트",
    "content": "리액트와 스프링부트 연동을 하는데, 중점을 두었다. 예제로, 테이블의 json을 받아와 출력하도록 하였다. Result.js . import React, { useEffect, useState } from 'react'; import \"./Result.css\"; export default function SearchBar() { const [interviews, setInterviews] = useState([]); useEffect(() =&gt; { fetch('/v1/interview') // Endpoint .then(response =&gt; response.json()) .then(data =&gt; setInterviews(data)) .catch(error =&gt; console.error(error)); }, []) return ( &lt;div className=\"Result_Search\"&gt; {/* interviews 배열에 맞게 데이터 렌더링 */} {interviews.map(interview =&gt; ( &lt;div key={interview.id}&gt; &lt;h3&gt;{interview.interview_title}&lt;/h3&gt; &lt;p&gt;{interview.interviewee}&lt;/p&gt; &lt;/div&gt; ))} &lt;/div&gt; ) } . InterviewController.java . @RestController // Json 형태 결과값 반환 @RequiredArgsConstructor // final 객체를 Constructor Injection (Autowired 역할) @RequestMapping(\"/v1\") // version1의 api public class InterviewController { private final InterviewRepository interviewRepository; /** * 조회 * * @return */ @GetMapping(\"interview\") public List&lt;InterviewEntity&gt; findAllInterview() { return interviewRepository.findAll(); } } . 결과 화면 . ",
    "url": "/docs/projects/pongdang/231018/#1-%EA%B2%80%EC%83%89%EC%9A%A9-db-%EC%83%9D%EC%84%B1-%ED%9B%84-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/projects/pongdang/231018/#1-검색용-db-생성-후-불러오기-테스트"
  },"214": {
    "doc": "제작 일지 <_11>",
    "title": "제작 일지 <_11>",
    "content": " ",
    "url": "/docs/projects/pongdang/231018/",
    
    "relUrl": "/docs/projects/pongdang/231018/"
  },"215": {
    "doc": "TIL (23-10-20)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231020/#til",
    
    "relUrl": "/docs/tils/231020/#til"
  },"216": {
    "doc": "TIL (23-10-20)",
    "title": "2023.10.20 (FRI)",
    "content": ". ",
    "url": "/docs/tils/231020/#20231020-fri",
    
    "relUrl": "/docs/tils/231020/#20231020-fri"
  },"217": {
    "doc": "TIL (23-10-20)",
    "title": "JPA와 MySQL에서의 컬럼명",
    "content": "분명 동일하게 네이밍을 했음에도 불구하고, 자꾸 컬럼명을 못찾는다고 나온다. 원인을 찾아보았다. Java는 카멜케이스(camelCase), SQL은 스테이크 케이스(snake_case)를 주로 사용한다. 그래서 MySQL에서 컬럼명을 대문자로 표기했을 때, 오류가 있었을 수도,,,? . 그래서 아래처럼 변경하였다. Spring -&gt; interviewTitle MySQL -&gt; interview_title . 정상 동작 한다!!! . ",
    "url": "/docs/tils/231020/#jpa%EC%99%80-mysql%EC%97%90%EC%84%9C%EC%9D%98-%EC%BB%AC%EB%9F%BC%EB%AA%85",
    
    "relUrl": "/docs/tils/231020/#jpa와-mysql에서의-컬럼명"
  },"218": {
    "doc": "TIL (23-10-20)",
    "title": "TIL (23-10-20)",
    "content": " ",
    "url": "/docs/tils/231020/",
    
    "relUrl": "/docs/tils/231020/"
  },"219": {
    "doc": "제작 일지 <_12>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;12&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231020/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-12",
    
    "relUrl": "/docs/projects/pongdang/231020/#퐁당-웹-매거진-프로젝트-제작-일지-12"
  },"220": {
    "doc": "제작 일지 <_12>",
    "title": "2023.10.20 (FRI)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231020/#20231020-fri",
    
    "relUrl": "/docs/projects/pongdang/231020/#20231020-fri"
  },"221": {
    "doc": "제작 일지 <_12>",
    "title": "1. 검색 알고리즘 생성",
    "content": "일단, title에서 검색어에 단어가 포함되면 리스트를 출력하도록 먼저 세팅해놓았다. ",
    "url": "/docs/projects/pongdang/231020/#1-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/231020/#1-검색-알고리즘-생성"
  },"222": {
    "doc": "제작 일지 <_12>",
    "title": "제작 일지 <_12>",
    "content": " ",
    "url": "/docs/projects/pongdang/231020/",
    
    "relUrl": "/docs/projects/pongdang/231020/"
  },"223": {
    "doc": "영어 끝말잇기",
    "title": "영어 끝말잇기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/231116/",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/"
  },"224": {
    "doc": "영어 끝말잇기",
    "title": "2023.11.16 (THU)",
    "content": ". 문제 : 프로그래머스 LV.3 - 영어 끝말잇기 . ",
    "url": "/docs/codingtest/1day1coding/231116/#20231116-thu",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#20231116-thu"
  },"225": {
    "doc": "영어 끝말잇기",
    "title": "조건 및 설명",
    "content": ". | 똑같은 걸 말하거나, 끝말잇기가 되지 않으면 탈락 | . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#조건-및-설명"
  },"226": {
    "doc": "영어 끝말잇기",
    "title": "접근법",
    "content": ". | 출력은 현재 인덱스에서 나머지 연산 등으로 구한다. | 단어수가 크지 않다. | 매번 인덱스마다 체크해보자. | . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#접근법"
  },"227": {
    "doc": "영어 끝말잇기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int[] solution(int n, String[] words) { int[] answer = {0, 0}; ArrayList&lt;String&gt; usedWords = new ArrayList&lt;&gt;(); // 사용한 단어 usedWords.add(words[0]); // 첫 단어 추가 for (int i = 1; i &lt; words.length; i++) { // 1. 끝 알파벳과 첫 알파벳이 같지 않을 경우 // 2. 똑같은 단어를 말했을 경우 if (words[i].charAt(0) != words[i-1].charAt(words[i-1].length()-1) || usedWords.contains(words[i])) { answer[0] = i % n + 1; answer[1] = i / n + 1; break; } usedWords.add(words[i]); } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#결과-코드"
  },"228": {
    "doc": "TIL (23-11-22)",
    "title": "TIL - (스프링+리액트) 특정 주소만 작동하지 않는 상황",
    "content": " ",
    "url": "/docs/tils/231122/#til---%EC%8A%A4%ED%94%84%EB%A7%81%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8A%B9%EC%A0%95-%EC%A3%BC%EC%86%8C%EB%A7%8C-%EC%9E%91%EB%8F%99%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/tils/231122/#til---스프링리액트-특정-주소만-작동하지-않는-상황"
  },"229": {
    "doc": "TIL (23-11-22)",
    "title": "2023.11.22 (WED)",
    "content": ". '/', '/test'는 정상작동 하지만, '/test/test'는 정상작동하지 않는 오류가 생겼다. | 기존 controller @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } } . | . 리다이렉트의 추가 수정이 필요하다. @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } @RequestMapping({\"/**/{path:^(?!.*\\\\.).*}\"}) public String deepRedirect() { return \"forward:/\"; } } . 근데 이후, 아래와 같은 오류가 발생하였다. Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2023-11-22 09:16:38.850 ERROR 30399 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter : APPLICATION FAILED TO START Description: Invalid mapping pattern detected: /**/{path:^(?!..).} ^ No more pattern data allowed after {*...} or ** pattern element Action: Fix this pattern in your application or switch to the legacy parser implementation with 'spring.mvc.pathmatch.matching-strategy=ant_path_matcher'. 해당 오류는 스프링부트에서 제공하는 기본 경로 패턴 매칭 알고리즘은 복잡한 정규 표현식을 지원하지 않기 때문에 발생하는 오류이다. 이를 해결하기 위해서는 스프링 부트의 설정을 변경하여, 이전 버전의 경로 매칭 알고리즘(AntPathMatcher)을 사용하면 된다. spring.mvc.pathmatch.matching-strategy=ant_path_matcher . ",
    "url": "/docs/tils/231122/#20231122-wed",
    
    "relUrl": "/docs/tils/231122/#20231122-wed"
  },"230": {
    "doc": "TIL (23-11-22)",
    "title": "TIL (23-11-22)",
    "content": " ",
    "url": "/docs/tils/231122/",
    
    "relUrl": "/docs/tils/231122/"
  },"231": {
    "doc": "TIL (23-11-25)",
    "title": "TIL - Jekyll(just-the-docs) 한국 검색 기능 추가",
    "content": " ",
    "url": "/docs/tils/231125/#til---jekylljust-the-docs-%ED%95%9C%EA%B5%AD-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80",
    
    "relUrl": "/docs/tils/231125/#til---jekylljust-the-docs-한국-검색-기능-추가"
  },"232": {
    "doc": "TIL (23-11-25)",
    "title": "2023.11.25 (SAT)",
    "content": ". 기존 Just the Docs에서는 lunr.js를 이용한 검색 기능을 제공한다. 하지만, 한국어는 정식으로 지원하지 않는 lunr다.. 그래서 해결책은 lunr-languages에서 제공한 js를 이용하는 것이다. | lunr.ko.js, lunr.multi.js, lunr.stemmer.support.js를 다운 받아, assets/js/vendor 디렉토리(lunr.min.js가 존재하는 디렉토리)에 넣어준다. | lunr.min.js가 임포트 된 head.html에 다음과 같은 순서로 임포트한다. 가장 오랜 시간을 잡아먹은,,, 순서를 지키지 않았더니, 한글 검색은 물론이고 영어 검색도 먹통이 되었다. | just-the-docs.js 파일에 아래 코드를 추가시켜준다. var index = lunr(function(){ this.use(lunr.multiLanguage('en', 'ko')); // ... | . | 아래와 같이 한글 검색 기능도 된다! | . ",
    "url": "/docs/tils/231125/#20231125-sat",
    
    "relUrl": "/docs/tils/231125/#20231125-sat"
  },"233": {
    "doc": "TIL (23-11-25)",
    "title": "TIL (23-11-25)",
    "content": " ",
    "url": "/docs/tils/231125/",
    
    "relUrl": "/docs/tils/231125/"
  },"234": {
    "doc": "제작 일지 <_13>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;13&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231204/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-13",
    
    "relUrl": "/docs/projects/pongdang/231204/#퐁당-웹-매거진-프로젝트-제작-일지-13"
  },"235": {
    "doc": "제작 일지 <_13>",
    "title": "2023.12.04 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231204/#20231204-mon",
    
    "relUrl": "/docs/projects/pongdang/231204/#20231204-mon"
  },"236": {
    "doc": "제작 일지 <_13>",
    "title": "1. 검색 페이지 완성 및 라우팅",
    "content": ". MySQL 데이터베이스와 연결하여, 검색 기능을 구현하였다. 그 중에서도 조금 오래걸렸던 부분은, 이 부분인데, 앞에 그라데이션 효과를 주면서 뒤에 요소를 클릭하게 만들고 싶었다.gradation_container &gt; img { width: 100%; position: absolute; bottom: 0; left: 0; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -o-user-select: none; user-select: none; -webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -o-user-drag: none; user-drag: none; pointer-events: none; /* 이미지 위에서의 이벤트 처리 막기 */ } . pointer-events를 none으로 설정하면, 이미지 위에서의 이벤트 처리를 차단할 수 있다. ",
    "url": "/docs/projects/pongdang/231204/#1-%EA%B2%80%EC%83%89-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%99%84%EC%84%B1-%EB%B0%8F-%EB%9D%BC%EC%9A%B0%ED%8C%85",
    
    "relUrl": "/docs/projects/pongdang/231204/#1-검색-페이지-완성-및-라우팅"
  },"237": {
    "doc": "제작 일지 <_13>",
    "title": "제작 일지 <_13>",
    "content": " ",
    "url": "/docs/projects/pongdang/231204/",
    
    "relUrl": "/docs/projects/pongdang/231204/"
  },"238": {
    "doc": "TIL (23-12-04)",
    "title": "TIL - CSS 버튼이나 링크 위에 이미지를 올릴 때, 이미지의 클릭 비활성화",
    "content": " ",
    "url": "/docs/tils/231204/#til---css-%EB%B2%84%ED%8A%BC%EC%9D%B4%EB%82%98-%EB%A7%81%ED%81%AC-%EC%9C%84%EC%97%90-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A5%BC-%EC%98%AC%EB%A6%B4-%EB%95%8C-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%9D%98-%ED%81%B4%EB%A6%AD-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/tils/231204/#til---css-버튼이나-링크-위에-이미지를-올릴-때-이미지의-클릭-비활성화"
  },"239": {
    "doc": "TIL (23-12-04)",
    "title": "2023.12.04 (MON)",
    "content": ". 앞에 그라데이션 효과를 주면서 뒤에 요소를 클릭하게 만들고 싶었다.gradation_container &gt; img { width: 100%; position: absolute; bottom: 0; left: 0; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -o-user-select: none; user-select: none; -webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -o-user-drag: none; user-drag: none; pointer-events: none; /* 이미지 위에서의 이벤트 처리 막기 */ } . pointer-events를 none으로 설정하면, 이미지 위에서의 이벤트 처리를 차단할 수 있다. ",
    "url": "/docs/tils/231204/#20231204-mon",
    
    "relUrl": "/docs/tils/231204/#20231204-mon"
  },"240": {
    "doc": "TIL (23-12-04)",
    "title": "TIL (23-12-04)",
    "content": " ",
    "url": "/docs/tils/231204/",
    
    "relUrl": "/docs/tils/231204/"
  },"241": {
    "doc": "TIL (23-12-12)",
    "title": "TIL - CS 지식 복기",
    "content": " ",
    "url": "/docs/tils/231211/#til---cs-%EC%A7%80%EC%8B%9D-%EB%B3%B5%EA%B8%B0",
    
    "relUrl": "/docs/tils/231211/#til---cs-지식-복기"
  },"242": {
    "doc": "TIL (23-12-12)",
    "title": "2023.12.12 (TUE)",
    "content": ". ",
    "url": "/docs/tils/231211/#20231212-tue",
    
    "relUrl": "/docs/tils/231211/#20231212-tue"
  },"243": {
    "doc": "TIL (23-12-12)",
    "title": "1️⃣ TCP, UDP",
    "content": "TCP와 UDP는 모두 데이터를 보내기 위해 사용하는 프로토콜이다. | TCP (Transmission Control Protocol) . 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. | 일반적으로 TCP와 IP를 함께 사용하여, TCP/IP라고도 불린다. | IP가 데이터의 배달을 처리한다면, TCP는 패킷을 추적 및 관리한다. | IP는 Internet Protocol의 약자로, 인터넷에서 데이터 주소를 지정하고 라우팅하기 위한 요구 사항의 집합이다. | . | TCP의 특징 . | 연결 지향 방식으로 패킷 교환 방식을 사용한다. | 3-way handshaking을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다. (그래서 연결 지향 방식이다.) | 높은 신뢰성 (연결형 서비스이기 때문에) | UDP보다 속도가 느리다. | 연속성 보다 신뢰성 있는 전송이 중요할 때! | . | TCP 서버의 특징 . | 서버 소켓은 연결만을 담당한다. | 연결 과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다. | 이게 무슨 말이야? -&gt; 왜 반환? -&gt; 요청자가 close() 함수를 사용하면 호출 즉시 OS에게 소켓의 리소스를 반환하며 모든 스트림이 파기된다. | 반환하면 재전송을 요청한다. -&gt; 그러면 전체적인 속도가 느려지겠지? | . | . | 서버와 클라이언트는 1대1로 연결된다. | 스트림 전송으로 전송 데이터의 크기가 무제한이다. | 왜? -&gt; TCP는 데이터를 세그먼트로 분할하여 패킷을 전송하는데, 이때 세그먼트의 크기에는 제한이 있지만, 스트림으로 전송되는 데이터의 크기에는 제한이 없다. 이는 TCP가 대량의 데이터를 효율적으로 전송하기 위해 사용되는 프로토콜이기 때문이다. -&gt; 즉, TCP가 데이터를 조각내어 전송하는 방식 때문에 데이터의 크기에 대한 제한이 없다는 의미다. | . | 패킷에 대한 응답을 해야하기 때문에, 성능이 낮다. | 패킷이란, 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송하는데, 그 조각을 패킷이라고 한다. | . | . | . | . | TCP는 패킷을 어떻게 추적하고 관리하나? 데이터는 패킷 단위로 나누어 같은 목적지(IP계층)으로 전송된다. A, B, C가 같은 목적지로 간다고 할 때, B가 분실되었다고 해보자. 하지만 목적지 입장에서는 A, B, C가 전부 필요한지 모른다. 그래서 1, 2, 3과 같은 마킹을 하여, 패킷의 분실 확인과 같은 처리를 하여 목적지에서 재조립을 한다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립한다. | . | UDP (User Datagram Protocol) . 데이터를 ‘데이터그램’ 단위로 처리하는 프로토콜이다. -&gt; 데이터 그램이란, 독립적인 관계를 지니는 패킷 (자세한 설명은 아래에) . UDP는 TCP와 달리 비연결형 프로토콜이다. 즉, 연결을 위한 논리적인 경로가 없다. 그래서 각각의 패킷은 다른 경로로 전송되며, 자동적으로 패킷은 독립적인 관계를 지니게 된다. | UDP 특징 . | 비연결형 서비스로 데이터그램을 방식을 제공한다. | 정보를 주고 받을 때, 정보를 보내거나 받는다는 신호절차를 거치지 않는다. | 그래서 TCP보다 속도가 빠르다 | . | UDP의 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다. | 대신, 신뢰성이 낮다. | . | . UDP는 비연결형 서비스이기 때문에, TCP처럼 연결을 설정하고 해제하는 과정이 존재하지 않는다. 하지만, 그런 특징 때문에 신뢰성 있는 데이터의 전송을 보장하지 못한다. | UDP 서버의 특징 . | UDP에는 연결 자체가 없다. -&gt; connect() 함수 불필요 -&gt; 서버 소켓과 클라이언트 소켓의 구분이 없다. | 소켓 대신 IP를 기반으로 데이터를 전송한다. | 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다. | 데이터그램(메시지) 단위로 전송되며 크기는 65535 바이트이다. (크기가 초과되면 잘라서 보낸다.) | 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인 불가 | 신뢰성보단 성능이 중요시 되는 경우 사용 | . | . 흐름제어(flow control)는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것이다. | . ",
    "url": "/docs/tils/231211/#1%EF%B8%8F%E2%83%A3-tcp-udp",
    
    "relUrl": "/docs/tils/231211/#1️⃣-tcp-udp"
  },"244": {
    "doc": "TIL (23-12-12)",
    "title": "2️⃣ 객체와 클래스 차이",
    "content": "객체 : 자신 고유의 속성을 가지는 물리적, 추상적인 모든 대상을 일컫는다. 클래스 : 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도이다. ",
    "url": "/docs/tils/231211/#2%EF%B8%8F%E2%83%A3-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4",
    
    "relUrl": "/docs/tils/231211/#2️⃣-객체와-클래스-차이"
  },"245": {
    "doc": "TIL (23-12-12)",
    "title": "3️⃣ 사용자가 도메인을 입력했을때, 웹페이지가 불러와지는 과정",
    "content": "1. 사용자가 웹 브라우저에 도메인 주소(예: www.example.com)를 입력한다. 2. 브라우저는 입력된 도메인 주소를 DNS 서버로 보낸다. (DNS 서버는 도메인 주소를 해당 도메인의 IP주소로 변환해주는 역할을 한다.) 3. DNS 서버는 도메인 주소에 대응하는 IP 주소를 찾아 브라우저에게 응답한다. 4. 브라우저는 IP 주소를 통해 웹서버에 접속을 시도한다. 5. 웹 서버는 해당 도메인에 대한 요청을 받고, 요청된 웹페이즈를 찾아서 브라우저에게 전송한다. 6. 브라우저는 받은 웹페이지를 해석하여 화면에 표시한다. ",
    "url": "/docs/tils/231211/#3%EF%B8%8F%E2%83%A3-%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B0%80-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84%EB%95%8C-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%B6%88%EB%9F%AC%EC%99%80%EC%A7%80%EB%8A%94-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/tils/231211/#3️⃣-사용자가-도메인을-입력했을때-웹페이지가-불러와지는-과정"
  },"246": {
    "doc": "TIL (23-12-12)",
    "title": "TIL (23-12-12)",
    "content": " ",
    "url": "/docs/tils/231211/",
    
    "relUrl": "/docs/tils/231211/"
  },"247": {
    "doc": "제작 일지 <_14>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;14&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-14",
    
    "relUrl": "/docs/projects/pongdang/240108/#퐁당-웹-매거진-프로젝트-제작-일지-14"
  },"248": {
    "doc": "제작 일지 <_14>",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/240108/#20240108-mon",
    
    "relUrl": "/docs/projects/pongdang/240108/#20240108-mon"
  },"249": {
    "doc": "제작 일지 <_14>",
    "title": "1️⃣ SpringBoot 서버 백그라운드 실행",
    "content": "서버를 24시간 돌려야하기 때문에, nohup 명령어를 통해 백그라운드에 돌아가게 한다. nohup java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log 2&gt;&amp;1 &amp; . ",
    "url": "/docs/projects/pongdang/240108/#1%EF%B8%8F%E2%83%A3-springboot-%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/pongdang/240108/#1️⃣-springboot-서버-백그라운드-실행"
  },"250": {
    "doc": "제작 일지 <_14>",
    "title": "2️⃣ 서버가 켜지지 않음",
    "content": "인스턴스 재시작시에는, 서비스들이 종료되어 있다. 때문에, nginx를 재시작해준다. sudo systemctl restart nginx . ",
    "url": "/docs/projects/pongdang/240108/#2%EF%B8%8F%E2%83%A3-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EC%A7%80-%EC%95%8A%EC%9D%8C",
    
    "relUrl": "/docs/projects/pongdang/240108/#2️⃣-서버가-켜지지-않음"
  },"251": {
    "doc": "제작 일지 <_14>",
    "title": "3️⃣ Date 자동 출력",
    "content": "Command + Shift + i . ",
    "url": "/docs/projects/pongdang/240108/#3%EF%B8%8F%E2%83%A3-date-%EC%9E%90%EB%8F%99-%EC%B6%9C%EB%A0%A5",
    
    "relUrl": "/docs/projects/pongdang/240108/#3️⃣-date-자동-출력"
  },"252": {
    "doc": "제작 일지 <_14>",
    "title": "4️⃣ AWS 인스턴스 시작 시, 자동 명령어 실행",
    "content": "위의 1, 2번을 자동 실행 되게 하였다. ",
    "url": "/docs/projects/pongdang/240108/#4%EF%B8%8F%E2%83%A3-aws-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%9C%EC%9E%91-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/pongdang/240108/#4️⃣-aws-인스턴스-시작-시-자동-명령어-실행"
  },"253": {
    "doc": "제작 일지 <_14>",
    "title": "5️⃣ 구글 애널리틱스 연동 및 시작",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/#5%EF%B8%8F%E2%83%A3-%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4-%EC%97%B0%EB%8F%99-%EB%B0%8F-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/projects/pongdang/240108/#5️⃣-구글-애널리틱스-연동-및-시작"
  },"254": {
    "doc": "제작 일지 <_14>",
    "title": "제작 일지 <_14>",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/",
    
    "relUrl": "/docs/projects/pongdang/240108/"
  },"255": {
    "doc": "GameChat 계획",
    "title": "토이 프로젝트 - 게임 서버 - GameChat 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/240108/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---gamechat-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/240108/#토이-프로젝트---게임-서버---gamechat-계획"
  },"256": {
    "doc": "GameChat 계획",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240108/#20240108-mon",
    
    "relUrl": "/docs/projects/gameServer/240108/#20240108-mon"
  },"257": {
    "doc": "GameChat 계획",
    "title": "프레임워크",
    "content": "React + SpringBoot . React 내부 페이지에 게임 구동 . ",
    "url": "/docs/projects/gameServer/240108/#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/docs/projects/gameServer/240108/#프레임워크"
  },"258": {
    "doc": "GameChat 계획",
    "title": "게임 구상",
    "content": "채팅과 게임의 결합이다. 현재는 온라인 채팅과 게임 모두 스마트폰안에서 해결할 수 있는 시대이다. 또는 Web으로도 게임 및 채팅이 가능하다. 그래서 이 둘을 함께 즐기는 웹페이지라면, 지속적인 채팅과 게임을 동시에 즐길 수 있지 않을까? 생각하였다. ",
    "url": "/docs/projects/gameServer/240108/#%EA%B2%8C%EC%9E%84-%EA%B5%AC%EC%83%81",
    
    "relUrl": "/docs/projects/gameServer/240108/#게임-구상"
  },"259": {
    "doc": "GameChat 계획",
    "title": "GameChat 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/240108/",
    
    "relUrl": "/docs/projects/gameServer/240108/"
  },"260": {
    "doc": "TIL (24-01-08)",
    "title": "TIL - 퐁당 프로젝트 / 서버 백그라운드 실행",
    "content": " ",
    "url": "/docs/tils/240108/#til---%ED%90%81%EB%8B%B9-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8--%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#til---퐁당-프로젝트--서버-백그라운드-실행"
  },"261": {
    "doc": "TIL (24-01-08)",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/tils/240108/#20240108-mon",
    
    "relUrl": "/docs/tils/240108/#20240108-mon"
  },"262": {
    "doc": "TIL (24-01-08)",
    "title": "1️⃣ SpringBoot 서버 백그라운드 실행",
    "content": "서버를 24시간 돌려야하기 때문에, nohup 명령어를 통해 백그라운드에 돌아가게 한다. nohup java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log 2&gt;&amp;1 &amp; . ",
    "url": "/docs/tils/240108/#1%EF%B8%8F%E2%83%A3-springboot-%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#1️⃣-springboot-서버-백그라운드-실행"
  },"263": {
    "doc": "TIL (24-01-08)",
    "title": "2️⃣ 서버가 켜지지 않음",
    "content": "인스턴스 재시작시에는, 서비스들이 종료되어 있다. 때문에, nginx를 재시작해준다. sudo systemctl restart nginx . ",
    "url": "/docs/tils/240108/#2%EF%B8%8F%E2%83%A3-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EC%A7%80-%EC%95%8A%EC%9D%8C",
    
    "relUrl": "/docs/tils/240108/#2️⃣-서버가-켜지지-않음"
  },"264": {
    "doc": "TIL (24-01-08)",
    "title": "3️⃣ Date 자동 출력",
    "content": "Command + Shift + i . ",
    "url": "/docs/tils/240108/#3%EF%B8%8F%E2%83%A3-date-%EC%9E%90%EB%8F%99-%EC%B6%9C%EB%A0%A5",
    
    "relUrl": "/docs/tils/240108/#3️⃣-date-자동-출력"
  },"265": {
    "doc": "TIL (24-01-08)",
    "title": "4️⃣ AWS 인스턴스 시작 시, 자동 명령어 실행",
    "content": "위의 1, 2번을 자동 실행 되게 하였다. ",
    "url": "/docs/tils/240108/#4%EF%B8%8F%E2%83%A3-aws-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%9C%EC%9E%91-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#4️⃣-aws-인스턴스-시작-시-자동-명령어-실행"
  },"266": {
    "doc": "TIL (24-01-08)",
    "title": "5️⃣ 구글 애널리틱스 연동 및 시작",
    "content": " ",
    "url": "/docs/tils/240108/#5%EF%B8%8F%E2%83%A3-%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4-%EC%97%B0%EB%8F%99-%EB%B0%8F-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/tils/240108/#5️⃣-구글-애널리틱스-연동-및-시작"
  },"267": {
    "doc": "TIL (24-01-08)",
    "title": "TIL (24-01-08)",
    "content": " ",
    "url": "/docs/tils/240108/",
    
    "relUrl": "/docs/tils/240108/"
  },"268": {
    "doc": "GameChat 개발일지 <1>",
    "title": "GameChat 개발일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240108_2/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#gamechat-개발일지-1"
  },"269": {
    "doc": "GameChat 개발일지 <1>",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240108_2/#20240108-mon",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#20240108-mon"
  },"270": {
    "doc": "GameChat 개발일지 <1>",
    "title": "리액트, 스프링 연동 성공",
    "content": "3000은 리액트, 8080은 스프링 . React Connect . ",
    "url": "/docs/projects/gameServer/240108_2/#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%97%B0%EB%8F%99-%EC%84%B1%EA%B3%B5",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#리액트-스프링-연동-성공"
  },"271": {
    "doc": "GameChat 개발일지 <1>",
    "title": "GameChat 개발일지 <1>",
    "content": " ",
    "url": "/docs/projects/gameServer/240108_2/",
    
    "relUrl": "/docs/projects/gameServer/240108_2/"
  },"272": {
    "doc": "GameChat 개발일지 <2>",
    "title": "GameChat 개발일지 &lt;2&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240113/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-2",
    
    "relUrl": "/docs/projects/gameServer/240113/#gamechat-개발일지-2"
  },"273": {
    "doc": "GameChat 개발일지 <2>",
    "title": "2024.01.13 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240113/#20240113-sat",
    
    "relUrl": "/docs/projects/gameServer/240113/#20240113-sat"
  },"274": {
    "doc": "GameChat 개발일지 <2>",
    "title": "Room 페이지 제작 중 …",
    "content": "계획이 뭔가!? . | Room의 디자인 | . 해당 페이지는 본격적으로 채팅 + 게임이 포함된다. 배치는 왼쪽 게임, 오른쪽 채팅을 생각하고 있다. 그렇지만 많은 게임들이 채팅은 필수이며, 없는 곳을 찾기 힘들다.(온라인 게임) 그래서 차별점을 주어야 한다. 그래서 준 차별점이 게임과 채팅의 상호작용이다! . ",
    "url": "/docs/projects/gameServer/240113/#room-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%A0%9C%EC%9E%91-%EC%A4%91-",
    
    "relUrl": "/docs/projects/gameServer/240113/#room-페이지-제작-중-"
  },"275": {
    "doc": "GameChat 개발일지 <2>",
    "title": "게임과 채팅의 상호작용을 통한 차별점",
    "content": "그거 어떻게 하는건데? . 게임에서의 점수나 이벤트들을 채팅에 적용시키거나, 그 거꾸로의 상황도 충족시키는 것이다. ",
    "url": "/docs/projects/gameServer/240113/#%EA%B2%8C%EC%9E%84%EA%B3%BC-%EC%B1%84%ED%8C%85%EC%9D%98-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%B0%A8%EB%B3%84%EC%A0%90",
    
    "relUrl": "/docs/projects/gameServer/240113/#게임과-채팅의-상호작용을-통한-차별점"
  },"276": {
    "doc": "GameChat 개발일지 <2>",
    "title": "GameChat 개발일지 <2>",
    "content": " ",
    "url": "/docs/projects/gameServer/240113/",
    
    "relUrl": "/docs/projects/gameServer/240113/"
  },"277": {
    "doc": "제작 일지 <_15>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;15&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/240115/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-15",
    
    "relUrl": "/docs/projects/pongdang/240115/#퐁당-웹-매거진-프로젝트-제작-일지-15"
  },"278": {
    "doc": "제작 일지 <_15>",
    "title": "2024.01.15 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/240115/#20240115-mon",
    
    "relUrl": "/docs/projects/pongdang/240115/#20240115-mon"
  },"279": {
    "doc": "제작 일지 <_15>",
    "title": "1️⃣ 해외 아이피 차단",
    "content": "국내 사용자가 대부분이라, 해외 아이피를 차단하였다. AWS를 사용하고 있어서 AWS WAF의 Web ACLs를 사용하여 차단해주었다. ",
    "url": "/docs/projects/pongdang/240115/#1%EF%B8%8F%E2%83%A3-%ED%95%B4%EC%99%B8-%EC%95%84%EC%9D%B4%ED%94%BC-%EC%B0%A8%EB%8B%A8",
    
    "relUrl": "/docs/projects/pongdang/240115/#1️⃣-해외-아이피-차단"
  },"280": {
    "doc": "제작 일지 <_15>",
    "title": "제작 일지 <_15>",
    "content": " ",
    "url": "/docs/projects/pongdang/240115/",
    
    "relUrl": "/docs/projects/pongdang/240115/"
  },"281": {
    "doc": "GameChat 개발일지 <3>",
    "title": "GameChat 개발일지 &lt;3&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240115/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-3",
    
    "relUrl": "/docs/projects/gameServer/240115/#gamechat-개발일지-3"
  },"282": {
    "doc": "GameChat 개발일지 <3>",
    "title": "2024.01.15 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240115/#20240115-mon",
    
    "relUrl": "/docs/projects/gameServer/240115/#20240115-mon"
  },"283": {
    "doc": "GameChat 개발일지 <3>",
    "title": "방명록 느낌을 메인에 만들기",
    "content": "사람들이 자유롭게 와서 글을 남기는 것 게임에 대한, 채팅에 대한 토론도 좋다. 글을 작성한 사람의 ip를 저장하여 로그 관리 . ",
    "url": "/docs/projects/gameServer/240115/#%EB%B0%A9%EB%AA%85%EB%A1%9D-%EB%8A%90%EB%82%8C%EC%9D%84-%EB%A9%94%EC%9D%B8%EC%97%90-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/projects/gameServer/240115/#방명록-느낌을-메인에-만들기"
  },"284": {
    "doc": "GameChat 개발일지 <3>",
    "title": "GameChat 개발일지 <3>",
    "content": " ",
    "url": "/docs/projects/gameServer/240115/",
    
    "relUrl": "/docs/projects/gameServer/240115/"
  },"285": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "프로그래머스 Lv.1 - 예산",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240122/",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/"
  },"286": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "2024.01.23 (TUE)",
    "content": ". 문제 : 예산 . ",
    "url": "/docs/codingtest/1day1coding/240122/#20240123-tue",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#20240123-tue"
  },"287": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "풀이",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/240122/#%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#풀이"
  },"288": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "결과 코드",
    "content": "/* * Date : 2024.01.23 (TUE) * Title : 프로그래머스 Lv.1 - 예산 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12982 */ import java.util.*; class Solution { public int solution(int[] d, int budget) { int answer = 0; Arrays.sort(d); for(int i = 0; i &lt; d.length; i++) { if (budget &lt; d[i]) { break; } budget -= d[i]; answer++; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240122/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#결과-코드"
  },"289": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240205/",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/"
  },"290": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "2024.02.05 (MON)",
    "content": ". 문제 : 성격 유형 검사하기 . ",
    "url": "/docs/codingtest/1day1coding/240205/#20240205-mon",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#20240205-mon"
  },"291": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "풀이",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/240205/#%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#풀이"
  },"292": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "결과 코드",
    "content": "/* * Date : 2024.02.05 (MON) * Title : 프로그래머스 Lv.1 - 성격 유형 검사하기 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/118666 */ import java.util.*; class Solution { public String solution(String[] survey, int[] choices) { String answer = \"\"; int index = 0; char[] words = new char[8]; int[] counts = new int[8]; words[0] = 'R'; words[1] = 'T'; words[2] = 'C'; words[3] = 'F'; words[4] = 'J'; words[5] = 'M'; words[6] = 'A'; words[7] = 'N'; for (int i = 0; i &lt; counts.length; i++) { counts[i] = 0; } // 점수 매기기 while (index &lt; survey.length) { if (choices[index] &gt; 4) { // 동의 for (int i = 0; i &lt; words.length; i++) { if (survey[index].charAt(1) == words[i]) { counts[i] += choices[index] - 4; } } } else if (choices[index] &lt; 4) { // 비동의 for (int i = 0; i &lt; words.length; i++) { if (survey[index].charAt(0) == words[i]) { counts[i] += 4 - choices[index]; } } } index++; } // 유형 결정 if (counts[0] &gt;= counts[1]) { answer += \"R\"; } else { answer += \"T\"; } if (counts[2] &gt;= counts[3]) { answer += \"C\"; } else { answer += \"F\"; } if (counts[4] &gt;= counts[5]) { answer += \"J\"; } else { answer += \"M\"; } if (counts[6] &gt;= counts[7]) { answer += \"A\"; } else { answer += \"N\"; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240205/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#결과-코드"
  },"293": {
    "doc": "도커에 웹서버 띄우기",
    "title": "도커에 웹서버 띄우기",
    "content": " ",
    "url": "/docs/projects/deverse/240312/",
    
    "relUrl": "/docs/projects/deverse/240312/"
  },"294": {
    "doc": "도커에 웹서버 띄우기",
    "title": "2024.03.11 (TUE)",
    "content": ". ",
    "url": "/docs/projects/deverse/240312/#20240311-tue",
    
    "relUrl": "/docs/projects/deverse/240312/#20240311-tue"
  },"295": {
    "doc": "도커에 웹서버 띄우기",
    "title": "개요",
    "content": ". | 웹서버를 도커에 배포한다 | Host OS: Ubuntu 22.04.4 LTS | . ",
    "url": "/docs/projects/deverse/240312/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/deverse/240312/#개요"
  },"296": {
    "doc": "도커에 웹서버 띄우기",
    "title": "Springboot 프로젝트 탑재",
    "content": ". | Dockerfile 파일 생성 | Gradle Clean | build.gradle에 아래 코드 작성 후, 업데이트 jar { enabled = false } . | Gradle bootJar 실행 | docker build -t 실행하여 이미지 생성 | . | 현재 이미지 생성까지 하였다. 이를 로컬서버에 구동시켜야한다. | . 2024-03-13 22:40:38 . ",
    "url": "/docs/projects/deverse/240312/#springboot-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%83%91%EC%9E%AC",
    
    "relUrl": "/docs/projects/deverse/240312/#springboot-프로젝트-탑재"
  },"297": {
    "doc": "도커에 웹서버 띄우기",
    "title": "프로젝트 작동 여부 확인",
    "content": ". | 스프링부트 프로젝트가 build 될 때, React 프로젝트가 먼저 build되어, 그 결과물을 스프링부트 프로젝트 build 결과물에 포함시킨다. | localhost:8080에 접근하면 페이지가 나오는 것을 볼 수 있다. | . ",
    "url": "/docs/projects/deverse/240312/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9E%91%EB%8F%99-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/projects/deverse/240312/#프로젝트-작동-여부-확인"
  },"298": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 순위\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/49191?language=java\" . ",
    "url": "/docs/codingtest/1day1coding/240724/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#문제"
  },"299": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "문제 풀이",
    "content": "문제 접근 . | 순위를 매길 수 있는 선수는 모든 선수와 대결을 한 선수? -&gt; X | 모든 경기 결과를 배열에 정리하여 파악해보자. 경기 결과 정리 . public static int[][] calGame(int n, int[][] results) { int[][] allGame = new int[n][n]; // init allGame (7-none, 1-win, -1-lose) for (int i = 0; i &lt; n; i++) { allGame[i][i] = 7; // none } for (int i = 0; i &lt; n; i++) { allGame[results[i][0]-1][results[i][1]-1] = 1; // win allGame[results[i][1]-1][results[i][0]-1] = -1; // lose } return allGame; } . | 결과 7 1 0 0 0 -1 7 -1 -1 1 0 1 7 -1 0 0 1 1 7 0 0 -1 0 0 7 경기 결과 분석 . | 0이 없는 선수는 순위를 정확히 매길 수 있다. | 또한 그 선수들의 순위 기준으로 다른 선수들의 순위를 알 수도 있다. | 자신과 다른 모든 선수 간의 관계를 알 수 있는 선수만이 자신의 정확한 순위를 알 수 있다. | 내가 만약 4위에게 졌다면, 그에게 이긴 3명은 못이긴다. | . | . 간단한 수도 코드 정리 . 1 Initialize the allGame matrix: Create an n x n matrix initialized with 0. For each [A, B] in results: Mark A beats B as 1 Mark B loses to A as -1. 2 Apply Floyd-Warshall algorithm: For each k from 0 to n-1: For each i from 0 to n-1: For each j from 0 to n-1: If i beats k and k beats j, then i beats j. If i loses to k and k loses to j, then i loses to j. 3 Count players with certain ranks: Initialize count to 0. For each player i from 0 to n-1: Check if i has results against all other players. If yes, increment count. 4 Return the count. ",
    "url": "/docs/codingtest/1day1coding/240724/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#문제-풀이"
  },"300": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int n, int[][] results) { int[][] allGame = calGame(n, results); // 플로이드-워셜 알고리즘을 통해 모든 선수 간의 승패 정보를 갱신 for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (allGame[i][k] == 1 &amp;&amp; allGame[k][j] == 1) { allGame[i][j] = 1; } if (allGame[i][k] == -1 &amp;&amp; allGame[k][j] == -1) { allGame[i][j] = -1; } } } } // 선수들의 승패 정보가 확실한 선수의 수를 셉니다. int answer = 0; for (int i = 0; i &lt; n; i++) { boolean certain = true; for (int j = 0; j &lt; n; j++) { if (i != j &amp;&amp; allGame[i][j] == 0) { certain = false; break; } } if (certain) { answer++; } } return answer; } public static int[][] calGame(int n, int[][] results) { int[][] allGame = new int[n][n]; // init allGame (0-unknown, 1-win, -1-lose) for (int i = 0; i &lt; n; i++) { allGame[i][i] = 0; // self match (irrelevant) } for (int i = 0; i &lt; results.length; i++) { allGame[results[i][0] - 1][results[i][1] - 1] = 1; // win allGame[results[i][1] - 1][results[i][0] - 1] = -1; // lose } return allGame; } } . ",
    "url": "/docs/codingtest/1day1coding/240724/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#풀이-코드"
  },"301": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "프로그래머스 Lv.3 - 순위",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240724/",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/"
  },"302": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 방문 길이\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/49994\" . ",
    "url": "/docs/codingtest/1day1coding/240825/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#문제"
  },"303": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "문제 풀이",
    "content": "문제 접근 . HashSet에 이미 지나간 경로 저장 (양쪽으로) . 간단한 수도 코드 정리 . ",
    "url": "/docs/codingtest/1day1coding/240825/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#문제-풀이"
  },"304": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "풀이 코드",
    "content": "import java.util.HashSet; import java.util.Set; class Solution { public int solution(String dirs) { int answer = 0; int x = 0, y = 0; Set&lt;String&gt; visitedPaths = new HashSet&lt;&gt;(); for (char dir : dirs.toCharArray()) { int nextX = x; int nextY = y; switch (dir) { case 'U': nextY++; break; case 'D': nextY--; break; case 'R': nextX++; break; case 'L': nextX--; break; } if (nextX &lt; -5 || nextX &gt; 5 || nextY &lt; -5 || nextY &gt; 5) { // 경계를 벗어나는 경우 무시 continue; } // 경로 저장 String path1 = x + \"\" + y + \"\" + nextX + \"\" + nextY; String path2 = nextX + \"\" + nextY + \"\" + x + \"\" + y; // 처음 방문한 길이라면 기록 if (!visitedPaths.contains(path1) &amp;&amp; !visitedPaths.contains(path2)) { visitedPaths.add(path1); visitedPaths.add(path2); answer++; } // 좌표 업데이트 x = nextX; y = nextY; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240825/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#풀이-코드"
  },"305": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "프로그래머스 Lv.2 - 방문 길이",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240825/",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/"
  },"306": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 롤케이크 자르기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/132265\" . | . ",
    "url": "/docs/codingtest/1day1coding/240827/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#문제"
  },"307": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "문제 풀이",
    "content": "문제 접근 . 간단한 수도 코드 정리 . Type/Paste Your Code . ",
    "url": "/docs/codingtest/1day1coding/240827/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#문제-풀이"
  },"308": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int[] topping) { int answer = 0; int left = 0; int right = topping.length - 1; // Initialize sets for left and right side toppings Set&lt;Integer&gt; leftSet = new HashSet&lt;&gt;(); Set&lt;Integer&gt; rightSet = new HashSet&lt;&gt;(); // Array to store unique topping count up to each index from the left int[] leftUnique = new int[topping.length]; for (int i = 0; i &lt; topping.length; i++) { leftSet.add(topping[i]); leftUnique[i] = leftSet.size(); } // Array to store unique topping count up to each index from the right int[] rightUnique = new int[topping.length]; for (int i = topping.length - 1; i &gt;= 0; i--) { rightSet.add(topping[i]); rightUnique[i] = rightSet.size(); } // Compare the unique topping count in left and right part using binary search for (int i = 0; i &lt; topping.length - 1; i++) { if (leftUnique[i] == rightUnique[i + 1]) { answer++; } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240827/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#풀이-코드"
  },"309": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240827/",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/"
  },"310": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 최솟값 만들기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12941\" . ",
    "url": "/docs/codingtest/1day1coding/240902/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#문제"
  },"311": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 한 배열은 오름차순, 한 배열은 내림차순 정렬 후, 계산 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240902/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#문제-풀이"
  },"312": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int []A, int []B) { int answer = 0; // sort Arrays.sort(A); Integer[] B2 = Arrays.stream(B).boxed().toArray(Integer[]::new); Arrays.sort(B2, Collections.reverseOrder()); // sum for (int i = 0; i &lt; A.length; i++) { answer += A[i] * B2[i]; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240902/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#풀이-코드"
  },"313": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "프로그래머스 Lv.2 - 최솟값 만들기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240902/",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/"
  },"314": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 주식가격\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/42584?language=java\" . | . ",
    "url": "/docs/codingtest/1day1coding/240911/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#문제"
  },"315": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "문제 풀이",
    "content": "문제 접근 . | Stack 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240911/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#문제-풀이"
  },"316": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "풀이 코드",
    "content": "class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; for (int i = 0; i &lt; prices.length; i++) { int time = 0; for (int j = i + 1; j &lt; prices.length; j++) { time++; if (prices[i] &gt; prices[j]) { break; // 가격이 떨어지면 멈춤 } } answer[i] = time; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240911/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#풀이-코드"
  },"317": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "프로그래머스 Lv.2 - 주식가격",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240911/",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/"
  },"318": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 | 프로그래머스 스쿨\" image: \"https://school.programmers.co.kr/assets/img-meta-programmers-86b32ab1929330ced348f75cf9a8033cbf8da3e78611d80f05dc3a321927f13b.png\" description: \"개발자 취업의 필수 관문 코딩테스트를 철저하게 연습하고 대비할 수 있는 문제를 총망라! 프로그래머스에서 선발한 문제로 유형을 파악하고 실력을 업그레이드해 보세요!\" url: \"https://school.programmers.co.kr/learn/challenges?order=recent&amp;languages=java\" . ",
    "url": "/docs/codingtest/1day1coding/240920/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#문제"
  },"319": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 빈 스택을 생성합니다. | 문자열의 각 문자를 순회합니다. | 현재 문자가 스택의 top과 같으면 스택에서 pop합니다. | 그렇지 않으면 현재 문자를 스택에 push합니다. | 모든 문자를 처리한 후, 스택이 비어있으면 1을 반환하고 그렇지 않으면 0을 반환합니다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/240920/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#문제-풀이"
  },"320": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) { if (!stack.isEmpty() &amp;&amp; stack.peek() == c) { stack.pop(); } else { stack.push(c); } } return stack.isEmpty() ? 1 : 0; } } . ",
    "url": "/docs/codingtest/1day1coding/240920/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#풀이-코드"
  },"321": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240920/",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/"
  },"322": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 124 나라의 숫자\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12899\" . | . ",
    "url": "/docs/codingtest/1day1coding/240921/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#문제"
  },"323": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "문제 풀이",
    "content": "문제 접근 . | 10진법 | 124 나라 | 10진법 | 124 나라 | —- | —— | —- | —— | 1 | 1 | 6 | 14 | 2 | 2 | 7 | 21 | 3 | 4 | 8 | 22 | 4 | 11 | 9 | 24 | 5 | 12 | 10 | 41 | . | 3진법인데, 숫자만 1, 2, 4이다. | 10진법 숫자를 3으로 나눠, 나머지를 정리하고 . | 그것을 124 나라만의 숫자로 변경한다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/240921/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#문제-풀이"
  },"324": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public String solution(int n) { StringBuilder answer = new StringBuilder(); String[] digits = {\"4\", \"1\", \"2\"}; while (n &gt; 0) { int remainder = n % 3; n = (n - 1) / 3; answer.insert(0, digits[remainder]); } return answer.toString(); } } . ",
    "url": "/docs/codingtest/1day1coding/240921/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#풀이-코드"
  },"325": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240921/",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/"
  },"326": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 연속된 부분 수열의 합\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/178870\" . | . ",
    "url": "/docs/codingtest/1day1coding/240923/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#문제"
  },"327": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "문제 풀이",
    "content": "문제 접근 . | 투 포인터 기법 사용: left와 right 포인터를 사용하여 연속된 부분 수열을 효율적으로 탐색 | 합계 계산 최적화: 매번 큐의 합을 계산하는 대신, sum 변수를 사용하여 현재 부분 수열의 합을 유지 | 최소 길이 부분 수열 찾기: minLength 변수를 사용하여 조건을 만족하는 가장 짧은 부분 수열 찾기 | 결과 저장: 조건을 만족하는 부분 수열을 찾을 때마다 answer 배열 업데이트 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240923/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#문제-풀이"
  },"328": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "풀이 코드",
    "content": "class Solution { public int[] solution(int[] sequence, int k) { int left = 0; int right = 0; int sum = 0; int minLength = Integer.MAX_VALUE; int[] answer = new int[2]; while (right &lt; sequence.length) { sum += sequence[right]; while (sum &gt;= k) { if (sum == k &amp;&amp; right - left + 1 &lt; minLength) { minLength = right - left + 1; answer[0] = left; answer[1] = right; } sum -= sequence[left]; left++; } right++; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240923/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#풀이-코드"
  },"329": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240923/",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/"
  },"330": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 4단 고음\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/1831\" . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#문제"
  },"331": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "문제 풀이",
    "content": "문제 접근 . | 모든 경우의 수를 볼 수 없다. | 제일 큰 경우의 문자열은 *++ *++ = 17 | 최소는 **++++ = 13 | 위는 규칙성이 있을까? . | 최대는 *++만큼 증가 (x3 +2) | 최소는 3*n + n*2 | 최종음높이에 따라, 가능한 3단고음의 개수의 범위를 구한다. | . | 이후, 계산 . | 스택을 활용해서, 올바른 문자열인지 확인할까? (효율적인가? 과연?) | 모든 조합은 안된다. -&gt; +로 시작하는 등의 예제가 n과 일치할 수도 있다. | 조건 . | 첫번째는 무조건 * | 마지막 * 뒤는 무조건 +가 두개 이상. | * 는 n-별순서 만큼의 두 배만큼 간단한 수도 코드 정리 . ```pseudocode 함수 solution(n): 초기화 answer = 0 초기화 min_pattern = 0 초기화 max_pattern = 0 . | . | . // 최소 패턴 길이 계산 초기화 tmp = 0 WHILE n &gt;= tmp AND tmp &lt;= Integer.MAX_VALUE: tmp = 3^(min_pattern + 1) + (min_pattern + 1)^2 min_pattern = min_pattern + 1 END WHILE min_pattern = min_pattern - 1 // 최소 패턴 길이 감소 . // 최대 패턴 길이 계산 초기화 tmp = 1 WHILE n &gt;= tmp AND tmp &lt;= Integer.MAX_VALUE: tmp = tmp * 3 + 2 max_pattern = max_pattern + 1 END WHILE . // 결과 계산 FOR i FROM min_pattern TO max_pattern: answer = answer + calResult(n, i) END FOR . RETURN answer . | . 함수 calResult(n, pattern): 초기화 count = 0 초기화 combinations = 빈 리스트 generateCombinations(“”, pattern, pattern * 2, combinations) . FOR 각 조합 s IN combinations: 초기화 sum = 1 FOR 각 문자 c IN s: IF c == '*': sum = sum * 3 ELSE IF c == '+': sum = sum + 1 END IF END FOR IF n == sum: count = count + 1 출력 s END IF END FOR RETURN count . // 재귀적으로 문자열 조합을 생성하는 메소드 함수 generateCombinations(current, remainingStars, remainingPluses, combinations): // 현재 조합에서 ‘*‘와 ‘+’의 개수가 다 사용되었으면 추가 IF remainingStars == 0 AND remainingPluses == 0: 추가 current TO combinations RETURN . // '*'가 남아있다면 추가 IF remainingStars &gt; 0: generateCombinations(current + \"*\", remainingStars - 1, remainingPluses, combinations) END IF // '+'가 남아있다면 추가 IF remainingPluses &gt; 0: generateCombinations(current + \"+\", remainingStars, remainingPluses - 1, combinations) END IF . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(int n) { int answer = 0; int min_pattern = 0; // 3단고음 패턴의 최소 갯수 int max_pattern = 0; // 3단고음 패턴의 최대 갯수 // min max length int tmp = 0; while (n &gt;= tmp || tmp &gt; Integer.MAX_VALUE) { tmp = (int)Math.pow(3, min_pattern+1) + (int)Math.pow(min_pattern+1, 2); min_pattern++; } min_pattern--; tmp = 1; while (n &gt;= tmp || tmp &gt; Integer.MAX_VALUE) { tmp = tmp * 3 + 2; max_pattern++; } // result for (int i = min_pattern; i &lt;= max_pattern; i++) { answer += calResult(n, i); } return answer; } public static int calResult(int n, int pattern) { int count = 0; List&lt;String&gt; combinations = new ArrayList&lt;&gt;(); generateCombinations(\"\", pattern, pattern*2, combinations); for (String s : combinations) { int sum = 1; for (char c : s.toCharArray()) { if (c == '*') { sum *= 3; } else if (c == '+') { sum++; } } if (n == sum) { count++; System.out.println(s); } } return count; } // 재귀적으로 문자열 조합을 생성하는 메소드 private static void generateCombinations(String current, int remainingStars, int remainingPluses, List&lt;String&gt; combinations) { // 현재 조합에서 '*'와 '+'의 개수가 다 사용되었으면 추가 if (remainingStars == 0 &amp;&amp; remainingPluses == 0) { combinations.add(current); return; } // '*'가 남아있다면 추가 if (remainingStars &gt; 0) { generateCombinations(current + \"*\", remainingStars - 1, remainingPluses, combinations); } // '+'가 남아있다면 추가 if (remainingPluses &gt; 0) { generateCombinations(current + \"+\", remainingStars, remainingPluses - 1, combinations); } } } . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#문제-풀이"
  },"332": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "미완성 코드다..",
    "content": "| |—|—|테스트 1| |입력값 〉|15|기댓값 〉|1|실행 결과 〉|테스트를 통과하였습니다.|출력 〉|++++| . |   |   | . | 테스트 2 |   | . | 입력값 〉 | 24 | . | 기댓값 〉 | 0 | . | 실행 결과 〉 | 테스트를 통과하였습니다. | . |   |   | . | 테스트 3 |   | . | 입력값 〉 | 41 | . | 기댓값 〉 | 2 | . | 실행 결과 〉 | 테스트를 통과하였습니다. | . | 출력 〉 | ++++++ ++++++ | . |   |   | . | 테스트 4 |   | . | 입력값 〉 | 2147483647 | . | 기댓값 〉 | 1735 | . | 실행 결과 〉 | 실행 중단 | . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AF%B8%EC%99%84%EC%84%B1-%EC%BD%94%EB%93%9C%EB%8B%A4",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#미완성-코드다"
  },"333": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240925/",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/"
  },"334": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - [1차] 셔틀버스\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/17678\" . ",
    "url": "/docs/codingtest/1day1coding/240930/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#문제"
  },"335": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 문제는 여러 대의 셔틀버스가 특정 시간 간격으로 운행되며, 각 셔틀에는 제한된 인원만 탑승할 수 있다는 조건이 주어진다. 주어진 크루들의 도착 시간에 따라 셔틀을 이용하는 방법을 계획해야 하며, 주인공인 콘이 가장 늦게 셔틀을 탈 수 있는 시간을 계산하는 문제이다. 핵심은 셔틀 도착 시간과 대기열에서 크루의 탑승 시간을 비교하여, 콘이 가장 늦게 셔틀을 탈 수 있는 시간을 구하는 것이다. 모든 크루가 도착한 시간 순서대로 줄을 서게 되므로, 이 문제는 크루의 도착 시간을 정렬한 후 각 셔틀에 크루들을 적절하게 배치하는 과정에서 답을 찾을 수 있다. 간단한 수도 코드 정리 . 1. 크루들의 도착 시간을 분 단위로 변환한다. 2. 변환된 시간 배열을 정렬한다. 3. 첫 번째 셔틀은 09:00에 도착하며, 이후 n회의 셔틀이 t분 간격으로 도착한다. 4. 각 셔틀 도착 시각마다 최대 m명의 크루를 태울 수 있다. 5. 마지막 셔틀에 콘이 타기 위해 가능한 가장 늦은 시간을 계산한다. - 마지막 셔틀에 자리가 있다면 셔틀 도착 시간에 맞춰 콘이 탈 수 있다. - 자리가 없다면 마지막으로 탄 크루보다 1분 먼저 콘이 도착해야 한다. 6. 콘이 탈 수 있는 가장 늦은 시간을 HH:MM 형식으로 반환한다. ",
    "url": "/docs/codingtest/1day1coding/240930/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#문제-풀이"
  },"336": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public String solution(int n, int t, int m, String[] timetable) { // timetable을 분 단위로 변환 int[] timeNum = new int[timetable.length]; for (int i = 0; i &lt; timetable.length; i++) { String[] time = timetable[i].split(\":\"); timeNum[i] = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]); } // 크루 도착 시간을 정렬 Arrays.sort(timeNum); int busTime = 540; // 첫 셔틀 시간 (09:00) int idx = 0; // 대기열에서 크루 인덱스 int lastTime = 0; // 콘이 탈 수 있는 가장 늦은 시간 // 각 셔틀을 순서대로 처리 for (int i = 0; i &lt; n; i++) { int count = 0; // 셔틀에 탑승한 크루 수 // 셔틀에 탈 수 있는 크루를 체크 while (idx &lt; timeNum.length &amp;&amp; timeNum[idx] &lt;= busTime &amp;&amp; count &lt; m) { count++; idx++; } // 마지막 셔틀일 때 if (i == n - 1) { if (count &lt; m) { // 자리가 있으면 셔틀 도착 시간에 콘이 탑승 lastTime = busTime; } else { // 자리가 없으면 마지막으로 탄 크루보다 1분 먼저 와야 함 lastTime = timeNum[idx - 1] - 1; } } // 다음 셔틀 시간 계산 busTime += t; } // 시각을 HH:MM 형식으로 변환 String hour = String.format(\"%02d\", lastTime / 60); String minute = String.format(\"%02d\", lastTime % 60); return hour + \":\" + minute; } } . ",
    "url": "/docs/codingtest/1day1coding/240930/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#풀이-코드"
  },"337": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "프로그래머스 Lv.3 - 셔틀 버스",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240930/",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/"
  },"338": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 최고의 집합\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 ”집합”으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12938\" . ",
    "url": "/docs/codingtest/1day1coding/241001/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#문제"
  },"339": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "문제 풀이",
    "content": "문제 접근 . | 간단히 쪼갤 수 있는 수 중, 차이가 가장 적은 수들의 조합을 선택하면 된다. | 입력 검증: | . | n이 s보다 크면 균등하게 나눌 수 없으므로 배열에 -1을 담아서 반환한다. | 배열 초기화: | . | 나눌 수 있는 기본 값 num을 s / n으로 계산한다. | 나머지 값 add를 s % n으로 계산한다. | 큰 값 할당: | . | add 개수만큼 배열의 앞부분에 num + 1을 할당한다. | 작은 값 할당: | . | 나머지 부분에는 num을 할당한다. | 결과 반환: | . | 배열을 오름차순으로 정렬하여 반환한다. | . | . 간단한 수도 코드 정리 . 함수 solution(n, s) { 만약 n &gt; s 이면 배열 answer에 -1을 넣고 반환 배열 answer를 크기 n으로 초기화 num을 s / n으로 설정 (기본 나눌 값) add를 s % n으로 설정 (나머지 값) add만큼 반복 { answer의 앞부분에 num + 1을 넣음 } 나머지 부분에 num을 넣음 answer를 정렬 answer 반환 } . ",
    "url": "/docs/codingtest/1day1coding/241001/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#문제-풀이"
  },"340": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int[] solution(int n, int s) { int[] answer = {}; if (n &gt; s) { answer = new int[1]; answer[0] = -1; } else { answer = new int[n]; int num = 0; // s가 쪼개져서 나온 숫자 int add = 0; // 쪼개고 남는 숫자 num = s / n; add = s % n; System.out.println(add); for (int i = 0; i &lt; add; i++) { answer[i] = num + 1; } for (int i = add; i &lt; n; i++) { answer[i] = num; } Arrays.sort(answer); } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241001/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#풀이-코드"
  },"341": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "프로그래머스 Lv.3 - 최고의 집합",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241001/",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/"
  },"342": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 금과 은 운반하기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/86053\" . ",
    "url": "/docs/codingtest/1day1coding/241008/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#문제"
  },"343": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 이분탐색으로 시간을 두고, 적절한 mid를 찾으면 된다. | 시간을 조금 썼던 부분은, 최댓값 지정이였다. | 금과 은, 그리고 이동거리를 따졌을때, 나오는 최대 시간으로 하면 모든 케이스들을 통과할 수 있다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/241008/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#문제-풀이"
  },"344": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "풀이 코드",
    "content": "class Solution { public long solution(int a, int b, int[] g, int[] s, int[] w, int[] t) { long answer = -1; long left = 0; long right = (long) (1e9 * 2 * 1e5 * 2); while (left &lt;= right) { long mid = (left + right) / 2; // 해당 시간 내에 운반할 수 있는 금과 은의 총합 long totalGold = 0; long totalSilver = 0; long totalAll = 0; for (int i = 0; i &lt; g.length; i++) { // mid 시간 내에서 왕복 long tripCount = mid / (2 * t[i]); // 편도 체크 if (mid % (2 * t[i]) &gt;= t[i]) { tripCount++; } // 트럭 운반 최대량 long maxTransport = tripCount * w[i]; // 금, 은 운반 가능량 long transportGold = Math.min(g[i], maxTransport); long transportSilver = Math.min(s[i], maxTransport); // 금, 은 합쳐서 계산 totalGold += transportGold; totalSilver += transportSilver; totalAll += Math.min(g[i] + s[i], maxTransport); } // 금, 은 만족하는지 검사 if (totalGold &gt;= a &amp;&amp; totalSilver &gt;= b &amp;&amp; totalAll &gt;= (a + b)) { answer = mid; right = mid - 1; } else { left = mid + 1; } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241008/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#풀이-코드"
  },"345": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241008/",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/"
  },"346": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 퍼즐 조각 채우기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/84021\" . ",
    "url": "/docs/codingtest/1day1coding/241022/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#문제"
  },"347": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 보드와 퍼즐의 모양을 저장하는 배열을 만든다. (dfs) | 보드와 퍼즐을 대조(+회전)하여 맞으면 퍼즐의 수를 + 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/241022/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#문제-풀이"
  },"348": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int[][] game_board, int[][] table) { int answer = 0; List&lt;int[][]&gt; boardList = new ArrayList&lt;&gt;(); List&lt;int[][]&gt; tableList = new ArrayList&lt;&gt;(); // game_board에서 빈 공간(0)을 조각으로 추출하여 boardList에 저장 saveList(game_board, boardList, 0); // table에서 채워진 공간(1)을 조각으로 추출하여 tableList에 저장 saveList(table, tableList, 1); // 각 테이블 조각을 게임 보드의 빈 공간과 비교하여 맞는지 확인 boolean[] used = new boolean[tableList.size()]; for (int[][] boardPiece : boardList) { for (int i = 0; i &lt; tableList.size(); i++) { if (!used[i] &amp;&amp; doesPieceMatch(boardPiece, tableList.get(i))) { answer += countCells(tableList.get(i)); // 맞으면 셀 개수 더함 used[i] = true; break; } } } return answer; } // 빈 공간 또는 채워진 공간을 찾아서 조각 리스트에 저장 public static void saveList(int[][] board, List&lt;int[][]&gt; result, int targetNum) { int n = board.length; boolean[][] visited = new boolean[n][n]; // 방문 여부 체크를 위한 배열 // 상, 하, 좌, 우 탐색을 위한 방향 배열 int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; // 보드 전체를 순회하며 DFS로 조각을 찾음 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // 아직 방문하지 않은 targetNum인 경우 DFS 시작 if (board[i][j] == targetNum &amp;&amp; !visited[i][j]) { List&lt;int[]&gt; piece = new ArrayList&lt;&gt;(); // 현재 조각을 저장할 리스트 dfs(board, visited, i, j, piece, targetNum, dx, dy); // 조각을 배열로 변환하여 result에 추가 result.add(convertPieceToArray(piece)); } } } } // DFS 탐색 함수 private static void dfs(int[][] board, boolean[][] visited, int x, int y, List&lt;int[]&gt; piece, int targetNum, int[] dx, int[] dy) { visited[x][y] = true; piece.add(new int[]{x, y}); int n = board.length; // 상, 하, 좌, 우 방향으로 탐색 for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; // 범위 내에 있고, 방문하지 않았으며, targetNum과 동일한 경우 if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; board[nx][ny] == targetNum &amp;&amp; !visited[nx][ny]) { dfs(board, visited, nx, ny, piece, targetNum, dx, dy); } } } // 조각을 리스트에서 2차원 배열로 변환 private static int[][] convertPieceToArray(List&lt;int[]&gt; piece) { // 조각의 크기를 구함 int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE; int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE; for (int[] coord : piece) { minX = Math.min(minX, coord[0]); minY = Math.min(minY, coord[1]); maxX = Math.max(maxX, coord[0]); maxY = Math.max(maxY, coord[1]); } // 조각을 담을 배열 생성 int[][] array = new int[maxX - minX + 1][maxY - minY + 1]; // 조각의 좌표를 배열에 채움 for (int[] coord : piece) { array[coord[0] - minX][coord[1] - minY] = 1; } return array; } // 조각을 회전시키는 함수 public static int[][] rotate(int[][] piece) { int n = piece.length; int m = piece[0].length; int[][] rotated = new int[m][n]; // 회전된 조각을 저장할 배열 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { rotated[j][n - 1 - i] = piece[i][j]; // 시계 방향으로 90도 회전 } } return rotated; } // 두 조각이 같은지 비교하는 함수 public static boolean areSamePiece(int[][] piece1, int[][] piece2) { if (piece1.length != piece2.length || piece1[0].length != piece2[0].length) { return false; // 크기가 다르면 일치할 수 없음 } for (int i = 0; i &lt; piece1.length; i++) { for (int j = 0; j &lt; piece1[0].length; j++) { if (piece1[i][j] != piece2[i][j]) { return false; // 값이 다르면 일치하지 않음 } } } return true; } // 테이블에서 가져온 조각이 게임 보드의 빈 공간과 일치하는지 확인 public static boolean doesPieceMatch(int[][] boardPiece, int[][] tablePiece) { // 0도, 90도, 180도, 270도 회전해서 비교 for (int i = 0; i &lt; 4; i++) { if (areSamePiece(boardPiece, tablePiece)) { return true; // 조각이 일치하면 true 반환 } tablePiece = rotate(tablePiece); // 90도 회전 } return false; } // 조각의 칸 개수를 세는 함수 public static int countCells(int[][] piece) { int count = 0; for (int[] row : piece) { for (int cell : row) { if (cell == 1) { count++; } } } return count; } } . ",
    "url": "/docs/codingtest/1day1coding/241022/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#풀이-코드"
  },"349": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241022/",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/"
  },"350": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 괄호 회전하기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/76502?language=java\" . ",
    "url": "/docs/codingtest/1day1coding/241202/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/#문제"
  },"351": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 코드는 문자열 s의 모든 회전된 문자열에 대해, 해당 문자열이 올바른 괄호 문자열인지 확인하는 방식으로 문제를 해결합니다. | . | 주어진 문자열을 한 글자씩 회전시켜 총 n개의 문자열을 생성합니다. | 각 회전된 문자열이 올바른 괄호 문자열인지 확인합니다. | 올바른 괄호 문자열인지 확인하는 함수(isCorrected)는 스택을 사용하여 여는 괄호와 닫는 괄호가 올바르게 매칭되는지 판단합니다. | . | 올바른 괄호 문자열의 개수를 계산하여 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(s): answer = 0 sb = StringBuilder(s) . for i from 0 to length(s) - 1: if isCorrected(sb.toString()): answer += 1 . // 문자열 회전 append first character of sb to the end delete first character of sb . return answer . | . function isCorrected(s): stack = empty stack . for each character in s: if stack is empty: push character to stack else if top of stack matches character: pop stack else: push character to stack return true if stack is empty, otherwise false . function isMatched(a, b): return true if (a, b) is one of (“[”, “]”), (“{“, “}”), (“(“, “)”) . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(String s) { int answer = 0; StringBuilder sb = new StringBuilder(s); for (int i = 0; i &lt; s.length(); i++) { // n-1번 검사 if (isCorrected(sb.toString())) { answer++; } // 회전 sb.append(sb.substring(0, 1)); sb.delete(0, 1); } return answer; } public static boolean isCorrected(String s) { boolean check = false; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String t : s.split(\"\")) { if (stack.isEmpty()) { stack.push(t); } else if (isMatched(stack.peek(), t)) { stack.pop(); } else { stack.push(t); } } if (stack.isEmpty()) { check = true; } else { check = false; } return check; } public static boolean isMatched(String a, String b) { boolean check = false; if (a.equals(\"[\") &amp;&amp; b.equals(\"]\")) { check = true; } else if (a.equals(\"(\") &amp;&amp; b.equals(\")\")) { check = true; } else if (a.equals(\"{\") &amp;&amp; b.equals(\"}\")) { check = true; } else { check = false; } return check; } } . ",
    "url": "/docs/codingtest/1day1coding/241202/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/#문제-풀이"
  },"352": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "프로그래머스 Lv.2 - 괄호 회전하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241202/",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/"
  },"353": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 다단계 칫솔 판매\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/77486\" . ",
    "url": "/docs/codingtest/1day1coding/241204/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/#문제"
  },"354": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "문제 풀이",
    "content": "문제 접근 . | 데이터 준비: | . | enroll: 멤버 이름을 기준으로 인덱스를 매핑합니다. | referral: 각 멤버의 추천인을 ref_index 배열로 변환합니다. 추천인이 없으면 -1로 설정합니다. | seller: 판매자의 인덱스를 sel_index 배열로 변환합니다. | 수익 분배 계산: | . | 각 판매자가 발생시킨 판매 금액(amount)에 대해, 총 수익을 계산하고 이를 추천 구조를 따라 분배합니다. | 수익의 10%를 추천인에게 전달하며, 남은 금액은 현재 판매자의 수익으로 기록됩니다. | 이 과정을 추천 체계의 끝까지 반복하거나, 분배할 금액이 1 미만일 때 종료합니다. | 결과 반환: | . | 최종적으로 각 판매자의 수익을 answer 배열에 저장하여 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(enroll, referral, seller, amount): answer = array of zeros with size of enroll ref_index = map referral to index of enroll (or -1 if no referral) sel_index = map seller to index of enroll . | . for i from 0 to length of seller - 1: index = sel_index[i] // current seller’s index money = amount[i] * 100 // total revenue from sales . while index is not -1: reward = floor(money * 0.1) // 10% of revenue if ref_index[index] is -1: // no referral add (money - reward) to answer[index] else if reward &lt; 1: // if reward is too small add money to answer[index] break else: add (money - reward) to answer[index] index = ref_index[index] // move to next referral money = reward // pass reward upwards . return answer . | . --- ## 풀이 코드 ```java [Type/Paste Your Code](&lt;import java.util.*; class Solution { public int[] solution(String[] enroll, String[] referral, String[] seller, int[] amount) { int[] answer = new int[enroll.length]; int[] ref_index = new int[referral.length]; int[] sel_index = new int[seller.length]; ArrayList%3CString%3E en_str = new ArrayList&lt;&gt;(Arrays.asList(enroll)); // init for (int i = 0; i &lt; enroll.length; i++) { answer[i] = 0; ref_index[i] = en_str.indexOf(referral[i]); // ref에 해당되는 인덱스 저장, \"-\"는 -1 } for (int i = 0; i &lt; seller.length; i++) { sel_index[i] = en_str.indexOf(seller[i]); } // calculation for (int i = 0; i &lt; seller.length; i++) { int index = sel_index[i]; // seller의 인덱스 int money = amount[i] * 100; // seller의 판매 수입 while (index != -1) { int reward = (int)(money * 0.1); if (ref_index[index] == -1) { answer[index] += money - reward; } else if (reward &lt; 1) { answer[index] += money; } else { answer[index] += money - reward; } index = ref_index[index]; money = reward; } } return answer; } }&gt;) . ",
    "url": "/docs/codingtest/1day1coding/241204/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/#문제-풀이"
  },"355": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241204/",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/"
  },"356": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "문제",
    "content": ". | 링크 title: \"프로그래머스\" image: \"https://school.programmers.co.kr/assets/img-meta-programmers-411e94bf29153dc31004168e6cd500279b1a531a23689303755e51971dee4526.png\" description: \"SW개발자를 위한 평가, 교육, 채용까지 Total Solution을 제공하는 개발자 성장을 위한 베이스캠프\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/131130\" . ",
    "url": "/docs/codingtest/1day1coding/241209/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/#문제"
  },"357": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 코드는 주어진 카드 배열에서 상자에 들어 있는 카드들이 순서대로 연결된 순환 구조를 따라가며, 두 개의 가장 큰 상자 크기를 찾아 그 값을 곱한 결과를 반환하는 문제를 해결합니다. 접근 방법의 핵심은 다음과 같습니다: . | . | 카드 배열의 수정: . | 카드 배열의 값은 1-based 인덱스(1부터 시작)로 되어 있으므로, 이를 0-based 인덱스(0부터 시작)로 변환하여 처리합니다. | . | 순환 구조 탐색: . | 각 카드 번호를 따라가며, 순환하는 상자들을 방문합니다. 이미 방문한 상자는 다시 방문하지 않도록 visited 배열을 사용합니다. | 각 순환의 길이를 계산하여 boxes 리스트에 저장합니다. | . | 가장 큰 상자 크기 계산: . | boxes 리스트에서 상자의 크기를 내림차순으로 정렬한 후, 가장 큰 두 상자의 크기를 곱합니다. | . | 결과 반환: . | 가장 큰 두 상자의 크기를 곱한 값을 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(cards): answer = 0 visited = array of false with size of cards boxes = empty list . | . for i from 0 to length(cards) - 1: cards[i] = cards[i] - 1 // convert to 0-based index . for i from 0 to length(cards) - 1: if visited[i] is false: count = 0 index = i while visited[index] is false: visited[index] = true index = cards[index] // move to the next card in the cycle count += 1 add count to boxes . sort boxes in descending order . answer = boxes[0] * boxes[1] // multiply the two largest box sizes . return answer . | . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(int[] cards) { int answer = 0; boolean[] visited = new boolean[cards.length]; ArrayList&lt;Integer&gt; boxes = new ArrayList&lt;&gt;(); // 박스에 1번 상자만 존재하면 에러가 나기 때문에, 0을 하나 삽입 boxes.add(0); for (int i = 0; i&lt; cards.length; i++) { cards[i] = cards[i] - 1; } for (int i = 0; i &lt; cards.length; i++) { int count = 0; int index = i; while (!visited[index]) { visited[index] = true; index = cards[index]; count++; } boxes.add(count); } Collections.sort(boxes, Collections.reverseOrder()); answer = boxes.get(0) * boxes.get(1); System.out.println(boxes); return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241209/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/#문제-풀이"
  },"358": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241209/",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/"
  },"359": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "자료형",
    "content": "1. 명시적 형변환 . #include &lt;iostream&gt; using namespace std; int main() { int i = 65; double d = 5.2; // 명시적 형변환 cout &lt;&lt; static_cast&lt;int&gt;(d) &lt;&lt; endl; // 5 return 0; } . ",
    "url": "/docs/cpp/CodingTestCpp/#%EC%9E%90%EB%A3%8C%ED%98%95",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#자료형"
  },"360": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "문자열",
    "content": "1. 문자열 찾기 . #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { // 문자열 초기화 string str = \"Hello, World!\"; // find int num = str.find(\"o\"); cout &lt;&lt; num &lt;&lt; endl; // 출력: 4 return 0; } . 2. 문자열 수정 . #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string str = \"Appl\"; str += \"e\"; // Apple // 문자열 수정 str[0] = 'B'; // Bpple str.replace(2, 2, \"lol\"); // Blolle return 0; } . ",
    "url": "/docs/cpp/CodingTestCpp/#%EB%AC%B8%EC%9E%90%EC%97%B4",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#문자열"
  },"361": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "STL",
    "content": "STL이란 . Standard Template Library . C++에서 제공하는 템플릿 기반의 표준 라이브러리 -&gt; 템플릿이란, C++에서 함수나 클래스를 구현할 때 어떤 타입에서도 동작할 수 있도록 하는 문법 . STL은 크게 3가지로 이루어진다. | 데이터를 담는 컨테이너 | 데이터를 처리하고 제어하는 알고리즘 | 컨테이너에 접근 및 순회할 수 있게 하는 반복자 | . Call by reference . | void modify(int&amp; value) | 주소: &amp;value | . #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; int main() { // vector vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; for (int num : vec) { cout &lt;&lt; num &lt;&lt; \" \"; } cout &lt;&lt; endl; // 1, 2, 3, 4, 5 // map map&lt;string, int&gt; fruitMap = {{\"apple\", 1}, {\"banana\", 2}, {\"cherry\", 3}}; for (const audo&amp; pair : fruitMap) { cout &lt;&lt; pair.first &lt;&lt; \"=\" &lt;&lt; pair.second &lt;&lt; \" \"; } cout &lt;&lt; endl; // apple=1 banana=2 cherry=3 return 0; } . 위와 같이 타입과 상관없이 유동적인 함수를 기용할 수 있다. 반복자 . 반복자는 C++에서 컨테이너(벡터, 맵, 셋 등) 종류와 관계없이 원소들을 순회하고 접근할 수 있게 해준다. | 순방향 반복자 | . #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec = {10, 20, 30, 40, 50}; // 순회 및 출력 (포인터 문법 사용) for (auto it = vec.begin(); it != vec.end(); ++it) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; // 출력: 10 20 30 40 50 } . ",
    "url": "/docs/cpp/CodingTestCpp/#stl",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#stl"
  },"362": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "코딩테스트 C++ 개인 요약",
    "content": "자바 문법과 많이 다른 부분 위주로 작성하였습니다. ",
    "url": "/docs/cpp/CodingTestCpp/",
    
    "relUrl": "/docs/cpp/CodingTestCpp/"
  },"363": {
    "doc": "Dashboard 진행상황 1",
    "title": "Dashboard 진행상황 1",
    "content": " ",
    "url": "/docs/projects/devzip/Dashboard1/",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/"
  },"364": {
    "doc": "Dashboard 진행상황 1",
    "title": "2024.12.11 (WED)",
    "content": ". ",
    "url": "/docs/projects/devzip/Dashboard1/#20241211-wed",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/#20241211-wed"
  },"365": {
    "doc": "Dashboard 진행상황 1",
    "title": "Dashboard",
    "content": ". | Devzip 서버의 대시보드를 구현 중이다. | 현재의 진행상황은 아래와 같다. | . ",
    "url": "/docs/projects/devzip/Dashboard1/#dashboard",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/#dashboard"
  },"366": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "DevZip 디자인",
    "content": " ",
    "url": "/docs/projects/devzip/Design/#devzip-%EB%94%94%EC%9E%90%EC%9D%B8",
    
    "relUrl": "/docs/projects/devzip/Design/#devzip-디자인"
  },"367": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.03 (TUE)",
    "content": ". [!info] 이 프로젝트는 개인 프로젝트 등을 담는 웹사이트를 제작합니다. ",
    "url": "/docs/projects/devzip/Design/#20240703-tue",
    
    "relUrl": "/docs/projects/devzip/Design/#20240703-tue"
  },"368": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.01",
    "content": " ",
    "url": "/docs/projects/devzip/Design/#20240701",
    
    "relUrl": "/docs/projects/devzip/Design/#20240701"
  },"369": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "AWS 계정 생성",
    "content": "AWS를 활용한 서버를 구축하여, 해당 서버에 프로젝트를 이식시킨다. | 프리티어 계정 생성 완료 | EC2 생성 완료 | . 기본적인 세팅은 끝났으며, 구체적인 프로젝트의 디자인을 우선 진행한다. ",
    "url": "/docs/projects/devzip/Design/#aws-%EA%B3%84%EC%A0%95-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/devzip/Design/#aws-계정-생성"
  },"370": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "프로젝트 디자인",
    "content": "전반적인 최종 목표들은 제3자가 보았을 때, . | 프로젝트가 눈에 잘 보이며 | 어떤 기능 등이 핵심인지 잘 보여야 하며 | 버튼 등을 누르면 사이트 또는 기능에 접근할 수 있어야한다. (프로젝트를 시도하기 위한 tmp 프로젝트를 간단히 만들어 테스트 해본다.) | . ",
    "url": "/docs/projects/devzip/Design/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8",
    
    "relUrl": "/docs/projects/devzip/Design/#프로젝트-디자인"
  },"371": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.03",
    "content": "SpringBoot + React 개발환경 세팅 . | Springboot 프로젝트 생성 및 실행테스트 - Done | 리액트 설치 cd src/main npx create-react-app frontend # npx create-reeact {프로젝트명} . | 아래 링크 따라 진행 (Springboot, React 연동) | . title: “Spring Boot + React.js 개발환경 연동하기” . Spring Boot와 React.js를 연동해 개발환경을 만들고, 빌드해서 jar 파일로까지 만들어보는 과정입니다. 자세한 내용은 아래 링크를 클릭하세요: . Spring Boot + React.js 개발환경 연동하기 . ",
    "url": "/docs/projects/devzip/Design/#20240703",
    
    "relUrl": "/docs/projects/devzip/Design/#20240703"
  },"372": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.06 (토)",
    "content": "메인 페이지 연결 . | React-router 서드파티 라이브러리를 이용 | . ",
    "url": "/docs/projects/devzip/Design/#20240706-%ED%86%A0",
    
    "relUrl": "/docs/projects/devzip/Design/#20240706-토"
  },"373": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.08 (월)",
    "content": "목표.. | 메인페이지 틀만 완성 | 데이터베이스에 웹페이지 제목, 사이트 링크, 이미지(?) 넣으면 자동으로 불러와 리스트 만들게 | . | 풀페이지를 활용하여 메인 페이지 만들기 . | 현재까지 완성한 부분 | . | . | 이제 할 것 . | 박스 사이 간격 | 화면 축소 시, 박스 및 전체 콘텐츠 크기 줄이기? | . | . ",
    "url": "/docs/projects/devzip/Design/#20240708-%EC%9B%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240708-월"
  },"374": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.09 (화)",
    "content": "오늘 . | 박스 사이 간격 ✅ 2024-07-09 | 화면 축소 시, 박스 및 전체 콘텐츠 크기 줄이기 ✅ 2024-07-09 | Footer 추가 | 날짜 추가 | 비활성화 시각효과 수정 | 마우스 오버레이 수정 | . ",
    "url": "/docs/projects/devzip/Design/#20240709-%ED%99%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240709-화"
  },"375": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.10 (수)",
    "content": "새로운 목표? . | 처음 프로젝트로 게시판 프로젝트 . | 그런데, 게시판 + @ 느낌으로 | 전송한 ip의 앞부분을 잘라 표시? | . | 그 전에, AWS에 심어볼까 . | AWS으로 프로젝트 Clone 완료 | npm install 후, npm start 테스트 - 완료 | 스프링 부트 빌드 중 -&gt; 시간 오래 걸림 | . | . ",
    "url": "/docs/projects/devzip/Design/#20240710-%EC%88%98",
    
    "relUrl": "/docs/projects/devzip/Design/#20240710-수"
  },"376": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.11 (목)",
    "content": "오늘은? . | AWS에서 스프링 부트 빌드 확인 및 8080 접속 확인 . | 확인 완료 | . | 게시판 만들기 | . ",
    "url": "/docs/projects/devzip/Design/#20240711-%EB%AA%A9",
    
    "relUrl": "/docs/projects/devzip/Design/#20240711-목"
  },"377": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.12 (금)",
    "content": "게시판 제작 . | 페이지 Guestbook.js 생성 | 페이지 디자인 완료 . | 프록시서버를 활성화 해야, 클라이언트의 IP를 가져올 수 있음 . | 도메인 구매: https://my.freenom.com/clientarea.php?action=domaindetails . | devzip.site | . | 로드밸런서 문제 해결 . | 대상 그룹을 8080포트를 오픈 | . | devzip.site에 접속 가능!!! | . 프록시 서버 설정 확인 . 프록시 서버에서 X-Forwarded-For 헤더를 올바르게 전달하고 있는지 확인해야 합니다. 특히 AWS Elastic Load Balancer (ELB)를 사용할 경우, 다음과 같은 설정을 확인합니다: . | Load Balancer 설정: AWS 콘솔에서 사용 중인 ELB의 설정을 확인합니다. 다음과 같은 단계를 따라 확인할 수 있습니다: . | AWS Management Console에 로그인합니다. | EC2 대시보드로 이동하고, “Load Balancers”를 클릭합니다. | 사용 중인 ELB를 선택하고, “Listeners” 탭을 클릭합니다. | 사용하는 프로토콜(일반적으로 HTTP 또는 HTTPS)에 따라서 “Add”를 클릭하여 X-Forwarded-For을 선택하고 “Update”를 클릭하여 적용합니다. | . | . -&gt; or . title: \"Fetching\" image: \"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLW1pY3Jvc29mdCIgd2lkdGg9IjgwcHgiICBoZWlnaHQ9IjgwcHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCkiPjxjaXJjbGUgY3g9IjgxLjczNDEzMzYxMTY0OTQxIiBjeT0iNzQuMzUwNDU3MTYwMzQ4ODIiIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0MC4wMDEgNDkuOTk5OSA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49IjBzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9Ijc0LjM1MDQ1NzE2MDM0ODgyIiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0OC4zNTIgNTAuMDAwMSA1MC4wMDAxKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMDYyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iNjUuMzA3MzM3Mjk0NjAzNiIgY3k9Ijg2Ljk1NTE4MTMwMDQ1MTQ3IiBmaWxsPSIjZjhiMjZhIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTQuMjM2IDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMTI1cyI+PC9hbmltYXRlVHJhbnNmb3JtPgo8L2NpcmNsZT48Y2lyY2xlIGN4PSI1NS4yMjEwNDc2ODg4MDIwNyIgY3k9Ijg5LjY1Nzc5NDQ1NDk1MjQxIiBmaWxsPSIjYWJiZDgxIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTcuOTU4IDUwLjAwMDIgNTAuMDAwMikiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjE4NzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjQ0Ljc3ODk1MjMxMTE5NzkzIiBjeT0iODkuNjU3Nzk0NDU0OTUyNDEiIGZpbGw9IiM4NDliODciIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM1OS43NiA1MC4wMDY0IDUwLjAwNjQpIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4yNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMzQuNjkyNjYyNzA1Mzk2NDE1IiBjeT0iODYuOTU1MTgxMzAwNDUxNDciIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDAuMTgzNTUyIDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMzEyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMjUuNjQ5NTQyODM5NjUxMTc2IiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDEuODY0NTcgNTAgNTApIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4zNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjE4LjI2NTg2NjM4ODM1MDYiIGN5PSI3NC4zNTA0NTcxNjAzNDg4NCIgZmlsbD0iI2Y4YjI2YSIgcj0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoNS40NTEyNiA1MCA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjQzNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PC9zdmc+\" description: \"Fetching https://repost.aws/ko/knowledge-center/elb-capture-client-ip-addresses\" url: \"https://repost.aws/ko/knowledge-center/elb-capture-client-ip-addresses\" . Guestbook.js . 구글 검색 후, 처음부터 다시 개발 . ",
    "url": "/docs/projects/devzip/Design/#20240712-%EA%B8%88",
    
    "relUrl": "/docs/projects/devzip/Design/#20240712-금"
  },"378": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.15 (월)",
    "content": ". | RDS를 활용해 게시물 저장 | RDS-EC2 연결 title: \"Fetching\" image: \"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLW1pY3Jvc29mdCIgd2lkdGg9IjgwcHgiICBoZWlnaHQ9IjgwcHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCkiPjxjaXJjbGUgY3g9IjgxLjczNDEzMzYxMTY0OTQxIiBjeT0iNzQuMzUwNDU3MTYwMzQ4ODIiIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0MC4wMDEgNDkuOTk5OSA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49IjBzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9Ijc0LjM1MDQ1NzE2MDM0ODgyIiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0OC4zNTIgNTAuMDAwMSA1MC4wMDAxKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMDYyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iNjUuMzA3MzM3Mjk0NjAzNiIgY3k9Ijg2Ljk1NTE4MTMwMDQ1MTQ3IiBmaWxsPSIjZjhiMjZhIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTQuMjM2IDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMTI1cyI+PC9hbmltYXRlVHJhbnNmb3JtPgo8L2NpcmNsZT48Y2lyY2xlIGN4PSI1NS4yMjEwNDc2ODg4MDIwNyIgY3k9Ijg5LjY1Nzc5NDQ1NDk1MjQxIiBmaWxsPSIjYWJiZDgxIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTcuOTU4IDUwLjAwMDIgNTAuMDAwMikiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjE4NzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjQ0Ljc3ODk1MjMxMTE5NzkzIiBjeT0iODkuNjU3Nzk0NDU0OTUyNDEiIGZpbGw9IiM4NDliODciIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM1OS43NiA1MC4wMDY0IDUwLjAwNjQpIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4yNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMzQuNjkyNjYyNzA1Mzk2NDE1IiBjeT0iODYuOTU1MTgxMzAwNDUxNDciIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDAuMTgzNTUyIDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMzEyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMjUuNjQ5NTQyODM5NjUxMTc2IiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDEuODY0NTcgNTAgNTApIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4zNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjE4LjI2NTg2NjM4ODM1MDYiIGN5PSI3NC4zNTA0NTcxNjAzNDg4NCIgZmlsbD0iI2Y4YjI2YSIgcj0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoNS40NTEyNiA1MCA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjQzNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PC9zdmc+\" description: \"Fetching https://a3magic3pocket.github.io/posts/aws-rds-allow-ec2/\" url: \"https://a3magic3pocket.github.io/posts/aws-rds-allow-ec2/\" . | . ",
    "url": "/docs/projects/devzip/Design/#20240715-%EC%9B%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240715-월"
  },"379": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "~~ 2024.07.22",
    "content": "지금까지 했던 것들 . | Guestbook 1차 개발 완료 | 로그라이크류 웹게임 개발 준비 | 구글 서치 콘솔 등록 | . ",
    "url": "/docs/projects/devzip/Design/#-20240722",
    
    "relUrl": "/docs/projects/devzip/Design/#-20240722"
  },"380": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "DevZip 디자인 및 메인 설계",
    "content": " ",
    "url": "/docs/projects/devzip/Design/",
    
    "relUrl": "/docs/projects/devzip/Design/"
  },"381": {
    "doc": "SpringBoot",
    "title": "Springboot",
    "content": " ",
    "url": "/docs/java/SpringBoot/SpringBoot/#springboot",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/#springboot"
  },"382": {
    "doc": "SpringBoot",
    "title": "This Page has been written since July 22, 2024.",
    "content": ". ",
    "url": "/docs/java/SpringBoot/SpringBoot/#this-page-has-been-written-since-july-22-2024",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/#this-page-has-been-written-since-july-22-2024"
  },"383": {
    "doc": "SpringBoot",
    "title": "SpringBoot",
    "content": " ",
    "url": "/docs/java/SpringBoot/SpringBoot/",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/"
  },"384": {
    "doc": "DevZip - The Map",
    "title": "DevZip - The Map",
    "content": " ",
    "url": "/docs/projects/devzip/TheMap/",
    
    "relUrl": "/docs/projects/devzip/TheMap/"
  },"385": {
    "doc": "DevZip - The Map",
    "title": "2024.08.12 (MON)",
    "content": ". [!info] 이 프로젝트는 개인 프로젝트 등을 담는 웹사이트를 제작합니다. ",
    "url": "/docs/projects/devzip/TheMap/#20240812-mon",
    
    "relUrl": "/docs/projects/devzip/TheMap/#20240812-mon"
  },"386": {
    "doc": "DevZip - The Map",
    "title": "현 개발 상황",
    "content": ". ",
    "url": "/docs/projects/devzip/TheMap/#%ED%98%84-%EA%B0%9C%EB%B0%9C-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/projects/devzip/TheMap/#현-개발-상황"
  },"387": {
    "doc": "AWS (DVA)",
    "title": "AWS 자격증 - AWS Certified Developer Associate (DVA)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_DVA/#aws-%EC%9E%90%EA%B2%A9%EC%A6%9D---aws-certified-developer-associate-dva",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/#aws-자격증---aws-certified-developer-associate-dva"
  },"388": {
    "doc": "AWS (DVA)",
    "title": "This Page has been written since August 19, 2023.",
    "content": "다음 사이트의 자료를 참고하였습니다. AWS Certified Developer Associate 시험 합격을 위한 모든 것! 덤프 . ",
    "url": "/docs/studies/aws_DA/aws_DVA/#this-page-has-been-written-since-august-19-2023",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/#this-page-has-been-written-since-august-19-2023"
  },"389": {
    "doc": "AWS (DVA)",
    "title": "AWS (DVA)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_DVA/",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/"
  },"390": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "AWS Certified Developer Associate - Dump 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#aws-certified-developer-associate---dump-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#aws-certified-developer-associate---dump-1"
  },"391": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "2024.03.27 (WED)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#20240327-wed",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#20240327-wed"
  },"392": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #1",
    "content": "문제 . 한 회사가 Amazon EC2 인스턴스에 애플리케이션을 구현하고 있습니다. 애플리케이션은 들어오는 트랜잭션을 처리해야 합니다. 애플리케이션이 유효하지 않은 거래를 감지하면 애플리케이션은 회사 지원팀에 채팅 메시지를 보내야 합니다. 메시지를 보내려면 애플리케이션이 채팅 API를 사용하여 인증할 액세스 토큰을 검색해야 합니다. 개발자는 액세스 토큰을 저장하는 솔루션을 구현해야 합니다. 액세스 토큰은 저장 및 전송 중에 암호화되어야 합니다. 액세스 토큰은 다른 AWS 계정에서도 액세스할 수 있어야 합니다. 최소한의 관리 오버헤드로 이러한 요구 사항을 충족하는 솔루션은 무엇입니까? . A. AWS Key Management Service(AWS KMS) AWS 관리형 키를 사용하는 AWS Systems Manager Parameter Store SecureString 매개변수를 사용하여 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 매개변수에 리소스 기반 정책을 추가하세요. Parameter Store에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. 암호 해독 플래그가 활성화된 상태로 Parameter Store에서 토큰을 검색합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. B. AWS Key Management Service(AWS KMS) 고객 관리형 키를 사용하여 액세스 토큰을 암호화합니다. Amazon DynamoDB 테이블에 액세스 토큰을 저장합니다. DynamoDB 및 AWS KMS에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. DynamoD에서 토큰 검색EC2 인스턴스에서 AWS KMS를 사용하여 토큰을 해독합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. C. AWS Key Management Service(AWS KMS) 고객 관리형 키와 함께 AWS Secrets Manager를 사용하여 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 보안 비밀에 리소스 기반 정책을 추가하세요. Secrets Manager에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. Secrets Manager에서 토큰을 검색합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. D. AWS Key Management Service(AWS KMS) AWS 관리형 키를 사용하여 액세스 토큰을 암호화합니다. Amazon S3 버킷에 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 S3 버킷에 버킷 정책을 추가하세요. Amazon S3 및 AWS KMS에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. S3 버킷에서 토큰을 검색합니다. EC2 인스턴스에서 AWS KMS를 사용하여 토큰을 해독합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. 내용 정리 . | AWS KMS(암호화 암호 서명): 데이터를 암호화 할때 사용되는 암호화 Key를 안전하게 관리하는데 목적을 둔 서비스 . | AWS Secrets Manager: 다른 AWS 서비스와 통합되어 암호의 사용을 안전하게 저장 . | . 정답 . 정답: D -&gt; 그런데 커뮤니티 투표 분배는 C가 84%다.. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-1"
  },"393": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #2",
    "content": "내용 체크 . | Amazon SQS: 서버들끼리 사용할 수 있는 메세지 큐를 제공하는 서비스 | 시스템이 처리해야 할 To-Do List | . 정답 (O) . D. 모든 계정에서 이벤트를 수신하도록 기본 계정 이벤트 버스에 대한 권한을 구성합니다. 각 계정에서 Amazon EventBridge 규칙을 생성하여 모든 EC2 인스턴스 수명 주기 이벤트를 기본 계정 이벤트 버스로 보냅니다. 모든 EC2 인스턴스 수명 주기 이벤트와 일치하는 기본 계정 이벤트 버스에 EventBridge 규칙을 추가합니다. SQS 대기열을 규칙의 대상으로 설정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-2",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-2"
  },"394": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #3",
    "content": "내용 체크 . | Amazon Cognito: 웹 및 모바일 앱에 대한 인증과 권한 부여 그리고 사용자 관리를 제공하고 기존의 아이디, 패스워드 방식 이외에도 Facebook, Google 등의 여러 글로벌 회사의 소셜 로그인 기능을 제공하는 서비스. | Cognito는 사용자 풀(user pool)과 자격 증명 풀(identity pool)로 구성되어 있다. | 사용자 풀: 사용자의 가입과 로그인을 제공하는 사용자 저장소 | 자격 증명 풀: 사용자 풀에 저장된 정보를 바탕으로 AWS 인프라의 여러 서비스에 대한 권한을 부여할 수 있는 서비스 | . | . | Amazon S3: 업계 최고의 확장성, 데이터 가용성 및 보안과 성능을 제공하는 객체 스토리지 서비스 | . 정답 (O) . D. Amazon Cognito 자격 증명 접두사 내의 IAM 정책을 사용하여 사용자가 Amazon S3에서 자신의 폴더를 사용하도록 제한합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-3",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-3"
  },"395": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #4",
    "content": "내용 체크 . | AWS Batch: 대규모 데이터 처리를 위한 서비스 . | 작업 대기 열, 컴퓨팅 환경, 작업 정의 등으로 구성 | 작업 정의에서는 컨테이너화된 애플리케이션과 매개 변수를 정의할 수 있다. | . | AWS Step Function: 여러 컴퓨팅 자원들의 수행 순서를 설정할 수 있는 서비스 . | 각 단계가 이전 단계의 출력으로 입력되는 단계로 구성된 워크 플로어를 설계하고 실행할 수 있도록 함으로써, 작업을 보다 쉽게 조정할 수 있게 하는 완전 관리형 서비스 | . | AWS Glue: 완전 관리형 ETL(추출, 변환 및 로드) 서비스 . | 간단하게 여러 데이터 스토어 및 스트림 간에 원하는 데이터를 분류, 정리, 보강, 이동 | 서버리스(관리할 인프라 X) | . | . 정답 (O) . B. AWS 단계 함수 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-4"
  },"396": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #5",
    "content": "내용 체크 . | Amazon DynamoDB . | NoSQL 데이터베이스 | 매우 빠른 쿼리속도 | . | . 정답 (O) . C. Lambda 함수에는 DynamoDB에 쓸 수 있는 IAM 권한이 없습니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-5"
  },"397": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #6",
    "content": "내용 체크 . | AWS CloudFormation: AWS의 대표적인 IaC 기반의 구성 조정 도구 . | 이를 사용하면 VPC, EC2, Lambda 등과 같은 리소스를 수동으로 생성할 필요 없이 리소스들을 템플릿(코드)으로 구성하고 Stack을 생성하여 인프라를 구성할 수 있다. | 인프라 관리 간소화 | 신속하게 인프라 복제 | . | . 정답 (O) . D. CloudFormation 템플릿에서 EC2 인스턴스 유형 목록을 AllowedValues로 사용하여 매개변수를 생성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-6",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-6"
  },"398": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #7",
    "content": "내용 체크 . | BatchGetItem: 아이템을 군집하여 읽는 메서드 | 지수 백오프(Exponential Backoff): 이는 클라이언트가 AWS 서비스에 대해 요청을 보냈을 때, 서비스로부터 응답이 없거나 일시적인 오류가 발생했을 경우, 클라이언트가 다시 시도하기 전에 대기하는 시간을 조정하는 기술입니다. 이 기술은 초기에는 대기 시간을 짧게 시작하고, 매번 실패할 때마다 대기 시간을 지수적으로 늘려가며 요청을 다시 시도합니다. 이는 네트워크 혼잡이나 임시적인 서비스 문제로 인한 부하를 완화하고, 서비스의 가용성과 성능을 향상시킵니다. | 무작위 지연(Randomized Delay): 이는 지수 백오프의 일종으로, 모든 클라이언트가 동시에 다시 시도하는 것을 방지하기 위해 일정 범위 내에서 무작위로 대기 시간을 설정하는 것입니다. 이를 통해 네트워크 트래픽의 집중을 완화하고, 서버 측의 부하를 분산시키는 효과를 얻을 수 있습니다. | . 정답 (X, 오답: (B,C)) . B. 지수 백오프 및 무작위 지연을 사용하여 일괄 작업을 다시 시도합니다. D. 작업이 액세스하는 DynamoDB 테이블의 프로비저닝된 읽기 용량을 늘립니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-7",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-7"
  },"399": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Questoin #8",
    "content": "내용 체크 . | Amazon API Gateway: 개발자가 API를 손쉽게 생성, 게시, 유지관리, 모니터링 및 보안 유지할 수 있는 서비스 | AWS X-Ray: 개발자를 위한 일종의 애플리케이션 분석 및 디버깅 서비스 . | 애플리케이션의 구성(분산 마이크로서비스 등 복잡한 형태)을 시각화한 맵으로 표현해주는 서비스 | . | . 정답 (X, 오답: (C)) . B. 온프레미스 서버에 X-Ray 데몬을 설치하고 실행하여 데이터를 캡처하고 X-Ray 서비스에 전달합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#questoin-8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#questoin-8"
  },"400": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #9",
    "content": "정답 (X, 오답: (D)) . A. AWS Secrets Manager에 API 자격 증명을 저장합니다. AWS SDK를 사용하여 런타임 시 API 자격 증명을 검색합니다. 자격 증명을 사용하여 API 호출을 수행합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-9"
  },"401": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #10",
    "content": "내용 체크 . | Amazon Elastic Container Service(Amazon ECS): 확장성이 뛰어나고 빠른 컨테이너 관리 서비스 . | 컨테이너를 쉽게 실행, 중지하는 등의 관리가 가능하다. | 정답 (O) . A. AWS Systems Manager Parameter Store에서 변수를 검색하도록 애플리케이션을 업데이트하십시오. 각 환경의 각 변수에 대해 Parameter Store의 고유한 경로를 사용하십시오. 각 환경의 AWS Secrets Manager에 자격 증명을 저장합니다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-10",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-10"
  },"402": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #11",
    "content": "내용 체크 . | Amazon Elastic File System(Amazon EFS): 완전관리형 파일 스토리지 서비스 . | 여러 EC2 인스턴스 간에 파일을 공유하고, 파일 시스템의 용량을 자동으로 확장하는 등의 기능을 제공 | . | . 정답 (O) . B. Amazon S3에 저장된 사진의 객체 키와 함께 각 직원의 연락처 정보를 Amazon DynamoDB 테이블에 저장합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-11",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-11"
  },"403": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #12",
    "content": "정답 (O) . B. Amazon Cognito 사용자 풀을 사용하여 사용자 계정을 관리합니다. API에 대한 액세스를 제어하려면 API Gateway에서 Amazon Cognito 사용자 풀 권한 부여자를 생성합니다. Lambda 함수를 사용하여 Amazon S3에 사진을 저장합니다. DynamoDB 테이블에 사진 세부 정보의 일부로 객체의 S3 키를 저장합니다. DynamoDB에 S3 키를 쿼리하여 이전에 업로드한 사진을 검색합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-12",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-12"
  },"404": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #13",
    "content": "내용 체크 . | Amazon SNS: 구독 중인 서비스나 사용자에게 메시지 전달 및 전송을 해주는 서비스 | . 정답 (O) . C. Amazon Simple 알림 서비스(Amazon SNS) 주제를 생성합니다. 특정 속성이 포함된 메시지를 SNS 주제에 게시하도록 Lambda 함수를 구성합니다. 각 파트너의 SNS 주제를 구독하세요. 주제 구독에 적절한 필터 정책을 적용합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-13",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-13"
  },"405": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #14",
    "content": "정답 (X, 오답: (D)) . C. S3 콘솔에서 S3 객체 Lambda 액세스 포인트를 생성합니다. RemovePii 기능을 선택합니다. PII 없이 객체에 액세스하려면 S3 액세스 포인트를 사용하십시오. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-14",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-14"
  },"406": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #15",
    "content": "내용 체크 . | AWS OpsWorks: Chef를 사용하여 모든 형태 및 규모의 애플리케이션을 구성하고 운영하도록 도와주는 구성 관리 서비스 | AWS CodePipeline: 완전관리형 지속적 전달 서비스 . | 소프트웨어를 릴리스하는데 필요한 단계를 모델링, 시각화 및 자동화할 수 있게 도와준다. | . | . 정답 (X, 오답: (D)) . B. 다른 버전의 함수 별칭을 사용하십시오. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-15",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-15"
  },"407": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #16",
    "content": "정답 (X, 오답: (A)) . B. 함수의 메모리를 늘립니다. (CPU 사용률 =&gt; 메모리 증가) . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-16",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-16"
  },"408": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #17",
    "content": "내용 체크 . | AWS Code Deploy: 애플리케이션을 구성하는 파일 군(아티팩트)의 디플로이를 자동화하는 AWS의 관리 서비스 . | 디플로이: 소프트웨어 개발 과정에서 컴파일 코드를 실행 가능한 상태로 만들고, 사용자가 접근 가능한 환경에 배치하는 과정을 의미 | . | . 정답 (X, 오답: ()) . B. ApplicationStop -&gt; BeforeInstall -&gt; AfterInstall -&gt; ApplicationStart . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-17",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-17"
  },"409": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #18",
    "content": "내용 체크 . | Amazon CloudWatch: AWS 리소스와 AWS에서 실시간을 실행 중인 애플리케이션을 모니터링하는 서비스 | . 정답 (O) . B. 외부 결제 처리 API 호출의 실패를 기록하는 사용자 지정 지표를 CloudWatch에 게시합니다. 오류율이 지정된 비율을 초과하면 기존 SNS 주제에 알리도록 CloudWatch 경보를 구성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-18",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-18"
  },"410": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #19",
    "content": "내용 체크 . | API 캐싱: API 실행을 담당하는 프로세스 또는 쓰레드의 실행 없이, 이전의 동일한 요청(Request)의 응답을 그대로 활용하여 클라이언트에게 즉시 응답하는 방법 | 인터페이스 VPC 엔드포인트: Amazon Virtual Private Cloud(VPC)내에서 리소스를 안전하게 액세스할 수 었는 개인적인 연결을 제공 | CORS(교차 원본 리소스 공유): 특정 도메인에서 실행되는 웹 애플리케이션이 다른 도메인의 자원에 액세스할 수 있도록 하는 HTTP 기능 | . 정답 (O) . A. API 게이트웨이에서 API 캐싱을 활성화합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-19",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-19"
  },"411": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #20",
    "content": "내용 체크 . | Amazon RDS: 클라우드에서 관계형 데이터베이스를 간편하게 설정, 운영 및 확장 가능 | . 정답 (O) . A. Amazon DynamoDB 테이블을 생성합니다. 제목을 파티션 키로, 출시 연도를 정렬 키로 구성하는 기본 키를 사용하여 테이블을 구성합니다. 장르를 파티션 키로, 제목을 정렬 키로 사용하는 글로벌 보조 인덱스를 생성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-20",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-20"
  },"412": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "AWS (DVA) - Dump 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/"
  },"413": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "AWS Certified Developer Associate - Dump 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#aws-certified-developer-associate---dump-2",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#aws-certified-developer-associate---dump-2"
  },"414": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "2024.03.27 (WED)",
    "content": ". 21 ~ 40 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#20240327-wed",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#20240327-wed"
  },"415": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #21",
    "content": "정답 (O) . A. API Gateway API에서 개발 단계를 정의합니다. 다른 개발자에게 엔드포인트가 개발 단계를 가리키도록 지시합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-21",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-21"
  },"416": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #22",
    "content": "정답 (X, 오답: (C)) . A. Redis 인스턴스용 Amazon ElastiCache를 생성합니다. 전송 중인 데이터와 저장 중인 데이터의 암호화를 활성화합니다. 자주 액세스하는 데이터를 캐시에 저장합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-22",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-22"
  },"417": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #23",
    "content": "내용 체크 . | AWS SDK: AWS를 프로그래밍적으로 유기적으로 다루기 위한 개발 도구 | . 정답 (O) . C. 리포지토리를 호스팅할 Amazon S3 버킷을 생성합니다. 기존 .xml 파일을 S3 버킷으로 마이그레이션합니다. AWS SDK를 사용하여 Amazon S3에서 구성 파일을 읽고 쓰도록 애플리케이션 코드를 업데이트합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-23",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-23"
  },"418": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #24",
    "content": "내용 체크 . | AWS Amplify: 사용자 인증, 실시간 데이터, AI/ML, 파일 스토리지 등 백엔드 사용사례를 지원하도록 하는 도구 및 기능 세트 | AWS Elastic Beanstalk: Java, .NET, PHP 등을 사용하여 Apache, Nginx, IIS와 같은 친숙한 서버에서 개발된 웹 애플리케이션 및 서비스를 간편하게 배포하고 조정할 수 있는 서비스 . | 코드를 업로드해서 용량 프로비저닝, 로드 밸런싱, 오토 스케일링, 애플리케이션 상태 모니터링, 배포를 자동으로 처리하도록 구성 | . | EB CLI: 로컬 리포지토리에서 환경 생성, 업데이트 및 모니터링을 단순화하는 대화형 명령을 제공하는 AWS Elastic Beanstalk용 명령줄 인터페이스 | . 정답 (X, 오답: (B)) . A. 서버리스 백엔드와 함께 AWS Amplify를 사용하여 각 웹사이트를 호스팅합니다. 원하는 각 환경에 해당하는 저장소 분기를 연결했습니다. 코드 변경 사항을 원하는 브랜치에 병합하여 배포를 시작하세요. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-24",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-24"
  },"419": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #25",
    "content": "정답 (X, 오답: (B)) . C. 하나 이상의 읽기 전용 복제본을 사용하여 Amazon RDS를 배포합니다. 쿼리가 읽기 전용 복제본의 URL을 사용하도록 애플리케이션 코드를 수정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-25",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-25"
  },"420": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #26",
    "content": "정답 (O) . B. Amazon DynamoDB 테이블을 생성합니다. 각 요청의 고유 식별자를 테이블에 저장합니다. 요청을 처리하기 전에 테이블에서 식별자를 확인하도록 Lambda 함수를 수정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-26",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-26"
  },"421": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #27",
    "content": "내용 체크 . | ASW ACM: AWS 웹사이트와 애플리케이션을 보호하는 퍼블릭 및 프라이빗 SSL/TCS X.509 인증서와 키를 만들고, 저장하고, 갱신하는 복잡성을 처리 | . 정답 (X, 오답: (B)) . A. 새 AMI를 생성하고 암호화 매개변수를 지정합니다. 암호화된 AMI를 대상 리전에 복사합니다. 암호화되지 않은 AMI를 삭제합니다. 암호화되지 않은 AMI에서는 암호화를 활성화할 수 없습니다. AMI 복사본을 암호화하려면 소스 AMI를 먼저 암호화해야 합니다. 소스가 암호화되지 않으면 AMI 복사본을 암호화할 수 없습니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-27",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-27"
  },"422": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #28",
    "content": "내용 체크 . | Amazon CloudFront: AWS에서 제공하는 CDN(Content Delivery Network) . | CDN: 콘텐츠 전송 네트워크, 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하는 시스템 | . | . 정답 (O) . C. 중앙 S3 버킷에 대한 액세스를 허용하는 CORS(교차 원본 리소스 공유) 구성을 생성합니다. 중앙 S3 버킷에 CORS 구성을 추가합니다. 자주 발생하는 문제입니다. 웹 애플리케이션은 일부 예외를 제외하고 기본적으로 다른 도메인의 리소스에 액세스할 수 없습니다. 액세스할 리소스에 CORS를 구성해야 합니다. -&gt; CORS: Cross-Origin Resource Sharing의 약자로, 출처가 다른 자원들을 공유한다는 뜻으로, 한 출처에 있는 자원에서 다른 출처에 있는 자원에 접근하도록 하는 개념 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-28",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-28"
  },"423": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Qustion #29",
    "content": "내용 체크 . | Amazon Kinesis: 실시간으로 데이터 스트림을 수집, 처리, 분석해주는 서비스 (샤드 조절을 통해) . | 위 서비스는 완전 관리형이라, 인프라 관리를 하지 않아도 됨 | . | 클릭스트림 데이터: 소비자 행동을 파악하는 데 사용할 수 있는 웹 트래픽 등 | PutRecords API | Amazon SNS: 구독중인 Service 또는 사용자(Client)에 메시지 전달, 전송을 조정 및 관리하는 웹서비스 (알림서비스) | . 정답 (X, 오답: (B)) . A. 지수 백오프로 재시도를 구현합니다. C. 요청 빈도 및/또는 크기를 줄입니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#qustion-29",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#qustion-29"
  },"424": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #30",
    "content": "정답 (O) . B. Amazon Simple Email Service(Amazon SES)를 사용하여 이메일 알림을 보내는 AWS Lambda 함수를 생성합니다. 함수에 대한 Amazon Cognito 사후 인증 Lambda 트리거를 추가합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-30",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-30"
  },"425": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #31",
    "content": "정답 (X, 오답: (A)) . B. PutObject API 작업을 호출할 때 x-amz-server-side-encryption 헤더를 설정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-31",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-31"
  },"426": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "AWS (DVA) - Dump 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/"
  },"427": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS Certified Developer Associate - Section 4 (IAM)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#aws-certified-developer-associate---section-4-iam",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#aws-certified-developer-associate---section-4-iam"
  },"428": {
    "doc": "AWS (DVA) - Section 4",
    "title": "2023.09.14 (THU)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#20230914-thu",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#20230914-thu"
  },"429": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS Identity &amp; Access Management (AWS IAM)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#aws-identity--access-management-aws-iam",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#aws-identity--access-management-aws-iam"
  },"430": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM: Users &amp; Groups",
    "content": ". | IAM에서는 사용자를 생성하고 그룹에 배치하기 때문에, 글로벌 서비스이다. | 루트 어카운트는 기본으로 만들어진다. 이후, 루트는 사용되거나 공유되면 안된다. | 사용자와 그룹을 만들어 사용한다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-users--groups",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-users--groups"
  },"431": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM: 권한",
    "content": ". | 사용자 또는 그룹에게 정책, 또는 IAM 정책이라고 불리는 JSON문서를 지정할 수 있다. | AWS는 필요 이상의 권한을 사용자에게 주지 않는다. | 그룹에게 권한을 부여하는 정책이 있으며, 개인에게는 개인에게만 적용되는 인라인 정책이라는 것을 생성할 수 있다. | IAM 정책 구조 . | 그룹과 사용자들의 정보 보호 . | 비밀번호 정책 . | ex) 길이 제한, 특수문자 등 | . | (중요) 다요소 인증 - MFA . | AWS에서 필수적으로 사용하도록 권장 | 적어도 root를, 최대한 IAM 사용자를 지켜야 함 | 따라서 비밀번호 외, MFA를 이용하는 것이다. | ex) Alice has Password + MFA Token =&gt; 로그인 성공! . | AWS에서 MFA 장치 옵션 (중요) . | 가상 MFA 장치 : 모바일이나 기타 장비로 가능 (Like 모바일 OTP) | U2F 보안 키 (물리) | 하드웨어 키 팝 MFA (물리) | . | . | . | 유저가 AWS에 접근하는 방법 . | AWS Management Console (protected by password + MFA) | AWS Command Line Interface (CLI): protected by access keys | AWS Software Developer Kit (SDK) - for code: protected by access keys . | 다들 각자의 키를 생성하기 때문에, 개인 키는 공유하면 안된다 | . | Access Key ID ~= username | Secret Access Key ~= password | . | . | AWS CLI . | AWS 서비스와 상호 작용할 수 있는 오픈소스 도구 | AWS CLI를 사용하면 Pwershell이나 터미널에서도 AWS에서 제공하는 명령어 기능을 실행할 수 있다. -&gt; 실습 해봄 | CLI 권한은 IAM 권한과 같다. | AWS CloudShell에서도 접속할 수 있다. | . | AWS SDK . | 소프트웨어 개발 키트 | 코딩을 통해 애플리케이션 내에 심어두는 것 | . | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-%EA%B6%8C%ED%95%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-권한"
  },"432": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM Roles",
    "content": "이는 사용자와 유사하지만, 실제 사용자가 사용하는 것이 아니라 AWS 서비스가 사용하는 것을 말한다. ex) EC2 인스턴스가 AWS에서 작업을 수행할 수 있도록, EC2에게 권한을 부여하는 것이다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-roles",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-roles"
  },"433": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM Security Tools",
    "content": ". | IAM 자격 증명 보고서 (계정 레벨) . | 계정에 있는 사용자와 다양한 자격 증명의 상태를 포함 | . | IAM 액세스 관리자 (유저 레벨) . | 사용자의 권한을 관리 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-security-tools",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-security-tools"
  },"434": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM 요약",
    "content": ". | Users: mapped to a physical user, has a password for AWS Console | Groups: contains users only | Policies: JSON document that outlines permissions for users or groups | Roles: for EC2 instances or AWS services | Security: MFA + Password Policy | AWS CLI: manage your AWS services using the command-line | AWS SDK: manage your AWS services using a programming language | Access Keys: access AWS using the CLI or SDK | Audit: IAM Credential Reports &amp; IAM Access Advisor | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-요약"
  },"435": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS (DVA) - Section 4",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/"
  },"436": {
    "doc": "AWS (DVA) - Section 5",
    "title": "AWS Certified Developer Associate - Section 5 (EC2 기초)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#aws-certified-developer-associate---section-5-ec2-%EA%B8%B0%EC%B4%88",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#aws-certified-developer-associate---section-5-ec2-기초"
  },"437": {
    "doc": "AWS (DVA) - Section 5",
    "title": "2023.09.19 (TUE) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#20230919-tue-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#20230919-tue-"
  },"438": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스"
  },"439": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2란?",
    "content": "Elastic Compute Cloud = Infrasturcture as a Service . EC2의 작동방식을 알아야, 클라우드 작동 방식을 이해할 수 있다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2란"
  },"440": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스 가상 서버에 사용 가능한 옵션",
    "content": ". | Operating System (OS): Linux, Windows or Mac OS | CPU, RAM 선택 가능 | 스토리지 공간 선택 가능 . | 네트워크를 통해 연결되는 스토리지 (EBS, EFS) | 하드워드를 통해 연결되는 스토리지 (EC2 Instance Store) | . | EC2 인스턴스에 연결할 네트워크 유형도 선택 가능 . | 네트워크 카드 속도 | 사용할 공개 IP | . | 방화벽 규칙: 보안 그룹 | Bootstrap script: EC2 User Data | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EA%B0%80%EC%83%81-%EC%84%9C%EB%B2%84%EC%97%90-%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스-가상-서버에-사용-가능한-옵션"
  },"441": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 User Data",
    "content": "이를 사용해 인스턴스를 Bootstrap 할 수 있다. Bootstrapping: 머신이 시작할 때, 명령을 실행하는 것 . | 이 스크립트는 오직 인스턴스 시작 시 한번만 실행된다. | 작업 . | 업데이트 설치 | 소프트웨어 설치 | 인터넷 파일 다운로드 | 등등 | . | 루트 사용자로 실행된다. (psuedo) . | 예시 . | 해당 빈 칸에, 전달하고 싶은 명령어를 넣으면 된다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-user-data",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-user-data"
  },"442": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 생성 실습",
    "content": "기존 사용하던 계정 말고, 다른 새 계정을 만들어 프리티어로 실습을 진행한다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%83%9D%EC%84%B1-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-생성-실습"
  },"443": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스 유형",
    "content": "예시로 'm5.2xlarge' 라는 유형의 인스턴스를 예로 들어본다. | m: 인스턴스 클래스 | 5: 인스턴스 세대 . | AWS가 하드웨어를 계속 개선해서 새로운 세대의 하드웨어를 출시하면 m5 -&gt; m6가 되는 것. | . | 2xlarge: 인스턴스 크기 (클수록 인스턴스에 더 많은 메모리와 CPU를 가지게 됨) | . | 범용 목적 . | 범용의 인스턴스는 웹 서버나 코드 저장소와 같은 다양한 작업에 적합 | 컴퓨팅, 메모리, 네트워킹 간의 균형도 잘맞는다. | . | 컴퓨팅 최적화 인스턴스 . | 컴퓨터 집약적인 작업에 최적화된 인스턴스 | 머신러닝, 전용 게임 서버, 고성능 웹서버 | 컴퓨터 최적화의 모든 인스턴스는 C로 시작하는 이름을 가짐 (C5, C5 등) | . | 메모리 최적화 인스턴스 . | 메모리에서 대규모 데이터셋을 처리하는 유형의 작업에 적합 | R로 시작함 (RAM) | . | 스토리지 최적화 인스턴스 . | 로컬 스토리지에서 대규모의 데이터셋에 액세스할 때 적합 | I, G, H1 등 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스-유형"
  },"444": {
    "doc": "AWS (DVA) - Section 5",
    "title": "보안 그룹",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#보안-그룹"
  },"445": {
    "doc": "AWS (DVA) - Section 5",
    "title": "보안 그룹이란?",
    "content": "AWS 클라우드에서 네트워크 보안을 실현하는 데 기본적인 기능 (보안 그룹 = 방화벽) . 보안 그룹을 이용해 EC2 인스턴스의 인바운드 및 아웃바운드 트래픽을 제어 기본적으로 허용 규칙만 사용 . | 인바운드 트래픽: 외부에서 EC2 인스턴스로 들어오는 트래픽을 허용되는지 지정 | 아웃바운드 트래픽: 내부에서 인터넷으로 통신할 수 있는지 지정 . | 보안 그룹은 여러 인스턴스에 연결할 수 있다. (다대다 관계) | SSH 전용의 별도의 보안 그룹을 관리하는 것이 좋다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#보안-그룹이란"
  },"446": {
    "doc": "AWS (DVA) - Section 5",
    "title": "특정 보안 그룹을 다른 보안 그룹에서 참조",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%ED%8A%B9%EC%A0%95-%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%9D%84-%EB%8B%A4%EB%A5%B8-%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%97%90%EC%84%9C-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#특정-보안-그룹을-다른-보안-그룹에서-참조"
  },"447": {
    "doc": "AWS (DVA) - Section 5",
    "title": "포트에 대해 알아야 할 것들",
    "content": ". | 22 = SSH - EC2 인스턴스에 로그인할 때 사용 | 21 = FTP - 파일 전송 프로토콜 용 | 80 = HTTP - 보안이 적용되지 않은 웹사이트에 액세스 | 443 = HTTPS - 보안이 적용된 웹사이트 | 3389 = RDP - 원격 데스크톱 프로토콜 (윈도우 인스턴스 로그인 용) | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%ED%8F%AC%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B2%83%EB%93%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#포트에-대해-알아야-할-것들"
  },"448": {
    "doc": "AWS (DVA) - Section 5",
    "title": "SSH 접속 실습",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ssh-%EC%A0%91%EC%86%8D-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ssh-접속-실습"
  },"449": {
    "doc": "AWS (DVA) - Section 5",
    "title": "AWS (DVA) - Section 5",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/"
  },"450": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AWS Certified Developer Associate - Section 6 (EC2 인스턴스 스토리지 / EBS)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#aws-certified-developer-associate---section-6-ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80--ebs",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#aws-certified-developer-associate---section-6-ec2-인스턴스-스토리지--ebs"
  },"451": {
    "doc": "AWS (DVA) - Section 6",
    "title": "2023.09.25 (MON) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#20230925-mon-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#20230925-mon-"
  },"452": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EC2 인스턴스 스토리지",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ec2-인스턴스-스토리지"
  },"453": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨",
    "content": "Elastic Block Store Volume . | 인스턴스가 실행 중인 동안 연결 가능한 네트워크 드라이브 | 인스턴스 종류된 후에도 데이터를 지속할 수 있다. | EBS 볼륨을 생성할 때는 특정 가용 영역에서만 가능하다. | 스냅샷을 이용하면 다른 가용 영역으로 볼륨 옮기기 가능 | . | . EBS 볼륨 = 네트워크 USB 스틱 . | 네트워크 드라이브로 EC2 인스턴스에서 분리될 수 있다. | 볼륨이기에 용량을 미리 결정해야 한다. | 인스턴스에 연결할 수 있어, 필요한 경우에만 연결한다. | . EC2 인스턴스를 통해 EBS 볼륨을 생성하는 경우, 종료 시 삭제 속성 - 기본 설정은 체크가 해제되어 있음 (인스턴스 root는 체크가 되어있음) . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨"
  },"454": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨 실습",
    "content": ". | EBS 볼륨은 특정 가용 영역의 인스턴스에만 부착할 수 있다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨-실습"
  },"455": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 스냅샷",
    "content": ". | EBS 볼륨의 특정 시점에서의 백업 | 스탭샷을 다른 가용 영역 및 다른 리전에 복사할 수 있다. | . 스냅샷의 기능 . | 스냅샷 아카이브 . | 스냅샷을 최대 75% 더 저렴한 아카이브 디어로 옮기는 기능 | . | EBS 스냅샷을 위한 휴지통을 만들기 . | 스냅샷을 영구적으로 삭제하는 대신, 휴지통에 보관 | 실수로 삭제한 경우 복구 가능 (보관 기간 : 하루에서 1년 설정 가능) | . | 스냅샷 완전 초기화 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EC%8A%A4%EB%83%85%EC%83%B7",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-스냅샷"
  },"456": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AMI",
    "content": "Amazon Machine Image = 사용자 지정 EC2 인스턴스 . AMI를 생성하면 부팅과 구성에 시간이 단축된다. EC2 인스턴스의 AMI 처리 . | 인스턴스를 시작하고, 이를 사용자 지정으로 바꾼다. | 인스턴스를 중지시켜, 데이터 무결성을 확보한다. | 다른 AMI에서 인스턴스를 실행할 수 있게 된다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ami",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ami"
  },"457": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EC2 Instance Store",
    "content": "EC2 인스턴스는 가상 머신이지만, 실제로는 하드웨어 서버에 연결되어 있고 물리적으로 연결된 디스크 공간을 갖는다. 따라서, 특정 유형의 EC2 인스턴스는 EC2 인스턴스 스토어라고 블린다. 이 EC2 인스턴스 스토어는 I/O 성능 향상을 위해 활용할 수 있다. EC2 인스턴스 스토어 = 임시 스토리지 장기 스토리지 경우, EBS가 적합 . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ec2-instance-store",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ec2-instance-store"
  },"458": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨 유형",
    "content": "EBS 볼륨에는 6가지 타입이 있다. | gp2 / gp3 (SSD) : 범용 SSD 볼륨 | io1 / io2 (SSD) : 최고 성능 SSD 볼륨, 미션 크리티컬, 지연 시간 낮음, 대용량의 워크로드에 쓰인다. | st1 (HDD) : 저비용의 HDD 볼륨 | sc1 (HDD) : 가장 비용이 적게 드는 HDD 볼륨 | . 이 중, gp2/gp3, io1/io2만 부팅 볼륨으로 사용될 수 있다. EBS 볼륨 정의 방법 . 크기, 처리량, IOPS(초당 I/O 작업 수) . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨-유형"
  },"459": {
    "doc": "AWS (DVA) - Section 6",
    "title": "시험에선 범용 gp2와 IOPS 프로비저닝이 가장 중요한 내용",
    "content": "gp2/gp3 . 짧은 지연 시간을 자랑하며, 효율적인 비용의 스토리지 . | gp3에선 IOPS와 처리량을 독자적으로 설정할 수 있다. | gp2에선 그 둘이 연결되어 있다. | . IOPS 프로비저닝 . IOPS 성능을 유지할 필요가 있는 주요 비즈니스 애플리케이션이나, 16,000 IOPS 이상을 요구하는 애플리케이션에 적합 . | 일반적으로 데이터베이스 워크로드에 알맞다. | gp2/gp3에 -&gt; io1 또는 io2 볼륨으로 바꾸면 된다. | . io2는 io1과 동일한 비용에 내구성과 기가 당 IOPS의 수가 더 높다. -&gt; io2가 합리적 . st1, sc1 . | 부팅 볼륨 X | 빅데이터, 데이터 웨어하우징 로그 처리에 적합 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#%EC%8B%9C%ED%97%98%EC%97%90%EC%84%A0-%EB%B2%94%EC%9A%A9-gp2%EC%99%80-iops-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D%EC%9D%B4-%EA%B0%80%EC%9E%A5-%EC%A4%91%EC%9A%94%ED%95%9C-%EB%82%B4%EC%9A%A9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#시험에선-범용-gp2와-iops-프로비저닝이-가장-중요한-내용"
  },"460": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 다중 연결",
    "content": "다중 연결 기능을 사용하면 동일한 EBS 볼륨을 동일한 가용영역에 있는 여러 개의 EC2 인스턴스에 첨부할 수 있다. 시험에 나오는 내용 : 하나의 볼륨은 한번에 최대 16개의 EC2 인스턴스에 부착할 수 있다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%8B%A4%EC%A4%91-%EC%97%B0%EA%B2%B0",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-다중-연결"
  },"461": {
    "doc": "AWS (DVA) - Section 6",
    "title": "Amazon EFS (탄력적 파일 시스템)",
    "content": "EFS: 관리형 NFS(네트워크 파일 시스템) 네트워크 파일 시스템이기 때문에, 많은 EC2 인스턴스에 마운트 가능 (서로 다른 가용 영역도 가능) . 특징 . | 가용성이 높다. | 확장성이 높다. | 비용은 gp2 볼륨의 3배이다. | 사용량에 따라 비용을 지불!!!! | . | . 사용처 . | 콘텐츠 관리 | 웹 서비스 | 데이터 공유 | 워드 프레스 | . 호환 . 이 기능은 Window가 아닌 Linux 기반 AMI와만 호환된다. 성능 및 스토리지 클래스 . EFS 스케일에서는 수천 개의 동시 NFS 클라이언트와 10기가바이트 이상의 처리량이 가능하다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#amazon-efs-%ED%83%84%EB%A0%A5%EC%A0%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#amazon-efs-탄력적-파일-시스템"
  },"462": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AWS (DVA) - Section 6",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/"
  },"463": {
    "doc": "AWS (DVA) - Section 7",
    "title": "AWS Certified Developer Associate - Section 7 (AWS 기초: ELB + ASG)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#aws-certified-developer-associate---section-7-aws-%EA%B8%B0%EC%B4%88-elb--asg",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#aws-certified-developer-associate---section-7-aws-기초-elb--asg"
  },"464": {
    "doc": "AWS (DVA) - Section 7",
    "title": "2023.11.21 (TUE) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#20231121-tue-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#20231121-tue-"
  },"465": {
    "doc": "AWS (DVA) - Section 7",
    "title": "고가용성 및 확장성",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1-%EB%B0%8F-%ED%99%95%EC%9E%A5%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#고가용성-및-확장성"
  },"466": {
    "doc": "AWS (DVA) - Section 7",
    "title": "확장성",
    "content": "애플리케이션 시스템이 조정을 통해 더 많은 양을 처리할 수 있다는 의미 . | 수직 확장성 . | 인스턴스 크기 확장 | 하드웨어 제한이 있기 때문에, 한계가 있다. | . | 수평 확장성(탄력성) . | 인스턴스나 시스템의 수를 늘리는 방법 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%ED%99%95%EC%9E%A5%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#확장성"
  },"467": {
    "doc": "AWS (DVA) - Section 7",
    "title": "고가용성",
    "content": "애플리케이션 또는 시스템을 적어도 둘 이상의 AWS의 AZ나 데이터 센터에서 가동중인 것을 의미 . | 고가용성의 목표: 데이터 센터에서의 손실을 막기 위해 (센터 하나가 멈춰도 계속 작동이 가능하게끔) | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#고가용성"
  },"468": {
    "doc": "AWS (DVA) - Section 7",
    "title": "일래스틱 로드 밸런싱(ELB)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EC%9D%BC%EB%9E%98%EC%8A%A4%ED%8B%B1-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1elb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#일래스틱-로드-밸런싱elb"
  },"469": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서",
    "content": "서버 혹은 서버셋으로 트래픽을 백엔드나 다운스트림 EC2 인스턴스 또는 서버들로 전달하는 역할 = 관리형 로드 밸런서 . | 쉽게 말해, 중재하는 관리자? | 왜 필요한가? . | 부하를 다수의 다운스트림 인스턴스로 분산하기 위해 | 어떤 인스턴스로 트래픽을 보낼 수 없는지도 확인해준다. | 클라우드 내에서 개인 트래픽과 공공 트래픽을 분리할 수 있다. | . | AWS가 관리하며, 어떤 경우에도 작동할 것을 보장함. (고가용성을 책임) | 무조건 쓰는 편이 좋음. | 자체 관리보다 저렴함 | 로드밸런서는 다수의 AWS와 연동됨 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서"
  },"470": {
    "doc": "AWS (DVA) - Section 7",
    "title": "Health Checks",
    "content": "ELB가 EC2 인스턴스의 작동이 올바르게 되고 있는지의 여부를 확인하기 위해 사용된다. | 제대로 작동하지 않으면, 해당 인스턴스로 트래픽을 보낼 수 없기 때문에 Health Checks는 굉장히 중요하다. | Health Checks는 포트와 라우트에서 이뤄진다. | EC2에서 http 200 응답을 주지 않으면, unhealthy하다 판단하고 ELB는 그쪽으로 트래픽을 보내지 않는다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#health-checks",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#health-checks"
  },"471": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서의 Types",
    "content": ". | Classic Load Balancer (v1) - call CLB . | 지금은 권장하지 않음 | . | Application Load Balancer (v2) - call ALB | Network Load Balancer (v2) - call NLB | Gateway Load Balancer - call GWLB | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-types",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서의-types"
  },"472": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서의 보안그룹",
    "content": ". | EC2 인스턴스의 보안 그룹을 로드 밸런서의 보안 그룹으로 연결한다. | 그렇게 되면 EC2 인스턴스는 로드 밸런서에서 온 트래픽만을 허용하게 된다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-%EB%B3%B4%EC%95%88%EA%B7%B8%EB%A3%B9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서의-보안그룹"
  },"473": {
    "doc": "AWS (DVA) - Section 7",
    "title": "1. CLB",
    "content": "-&gt; 이제 사용하지 않아, 다루지 않는다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#1-clb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#1-clb"
  },"474": {
    "doc": "AWS (DVA) - Section 7",
    "title": "2. ALB",
    "content": "7계층 - HTTP 전용 로드밸런서 . | 동일 EC2 인스턴스 상의 여러 애플리케이션에 부하를 분산한다. | 컨테이너와 ECS를 사용함 | . | HTTP에서 HTTPS로 트래픽을 자동 리다이렉트를 하려는 경우, 로드 밸런서 레벨에서 가능하다. | 경로 라우팅도 지원 | 뭐리 문자열과 헤더에 기반한 라우팅도 가능 | ALB 하나만으로도 다수의 애플리케이션을 처리할 수 있다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#2-alb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#2-alb"
  },"475": {
    "doc": "AWS (DVA) - Section 7",
    "title": "3. NLB",
    "content": "4계층 - TCP/UDP 트래픽 처리 . | 고성능 (초당 수백만건 요청 처리) | 가용 영역 당 하나의 고정 IP만 있다. | 각 가용 영역에 탄력적 IP를 배정할 수 있다. | 이건 여러 고정 IP가 있는 애플리케이션을 노출해야 할 때 유용 | . | NLB의 대상 그룹이 하는 상태 확인은 TCP, HTTP, HTTPS 프로토콜을 지원한다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#3-nlb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#3-nlb"
  },"476": {
    "doc": "AWS (DVA) - Section 7",
    "title": "4. GWLB",
    "content": "배포 및 확장과 AWS의 타사 네트워크 가상 어플라이언스의 플릿 관리에 사용됨 . | 방화벽을 통과하게 하거나, 침입 탐지 및 방지 시스템에 사용된다. | 1). 라우팅 테이블이 수정되면, 모든 사용자 트래픽은 GWLB를 통과 | 2). GWLB는 가상 어플라이언스의 대상 그룹 전반으로 트래픽을 확한 | 3). 모든 트래픽은 어플라이언스에 도달하고 어플라이언스는 트래픽을 분석하고 처리 | 4). 이상이 없다면 다시 GWLB로 보내고, 이상이 있으면 트래픽을 드롭 | 5). 허용된 트래픽은 GWLB에서 애필리케이션으로 보내짐 | 기능 . | 1). 투명 네트워크 게이트웨이 | 2). 로드밸런서 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#4-gwlb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#4-gwlb"
  },"477": {
    "doc": "AWS (DVA) - Section 7",
    "title": "ELB의 고정 세션 or 세션 밀접성",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#elb%EC%9D%98-%EA%B3%A0%EC%A0%95-%EC%84%B8%EC%85%98-or-%EC%84%B8%EC%85%98-%EB%B0%80%EC%A0%91%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#elb의-고정-세션-or-세션-밀접성"
  },"478": {
    "doc": "AWS (DVA) - Section 7",
    "title": "AWS (DVA) - Section 7",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/"
  },"479": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/"
  },"480": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "2023.09.11 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#20230911-mon",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#20230911-mon"
  },"481": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "서버리스란?",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#서버리스란"
  },"482": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "패러다임의 전환",
    "content": ". | 물리적 머신 | Virtual machines (VM) . | ex) ec2 | 컴퓨터 및 장비 별로 버전 차이 등으로 종속성 문제가 발생하는 단점이 존재 | . | Containerization . | VM의 단점을 해소 | 필요에 따라 서버 증설 등의 여러가지 밑단의 내용들을 신경써야함 | . | Serverless . | AWS 차원에서 모든 리소스들을 추상화함. | 지속적인 스케일링 | 사용한 만큼만 과금 | 유지보수 ZERO | 때문에, 비즈니스 가치에 집중할 수 있다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84%EC%9D%98-%EC%A0%84%ED%99%98",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#패러다임의-전환"
  },"483": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "서버리스란?",
    "content": ". | 서버 관리 필요없음 | 사용한 만큼만 지불 | 요청에 맞게 스케일링 | 높은 보안 수준 | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%9E%80-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#서버리스란-1"
  },"484": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "다양한 범주의 서버리스 서비스",
    "content": ". 출처 : AWS . | 대표적으로 AWS Lambda | 네모 표시는 실습 때, 살펴볼 내용 | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B2%94%EC%A3%BC%EC%9D%98-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#다양한-범주의-서버리스-서비스"
  },"485": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda"
  },"486": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda",
    "content": ". | 불필요한 서버 관리 | 자동 확장 | 고가용성 및 보안 | 사용한 만큼만 지불 | . 출처 : AWS . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-1"
  },"487": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda 사용 사례",
    "content": ". | Web Apps . | 정적 웹사이트 | 복합적 웹앱 | . | Backends . | 앱 &amp; 서비스 | 모바일 | IoT | . | Data Processing . | Real time | MaoReduce | Batch | . | Chatbots . | Powering chatbot loginc | . | etc | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-사용-사례"
  },"488": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon API Gateway",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-api-gateway",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-api-gateway"
  },"489": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "API Gateway는 API 기반 아키텍처의 관문",
    "content": "API : 응용프로그램과 운영체제 간의 통신을 연결해주는 인터페이스 . API Gateway : 서비스가 많아지면, 버전 관리 및 관리가 매우 힘들어진다. 이를 해소시켜주는 것. (like 정문 역할) . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#api-gateway%EB%8A%94-api-%EA%B8%B0%EB%B0%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B4%80%EB%AC%B8",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#api-gateway는-api-기반-아키텍처의-관문"
  },"490": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon DynamoDB",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb"
  },"491": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon DynamoDB",
    "content": "대규모 성능에 최적화된 완전 관리형 NoSQL 데이터베이스 서비스 . | 서버리스 . | 유지관리 불필요 | 오토 스케일링 | 고가용성 및 내결함성 | . | 높은 성능 . | 초당 수백만의 요청 처리 및 짧은 지연시간 | 다른 AWS 서비스와 통합 | . | 보안 및 엑세스 . | 전송 중 및 저장 시 암호화 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb-1"
  },"492": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Core Concepts - Tables, Items, Attributes, Indexes",
    "content": ". 출처 : AWS . | Primary Key를 잘 설계하는 것이 중요. | Unique하게 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#core-concepts---tables-items-attributes-indexes",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#core-concepts---tables-items-attributes-indexes"
  },"493": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "데이터 베이스 확장",
    "content": ". | SQL . | 수직정 확장 | . | NoSQL . | 수평적 확장 : 다수의 샤드로 수평확장 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%99%95%EC%9E%A5",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#데이터-베이스-확장"
  },"494": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "실습",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#실습"
  },"495": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "실습 과정",
    "content": ". | Lambda 생성 | DynamoDB, API Gateway 생성 | . https://catalog.us-east-1.prod.workshops.aws/workshops/600420b7-5c4c-498f-9b80-bc7798963ba3/ko-KR/serverless . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%8B%A4%EC%8A%B5-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#실습-과정"
  },"496": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "자료형",
    "content": ". | 우선순위 큐 | . PriorityQueue&lt;Integer&gt; pQ = new PriorityQueue&lt;&gt;(); // 삽입 (큐랑 동일) pQ.add(1); // front 확인 및 제거 pQ.remove(); . | 해시맵 | . HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 1); map.put(\"banana\", 2); // 키값 변경 map.put(\"banana\", 4); // 키가 있는지 확인, 키값 가져오기 (get) String key = \"apple\"; if (map.containsKey(key)) { int value = map.get(key); System.out.println(key + \": \" + value); // apple: 1 } // 키값 삭제 map.remove(\"banana\"); . | 스택 | . Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); . | 큐 | . Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); . | 연결리스트 | . LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // add list.addFirst(1); // 앞에 추가 list.addLast(2); // 뒤에 추가 list.add(3); list.add(1, 10); // index 1에 값 \"10\"추가 // remove list.removeFirst(); list.removeLast(); list.remove(); // 생략시 index 0 제거 list.remove(2); // index 2 제거 list.clear(); // 기타 list.get(1); list.size(); list.contain(1); // 1 검색, boolean list.indexOf(1); // index 1에 있는 값 불러오기, 없으면 -1 . | 해시셋 | . HashSet&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); // 용량이 10인 HashSet 생성 (해시셋은 저장공간을 늘릴 때, 2배로 늘리기 때문에 크기를 알고 있다면 정해주는 것이 Best) HashSet&lt;Integer&gt; set2 = new HashSet&lt;&gt;(10); set.add(1); set.add(1); set.add(2); set.remove(1); // 값 1 제거 set.clear(); if (set.contains(1)) { System.out.println(\"It has 1.\"); } . ",
    "url": "/docs/java/codingTestSyntax/#%EC%9E%90%EB%A3%8C%ED%98%95",
    
    "relUrl": "/docs/java/codingTestSyntax/#자료형"
  },"497": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "문자열",
    "content": ". | 정렬 | . // 기본 정렬 (오름차순) Arrays.sort(arr); // 내림차순 정렬 Arrays.sort(arr, Collections.reverseOrder()); . | StringBuffer | . String str = \"abc\"; StringBuffer sb = new StringBuffer(str); // \"abc\"로 초기화 // reverse (거꾸로, toString) String reversedStr = sb.reverse().toString; . | String to Int | . String str = \"123\"; int a = Integer.parseInt(str); . | int to String int a = 123; String str1 = Integer.toString(a); String str2 = a + \"\"; . | . ",
    "url": "/docs/java/codingTestSyntax/#%EB%AC%B8%EC%9E%90%EC%97%B4",
    
    "relUrl": "/docs/java/codingTestSyntax/#문자열"
  },"498": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "코딩테스트 - Java 문법 정리",
    "content": " ",
    "url": "/docs/java/codingTestSyntax/",
    
    "relUrl": "/docs/java/codingTestSyntax/"
  },"499": {
    "doc": "CodingTest",
    "title": "코딩테스트",
    "content": " ",
    "url": "/docs/codingtest/codingtest/#%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/codingtest/codingtest/#코딩테스트"
  },"500": {
    "doc": "CodingTest",
    "title": "This Page has been written since August 08, 2023.",
    "content": " ",
    "url": "/docs/codingtest/codingtest/#this-page-has-been-written-since-august-08-2023",
    
    "relUrl": "/docs/codingtest/codingtest/#this-page-has-been-written-since-august-08-2023"
  },"501": {
    "doc": "CodingTest",
    "title": "CodingTest",
    "content": " ",
    "url": "/docs/codingtest/codingtest/",
    
    "relUrl": "/docs/codingtest/codingtest/"
  },"502": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/cpp/cpp/",
    
    "relUrl": "/docs/cpp/cpp/"
  },"503": {
    "doc": "C++",
    "title": "This Page has been written since December 12, 2024.",
    "content": " ",
    "url": "/docs/cpp/cpp/#this-page-has-been-written-since-december-12-2024",
    
    "relUrl": "/docs/cpp/cpp/#this-page-has-been-written-since-december-12-2024"
  },"504": {
    "doc": "db오류",
    "title": "오류",
    "content": "- [Server] Plugin mysql_native_password reported: ''mysql_native_password' is deprecated and will be removed in a future release. Please use caching_sha2_password instead'` . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%EC%98%A4%EB%A5%98",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#오류"
  },"505": {
    "doc": "db오류",
    "title": "원인 #1",
    "content": "원인은 MySQL 8.0이상 부터의 보안 정책과 관련되었다. SSL/TLS . SSL/TLS은 클라이언트와 서버 프로그램이 네트워크로 통신하는 과정에서 도청 및 간섭, 위변조 방지를 위해서 서로 신뢰할 수 있는 전자 서명이 포함된 인증서를 사용하는 암호화 통신 프로토콜 . [!info] Content . | 이 내용은 클라이언트(애플리케이션이나 PC 등)에서 MySQL을 SSL/TLS 방식으로 접속시에 TLS1.0 또는 1.1 버전으로 접속한다면 다음과 같은 에러가 발생되면서 접속이 불가능함을 의미 | . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%EC%9B%90%EC%9D%B8-1",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#원인-1"
  },"506": {
    "doc": "db오류",
    "title": "해결",
    "content": ". | 이와 다른 부분이였다. 다음날 다시 접속하니 해결,,? 되었다.. | . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#해결"
  },"507": {
    "doc": "db오류",
    "title": "db오류",
    "content": "[!question] 갑자기 잘되던 AWS RDS로의 접속이 안된다. ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/"
  },"508": {
    "doc": "사이드 프로젝트 - Deverse",
    "title": "Project - Deverse",
    "content": " ",
    "url": "/docs/projects/deverse/deverse/#project---deverse",
    
    "relUrl": "/docs/projects/deverse/deverse/#project---deverse"
  },"509": {
    "doc": "사이드 프로젝트 - Deverse",
    "title": "Project has been written since March 12, 2024.",
    "content": ". | Links | . ",
    "url": "/docs/projects/deverse/deverse/#project-has-been-written-since-march-12-2024",
    
    "relUrl": "/docs/projects/deverse/deverse/#project-has-been-written-since-march-12-2024"
  },"510": {
    "doc": "사이드 프로젝트 - Deverse",
    "title": "사이드 프로젝트 - Deverse",
    "content": " ",
    "url": "/docs/projects/deverse/deverse/",
    
    "relUrl": "/docs/projects/deverse/deverse/"
  },"511": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "Project - DeverZip",
    "content": " ",
    "url": "/docs/projects/devzip/devzip/#project---deverzip",
    
    "relUrl": "/docs/projects/devzip/devzip/#project---deverzip"
  },"512": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "Project has been written since July 3, 2024.",
    "content": ". DevZip은 제가 개발한 프로젝트들의 모음Zip입니다! . | Links | . ",
    "url": "/docs/projects/devzip/devzip/#project-has-been-written-since-july-3-2024",
    
    "relUrl": "/docs/projects/devzip/devzip/#project-has-been-written-since-july-3-2024"
  },"513": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "사이드 프로젝트 - DevZip",
    "content": " ",
    "url": "/docs/projects/devzip/devzip/",
    
    "relUrl": "/docs/projects/devzip/devzip/"
  },"514": {
    "doc": "entityManagerFactory 에러",
    "title": "entityManagerFactory 에러",
    "content": "[!question] 스프링부트 프로젝트에서 게시판을 만들고 있던 중, 게시판 작성 내용을 DB에 저장하는 컨트롤러를 만들던 중 오류가 발생하였다. 오류 . ```bash ********* APPLICATION FAILED TO START ************* . Description: . Parameter 0 of constructor in Service required a bean named ‘entityManagerFactory’ that could not be found. Action: . Consider defining a bean named ‘entityManagerFactory’ in your configuration.&gt;) . ### 초기 해결 방법 `EntityManagerFactory`를 수동으로 설정하는 방법을 채택 ```java @Configuration @EnableTransactionManagement public class JpaConfig { @Autowired private DataSource dataSource; @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() { LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean(); factory.setDataSource(dataSource); factory.setPackagesToScan(\"entity\"); factory.setJpaVendorAdapter(new HibernateJpaVendorAdapter()); return factory; } @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(entityManagerFactory); return transactionManager; } } . | 는 다른 곳이였다… (아래는 해결) | . # JPA 비활성화를 주석처리 ... # spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration . ",
    "url": "/docs/java/SpringBoot/entityManagerFactory_%EC%97%90%EB%9F%AC/",
    
    "relUrl": "/docs/java/SpringBoot/entityManagerFactory_%EC%97%90%EB%9F%AC/"
  },"515": {
    "doc": "Facade 패턴",
    "title": "Facade 패턴",
    "content": "[!NOTE] Facade 패턴 == 드라이브 스루 창구 . | Facade 패턴은 드라이브 스루 창구 처럼 이용자가 제품 제작과 포장 등 여러 기능들을 볼 수 없듯이, 여러 기능을 하나의 창구를 통해 간단하게 사용할 수 있도록 하는 패턴 | . ",
    "url": "/docs/java/facadePattern/",
    
    "relUrl": "/docs/java/facadePattern/"
  },"516": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "Project - 토이 프로젝트 - 게임 서버",
    "content": " ",
    "url": "/docs/projects/gameServer/gameServer/#project---%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/projects/gameServer/gameServer/#project---토이-프로젝트---게임-서버"
  },"517": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "Project has been written since Aug 19, 2023.",
    "content": ". ",
    "url": "/docs/projects/gameServer/gameServer/#project-has-been-written-since-aug-19-2023",
    
    "relUrl": "/docs/projects/gameServer/gameServer/#project-has-been-written-since-aug-19-2023"
  },"518": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "토이 프로젝트 - 게임 서버",
    "content": " ",
    "url": "/docs/projects/gameServer/gameServer/",
    
    "relUrl": "/docs/projects/gameServer/gameServer/"
  },"519": {
    "doc": "Hoooon22's Log",
    "title": "Hoooon22",
    "content": "Web &amp; Server Delveloper . ",
    "url": "/",
    
    "relUrl": "/"
  },"520": {
    "doc": "Hoooon22's Log",
    "title": "Profile",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"521": {
    "doc": "Hoooon22's Log",
    "title": "김지훈",
    "content": "웹 &amp; 서버 개발자 . 학력 . | 동국대학교 컴퓨터공학과 (2018.03 ~ 2023.02) | . 기타 . | 동국대학교 인간-로봇 상호작용 연구실 학부연구생 (2019.07 ~ 2021.04) | . 경력 . | 마준소프트 인턴 (2024.01 ~ 2024.02) | . ",
    "url": "/",
    
    "relUrl": "/"
  },"522": {
    "doc": "Hoooon22's Log",
    "title": "Tech Stack",
    "content": ". | Programming Languages: Java, C/C++ | Frameworks: SpringBoot, Node.js, React | Web Technologies: HTML5, CSS, Javascript, ASP | Databases: MySQL | Version Control: Git | PaaS/IaaS: AWS | Operating Systems:: Linux | Miscellaneous Tools/Platforms:: Unity | . ",
    "url": "/",
    
    "relUrl": "/"
  },"523": {
    "doc": "Hoooon22's Log",
    "title": "Projects",
    "content": "ㅤ1. '퐁당 매거진' 웹사이트 제작 프로젝트 . 이미지를 클릭하시면, 웹페이지로 이동합니다. | Period: 2022.07 ~ 2023.12 | Description: 청소년들에게 세상에 있는 다양한 직업들을 소개해주는 웹매거진 ‘매거진 퐁당’의 풀스택 개발을 맡았습니다. | 첫 번째 사이트: VanilaJS, Node.js | 두 번째 사이트(개발 진행중): React, SpringBoot | . | Tech Stack: AWS, HTML/CSS/Javascript, Node.js, React, SpringBoot, NGINX | . 퐁당 매거진 웹사이트 제작 과정 '퐁당 매거진 두번째 돌' 웹사이트의 제작 과정을 기록한 페이지 입니다. Pongdang_Server2 Github '퐁당 매거진 두번째 돌' 웹사이트의 깃허브 입니다. ㅤ2. Automated CCTV Video Processing System to Prevent Child Abuse in Daycare Centers . | Period: 2022.03.02 ~ 2022.12.16 (약 10개월 간) | Description: 아동학대 방지를 위해 어린이집 내 CCTV 영상을 효율적으로 반출하는 시스템을 개발하였습니다. 학대 의심 구간을 C3D모델로 탐지하고, YOLOv5와 StrongSORT 모델을 사용하여 프레임별로 얼굴 영역을 검출하며, 이에 해당하는 영역을 모자이크 처리하여 사용자에게 영상을 최종적으로 제공하는 시스템입니다. 이 중 학대 의심 구간을 탐지하는 Violence Detection module을 개발하는 역할을 맡았습니다. 또한 이에 매칭되는 부분의 논문 작성을 맡았고, 구현 후 테스트 총괄을 맡았습니다. 이후, 2022 한국정보기술학회 추계학술대회 대학생논문경진대회에서 은상을 수상하였습니다. | Tech Stack: 영상처리, Front-end, Back-end | Result: 학회 논문 게시, 웹사이트 기반 시스템 제작 | . Automated CCTV Video Processing System Github 프로젝트의 깃허브 입니다. ㅤ3. 동국대학교 전자불전문화콘텐츠연구소 아카이브 홈페이지 제작 프로젝트 . | Period: 2020.03 ~ 2020.08 (약 6개월) | Description: 동국대학교 전자불전문화콘텐츠연구소의 불교문화가 담긴 사진 등의 빅데이터들을 저장하고 열람할 수 있는 홈페이지를 제작하였습니다. | 웹 전체 페이지 개발, 빅데이터 관리, 정보 분류를 위한 검색 SQL문 작성, 서버 보조 관리 | . | Tech Stack: HTML/CSS/JS, Node.js, MySQL | Result: 빅데이터 관리, 웹 디자인 경험, Server &amp; Client 동시 구현 | . ㅤ4. 안전사고 예방과 과학 교육을 위한 VR실험실 개별연구 프로젝트 . | Period: 2022.03 ~ 2022.06 (약 4개월) | Description: CS VR 기기를 활용한 스마트 시스템 설계 – VR 실험실 개발 및 논문 작성 . | 실제 화학 실험에서의 위험사고와 경제적 손실을 최소화하는 방법으로, VR 상의 가상 실험 을 구현하여 해당 VR 실험실에서의 실험과 실제 실험의 실험을 서로 비교하고 관찰하여 각 방법의 효율성 과 유효성(학습효과 등)을 분석하였습니다. Unity와 C#, Blender를 사용하여 제작하였습니다. | . | Tech Stack: Unity, C#, Blender (그래픽 프로그램) | Result: Unity 활용능력, Blender 사용 경험, 논문 작성 | . ChemicalLab Github ChemicalLab 프로젝트의 깃허브 입니다. ㅤ5. 동국대학교 이공계를 위한 문제중심 C언어 프로그래밍 교안 제작 프로젝트 . | Period: 2019.10 ~ 2020.07 (약 10개월) | Description: 동국대학교의 이공계 학생들을 위한 문제풀이 중심의 C언어 프로그래밍 교안을 제작하였습니다. | 문제 Project 4개 중 1개 제작, Project1-주기율표 계산 프로그램 | . | Tech Stack: C언어 기초지식과 기초 프로그래밍 Skill | Result: 동국대학교 수업 사용 교안 제작, C언어 활용 Skill | . ㅤ6. 시각장애인을 위한 스마트 점자 패널 기초연구 . | Period: 2019.09.01 ~ 2019.11.02 (약 3개월 간) | Description: 시각장애인 의 스마트폰을 통한 정보접근성 향상을 위해‘스마트 점자 패널’을 설계하고 논문으로 발표하였습니다. 스마트폰으로 인한 시각장애인과 비장애인의 정보격차를 줄이기 위한 기술로, 스마트폰의 음성이 아닌 본 기술의 점자를 이용하여 스마트폰의 정보를 전달할 수 있게 설계하였습니다. | Tech Stack: 논문 주 저자, 아이디어 제시 및 논문 발표 | Result: 2019 한국지능시스템학회 추계학술대회 논문 게시 . 논문 원본입니다. | . ㅤ7. 스마트미러를 활용한 청각장애인 구화훈련 애플리케이션 제작 . | Period: 2020.09.01 ~ 2021.02.28 (약 6개월 간) | Description: 스마트미러를 활용한 청각장애인 구화훈련 애플리케이션을 제작하였습니다. | 아이디어 제시, 스마트미러 전용 애플리케이션 개발, 테스트 실험 | . | Tech Stack: Android Studio, STT(Speech to Text) 알고리즘 | Result: 동국대학교 2021 겨울캡스톤 디자인대회 밸류업 프로그램 장려상 수상, 애플리케이션 개발 능력 . 논문 원본입니다. | . ㅤ8. Chrome Extension 개발 프로젝트 . | Period: 2024.12.30 ~ (진행중) | Description: 생각나는 좋은 아이디어들을 담아 제작한 Chrome Extension을 개발한 프로젝트입니다. (1). Github_Summary . [ 2024.12.30 ~ (진행중) ] . | OpenAI API를 활용하여, 접속한 Github Repository 및 Code를 자동으로 요약해주는 Extension입니다. | . | . | Tech Stack: Vanila JS, Javascript, API | Result: Chrome Extension 웹스토어 등록 대기 중… | . if (code.isWorks()) { return Best_Moment; // :) } . ",
    "url": "/",
    
    "relUrl": "/"
  },"524": {
    "doc": "Hoooon22's Log",
    "title": "Hoooon22's Log",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"525": {
    "doc": "★ Java",
    "title": "Java",
    "content": " ",
    "url": "/docs/java/java/#java",
    
    "relUrl": "/docs/java/java/#java"
  },"526": {
    "doc": "★ Java",
    "title": "This Page has been written since July 22, 2024.",
    "content": " ",
    "url": "/docs/java/java/#this-page-has-been-written-since-july-22-2024",
    
    "relUrl": "/docs/java/java/#this-page-has-been-written-since-july-22-2024"
  },"527": {
    "doc": "★ Java",
    "title": "★ Java",
    "content": " ",
    "url": "/docs/java/java/",
    
    "relUrl": "/docs/java/java/"
  },"528": {
    "doc": "오브젝트",
    "title": "Obejct &amp; OOP",
    "content": " ",
    "url": "/docs/studies/object/object/#obejct--oop",
    
    "relUrl": "/docs/studies/object/object/#obejct--oop"
  },"529": {
    "doc": "오브젝트",
    "title": "This Page has been written since August 08, 2023.",
    "content": "참고 서적 : “오브젝트”, 조영호 . ",
    "url": "/docs/studies/object/object/#this-page-has-been-written-since-august-08-2023",
    
    "relUrl": "/docs/studies/object/object/#this-page-has-been-written-since-august-08-2023"
  },"530": {
    "doc": "오브젝트",
    "title": "오브젝트",
    "content": " ",
    "url": "/docs/studies/object/object/",
    
    "relUrl": "/docs/studies/object/object/"
  },"531": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "Project - 퐁당 웹 매거진 프로젝트 Ver.02",
    "content": " ",
    "url": "/docs/projects/pongdang/pongdang/#project---%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-ver02",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#project---퐁당-웹-매거진-프로젝트-ver02"
  },"532": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "Project has been written since July 1, 2023.",
    "content": ". | Links | . 퐁당 웹 매거진 프로젝트 Ver.01 제작 일지 . 퐁당 웹 매거진 프로젝트 Ver.01 Github(private) . 퐁당 웹 매거진 프로젝트 Ver.02 제작 일지 . 퐁당 웹 매거진 프로젝트 Ver.02 Github(public) . ",
    "url": "/docs/projects/pongdang/pongdang/#project-has-been-written-since-july-1-2023",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#project-has-been-written-since-july-1-2023"
  },"533": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "퐁당 웹 매거진 프로젝트",
    "content": " ",
    "url": "/docs/projects/pongdang/pongdang/",
    
    "relUrl": "/docs/projects/pongdang/pongdang/"
  },"534": {
    "doc": "Projects",
    "title": "Project",
    "content": "Project has been written since July 1, 2023. ",
    "url": "/docs/projects#project",
    
    "relUrl": "/docs/projects#project"
  },"535": {
    "doc": "Projects",
    "title": "Projects",
    "content": " ",
    "url": "/docs/projects",
    
    "relUrl": "/docs/projects"
  },"536": {
    "doc": "STUDY",
    "title": "공부",
    "content": "This Page has been written since July 17, 2023. ",
    "url": "/docs/studies#%EA%B3%B5%EB%B6%80",
    
    "relUrl": "/docs/studies#공부"
  },"537": {
    "doc": "STUDY",
    "title": "STUDY",
    "content": " ",
    "url": "/docs/studies",
    
    "relUrl": "/docs/studies"
  },"538": {
    "doc": "AWS 기초 - 1",
    "title": "AWS 기초 - 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_1/",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/"
  },"539": {
    "doc": "AWS 기초 - 1",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_1/#20230819-sat",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#20230819-sat"
  },"540": {
    "doc": "AWS 기초 - 1",
    "title": "1. 온프라미스와 AWS 용어 비교",
    "content": "AWS는 아마존에서 온프레미스를 클라우드 서비스로 만든 것이다. 온프라미스(On-premise)란, 기업의 서버를 클라우드 같은 원격 환경에서 운영하는 방식이 아닌, 자체적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식이다. – . 온프라미스 용어 = 클라우드 용어 . | 방화벽 = 보안그룹 | ACL = NACL . | ACL(Access Control List) : 허가되지 않은 이용자가 라우터나 네트워크의 특정 자원을 접근하려고 하는 것을 차단한다. | . | 관리자 권한 = IAM | L4, 로드 밸런서 = ELB(일라스틱 로드 밸런서), 탄력적인 로드 밸련서, ALB, … . | 로드 밸런서 : 서버에 가해지는 부사(=로드)를 분산(=밸런싱)해주는 장치 또는 기술 | . | 네트워크 = VPC . | VPC는 Virtual Private Cloud로, 정의한 논리적으로 격리된 가상 네트워크에서 AWS 리소스를 시작할 수 있다. | . | 서버 = EC2(일라스틱 컴퓨트 클라우드), C2 | NAS = EFS(탄력적인 파일 시스템) . | NAS란, 네트워크 연결 스토리지로, 네트워크를 통해 효과적으로 협업할 수 있도록 데이터를 지속적으로 사용할 수 있게 하는 파일 전용 스토리지 디바이스이다. | 많은 곳에서 NAS를 사용하는 이유 : 확장 가능하며, 저렴한 스토리지를 제공하기 때문. | . | . | 디스크 = EBS (탄력적인 블록 스토어 저장장치) | DB = RDS (관계형 데이터 베이스) | . ",
    "url": "/docs/studies/aws_DA/summary_1/#1-%EC%98%A8%ED%94%84%EB%9D%BC%EB%AF%B8%EC%8A%A4%EC%99%80-aws-%EC%9A%A9%EC%96%B4-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#1-온프라미스와-aws-용어-비교"
  },"541": {
    "doc": "AWS 기초 - 1",
    "title": "2. AWS의 기본 구성",
    "content": ". | 사용자가 서비스를 사용하는 과정 . | 특정 서비스에 연결하려면 도메인 질의를 한다. | DNS 서비스가 응답을 한다. | 해당 도메인을 IP로 변환하여 서버에 연결한다. | 서버의 디스크의 데이터를 읽는다.(?) | 따로 요청한 데이터를 디비에서 읽어온다. | 스토리지에 저장된 이미지나 파일들을 다운받아 사용한다. | . | AWS 용어로 치환 가능하다. | Route53이 도메인에 대한 응답을 한다. (참고로 DNS포트가 53이라, Route53이다.) | 서버 EC2로 접속한다. | 로컬 디스크인 EBS에서 데이터를 읽는다. | 비지니스적으로 요청한 데이터가 있으면, Amazon DB에서 읽어온다. | S3 등등 | . | . ",
    "url": "/docs/studies/aws_DA/summary_1/#2-aws%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#2-aws의-기본-구성"
  },"542": {
    "doc": "AWS 기초 - 1",
    "title": "3. 온프레미스, 클라우드, 하이브리드…",
    "content": ". | 온 프레미스 : 일반 데이터 센터, 물리 서버로 운영하는 데이터 센터 | 하이브리드 : 클라우드 + 온프레미스 | 클라우드 : AWS, AZURE, GCP 등 유료서비스 | 멀티클라우드 : 여러 개의 퍼블릭 클라우드를 사용하는 경우 | . ",
    "url": "/docs/studies/aws_DA/summary_1/#3-%EC%98%A8%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#3-온프레미스-클라우드-하이브리드"
  },"543": {
    "doc": "AWS 기초 - 1",
    "title": "4. AZ",
    "content": "AZ란, 가용영역으로 한 리전에 여러 AZ가 존재한다. ex) 서울 리전, 도쿄 리전. 아마존 서버가 존재하는 곳이다. AZ끼리는 전용선으로 연결되어 있기 때문에, 빠르게 데이터를 주고 받을 수 있다. ",
    "url": "/docs/studies/aws_DA/summary_1/#4-az",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#4-az"
  },"544": {
    "doc": "AWS 기초 - 1",
    "title": "5. AWS 엣지 인프라 서비스",
    "content": "(1). AWS Outposts . 클라우드를 온프라미스에서도 쓸 수 있도록 확장한 것. (2). AWS Local Zones . 대형 메트로 센터를 사용한 엣지 서비스 . 엣지 컴퓨팅 : 정보 저장 및 컴퓨팅 능력을 사용자에게 더 가까이 제공하는 프로세스 . (3). AWS Wavelength . 5G 네트워크 엣지 서비스 통신사에서 클라우드 서비스 하는 것이다. ",
    "url": "/docs/studies/aws_DA/summary_1/#5-aws-%EC%97%A3%EC%A7%80-%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#5-aws-엣지-인프라-서비스"
  },"545": {
    "doc": "AWS 기초 - 2",
    "title": "AWS 기초 - 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_2/",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/"
  },"546": {
    "doc": "AWS 기초 - 2",
    "title": "2023.09.04 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_2/#20230904-mon",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#20230904-mon"
  },"547": {
    "doc": "AWS 기초 - 2",
    "title": "1. 서버",
    "content": "(1). EC2 . | Elastic Compute Cloud의 줄임말이다. | C가 2개여서 EC2이다. | . (2). 인스턴스 패밀리 . | AWS 인스턴스 : 가상 컴퓨팅 환경으로 애플리케이션을 배포, 관리 및 확장하는데 도움이 되는 수많은 추가 기능 제공 | 인스턴스 표기법 . | | 인스턴스 패밀리 : M, T, C, X, R, IO, … (각 기능이 다르다.) | 인스턴스 세대 : 인스턴스 패밀리에 따라, 1~5세대 | 인스턴스 크기 : 인스턴스 패밀리 및 세대에 따라 다양한 크기 제공 | . | . ",
    "url": "/docs/studies/aws_DA/summary_2/#1-%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#1-서버"
  },"548": {
    "doc": "AWS 기초 - 2",
    "title": "2. EC2 요금",
    "content": ". | 온디맨드 인스턴스 | 예약 인스턴스 | Savings Plan | 스팟 인스턴스 | . ",
    "url": "/docs/studies/aws_DA/summary_2/#2-ec2-%EC%9A%94%EA%B8%88",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#2-ec2-요금"
  },"549": {
    "doc": "AWS 기초 - 2",
    "title": "3. 대표적인 컨테이너 관리형 서비스",
    "content": ". | . | ECS . | 간편 관리형 서비스 | AWS 전용이다. | 컨테이너가 소수일 때 커맨드로 관리 가능하지만, 많아지면 관리가 힘들어져 관리형 서비스를 사용한다. | ECS는 AWS에서 인프라를 관리해주며, 확장 등이 쉽게 가능하다. | . | . | . | EKS . | 쿠버네티스 사용의 관리 리소스가 포함됨 | 관리시간이 줄어듬 | 마스터노드의 관리를 AWS가 해줌 | 사용자는 워커노드만 관리하면 된다. | . | 워커노드 : 배포하고자 하는 어플리케이션의 실제 실행을 수행 - 마스터 서버로는 API 서버로 명령만 내릴 수 있다. - 별도의 AWS VPC에 마스터 서버가 구성된다. (사용자는 접근 불가) | . | . | . ",
    "url": "/docs/studies/aws_DA/summary_2/#3-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B4%80%EB%A6%AC%ED%98%95-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#3-대표적인-컨테이너-관리형-서비스"
  },"550": {
    "doc": "AWS 기초 - 2",
    "title": "4, 람다",
    "content": ". | 대표적인 서버리스 컴퓨팅 (이 또한 관리형 서비스) | 서버 처리가 이벤트 방식이다. (람다는 이벤트 발생 시 트래픽 처리됨) | 사용자가 확장 등을 고려할 필요가 없다. | 거의 모든 것이 자동으로 처리된다. | . ",
    "url": "/docs/studies/aws_DA/summary_2/#4-%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#4-람다"
  },"551": {
    "doc": "AWS 기초 - 3",
    "title": "AWS 기초 - 3",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_3/",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/"
  },"552": {
    "doc": "AWS 기초 - 3",
    "title": "2023.09.04 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_3/#20230904-mon",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#20230904-mon"
  },"553": {
    "doc": "AWS 기초 - 3",
    "title": "스토리지, 데이터 베이스",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_3/#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#스토리지-데이터-베이스"
  },"554": {
    "doc": "AWS 기초 - 3",
    "title": "1. AWS 스토리지 옵션",
    "content": "(1). Options . | S3 : 오브젝트 스토리지, 일반 스토리지 | S3 Glacier : S3 중 장기 보관용으로 저렴하다. | EFS : 공유 파일 스토리지, NAS와 같다. | NAS란, 네트워크를 통해 효과적으로 협업할 수 있도록 데이터를 지속적으로 사용할 수 있게 하는 파일 전용 스토리지 디바이스 | . | Storage Gateway | EBS - EC2에서 사용하는 디스크 저장소 | . ",
    "url": "/docs/studies/aws_DA/summary_3/#1-aws-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#1-aws-스토리지-옵션"
  },"555": {
    "doc": "TIL",
    "title": "Today I Learned",
    "content": "TIL has been written since July 1, 2023. ",
    "url": "/docs/tils#today-i-learned",
    
    "relUrl": "/docs/tils#today-i-learned"
  },"556": {
    "doc": "TIL",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils",
    
    "relUrl": "/docs/tils"
  },"557": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "content": " ",
    "url": "/docs/java/SpringBoot/toby_1-1/",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/"
  },"558": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "2024.09.24 (TUE)",
    "content": ". ",
    "url": "/docs/java/SpringBoot/toby_1-1/#20240924-tue",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#20240924-tue"
  },"559": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "스프링의 핵심 철학",
    "content": "객체지향 프로그래밍이 제공하는 오브젝트에 집중한다. 스프링은 객체지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지는 않는다. -&gt; 하지만 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할지에 대한 기준을 알려준다. ",
    "url": "/docs/java/SpringBoot/toby_1-1/#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%B2%A0%ED%95%99",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#스프링의-핵심-철학"
  },"560": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "오브젝트의 동일성과 동등성",
    "content": ". | 직접 생성한 팩토리 오브젝트는 오브젝트를 만들 때, 매번 다른 오브젝트가 생성된다. | . DaoFactory factory = new DaoFactory(); UserDao dao1 = factory.userDao(); UserDao dao2 = factroy.userDao(); System.out.println(dao1); System.out.println(dao2); . 출력: example.dao.UserDao@118f375 example.dao.UserDao@117a8bd . | 하지만, 스프링 컨텍스트로부터 가져온 오브젝트는 동일하다. | . ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); UserDao dao3 = context.getBean(\"userDao\", UserDao.class); UserDao dao4 = context.getBean(\"userDao\", UserDao.class); System.out.println(dao3); System.out.println(dao4); . 출력: example.dao.UserDao@ee22f7 example.dao.UserDao@ee22f7 . 오브젝트 팩토리와 스프링의 애플리케이션 컨텍스트의 동작방식에 차이가 있기 때문이다. | 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다. | 애플리케이션 컨텍스트는 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너이다. | 그러면서 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 싱글톤 레지스트리란? . | . | 왜 싱글톤으로 빈을 만들까? . | 스프링은 주로 “자바 엔터프라이즈 기술”을 사용하는 서버환경이기 때문이다. | 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구된다. | 아무리 자바의 성능이 좋아도 요청 한 번에 여러 오브젝트를 만들면,,, 서버 XoX,,, | . | 싱글톤 레지스트리는 private와 스태틱 메소드 만을 사용해야하는 비정상적인 클래스가 아닌 평범한 클래스도 싱글톤으로 사용이 가능하다. | 그럴 수 있는 이유는, 오브젝트의 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다. XML을 이용한 의존관계 설정정보\\ . | . | &lt;beans&gt;를 루트 엘리먼트로 사용한다. | 해당 beans안에는 여러개의 bean이 들어갈 수 있다. | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-1/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#오브젝트의-동일성과-동등성"
  },"561": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "1장 요약",
    "content": ". | 스프링이 왜 IoC 컨테이너인지, DI 프레임워크인지 설명해주는 파트였다. | 각종 의존관계를 코드로 설명해주어, IoC와 DI에 대한 설명이 좋았다. | 스프링이란, 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크 | . ",
    "url": "/docs/java/SpringBoot/toby_1-1/#1%EC%9E%A5-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#1장-요약"
  },"562": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "토비의 스프링 1권 2장 - 테스트",
    "content": " ",
    "url": "/docs/java/SpringBoot/toby_1-2/",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/"
  },"563": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "2024.09.29 (SUN)",
    "content": ". ",
    "url": "/docs/java/SpringBoot/toby_1-2/#20240929-sun",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#20240929-sun"
  },"564": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "스프링이 개발자에게 제공하는 가장 중요한 가치",
    "content": ". | 객체지향 | 테스트 | . 스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 애플리케이션은 점점 복잡해져 가는데, 그렇게 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 것이 테스트 기술이다. +) 또한 테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법 중 하나! . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%EC%A4%91%EC%9A%94%ED%95%9C-%EA%B0%80%EC%B9%98",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#스프링이-개발자에게-제공하는-가장-중요한-가치"
  },"565": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "테스트는 가능한 작게",
    "content": ". | 작은 단위의 테스트 (단위 테스트 / unit test) . | 테스트를 한꺼번에 너무 몰아서 많은 것을 하면, 테스트 수행 과정도 복잡해진다. | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9E%91%EA%B2%8C",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#테스트는-가능한-작게"
  },"566": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "테스트의 효율 향상을 위한 방법",
    "content": ". | 테스트 검증의 자동화 | . | 수정 전 System.out.prinln(user2.getName()); System.out.prinln(user2.getPassWord()); System.out.prinln(user2.getId() + \" 조회 성공\"); . | 수정 후 (자동화) if (!user.getName().equals(user2.getName())) { System.out.println(\"테스트 실패 (name)\"); // ... } . | . 개발자의 눈으로 일일히 확인할 필요 없이, 테스트를 실패하였는지 성공하였는지를 확인한다. | 테스트의 효율적인 수행과 결과 관리 . | JUnit을 활용한 단위 테스트 | 테스트의 수가 많아지면, IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것도 좋다. | ex). 이클립스 (run -&gt; Run As -&gt; JUnit Test) | . | “항상 네거티브 테스트를 먼저 만들라” . | 개발자는 흔히 “내가 할 떄는 잘됐는데”가 내장되어있을 수 있다.. | . | TDD : 테스트 주도 개발 . | 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법 | “실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.” | . | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%9A%A8%EC%9C%A8-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#테스트의-효율-향상을-위한-방법"
  },"567": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "JUnit 활용",
    "content": "@Before . | 매번 테스트마다 중복된 메소드를 불러온다면, @Before 애노테이션으로 설정해준다면, 각 테스트 메소드에서 코드를 실행하기 전에 @Before을 먼저 실행시킨다. | . public class UserDaoTest { private UserDao dao; @Before public void setUp() { ApplicationContext context = new GenericXmlApplicationContext(\"applicationContext.xml\"); this.dao = context.getBean(\"userDao\", UserDao.class); } @Test public void addAndGet() throws SQLException { // 각 테스트 메소드에 반복적으로 나타났던 코드를 제거하고 이를 @Before 에 옯겨 놓는다. // ... } @Test public void count() throws SQLException { // 각 테스트 메소드에 반복적으로 나타났던 코드를 제거하고 이를 @Before 에 옯겨 놓는다. // ... } // ... } . | JUnit이 제공하는 @Before 애노테이션, @Test 메소드가 실행되기 전에 먼저 실행되어야 하는 메소드를 정의한다. | . 테스트를 위한 애플리케이션 컨텍스트 관리 . | 애플리케이션 컨텍스트를 매 테스트마다 생성하는 것은 불필요하기 때문에, 스태틱 변수에 저장하는 등의 방법이 필요하다. | 그런 방법들 보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 이용하는 것이 더 편리하다. (@RunWith, @ContextConfiguration) | 매 테스트 메소드가 실행되기 전에 한번씩 실행되며, 모두 새로운 테스트 오브젝트를 만들어 사용한다. (애플리케이션 컨텍스트 재사용) | 여러 개의 테스트 클래스에게도 공유 가능 | . | . @Autowired . | 스프링 DI에 사용되는 특별한 애노테이션 | @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내 빈을 찾는다. | 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. | 일반적으로 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능 | ‼️‼️ 단, 같은 타입의 빈이 두 개 이상 있는 경우는 타입만으로 결정할 수 없다. | 선택할 수 없는 경우에는, 변수의 이름과 같은 이름의 빈이 있는지 확인 . | 이름으로도 찾을 수 없으면, 예외 발생 | . | . | . | 이를 통해서, 자신이 사용하는 오브젝트의 클래스가 무엇인지 알 필요가 없다는 장점이 있다. | . 학습 테스트 . | JUnit 자신에 대한 테스트를 통해, 테스트를 학습 테스트로 사용해 볼 수 있다. | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#junit-%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#junit-활용"
  },"568": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "2장 요약",
    "content": ". | 테스트는 자동화되어야 하며, 빠르게 실행되어야 한다. | main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다. | 테스트하기 쉬운 코드가 좋은 코드다. | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#2%EC%9E%A5-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#2장-요약"
  }
}
