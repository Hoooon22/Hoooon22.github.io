{"0": {
    "doc": "OOP",
    "title": "객체지향 프로그래밍",
    "content": " ",
    "url": "/docs/studies/object/02_OOP/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D",
    
    "relUrl": "/docs/studies/object/02_OOP/#객체지향-프로그래밍"
  },"1": {
    "doc": "OOP",
    "title": "2023.08.08 (TUE)",
    "content": ". ",
    "url": "/docs/studies/object/02_OOP/#20230808-tue",
    
    "relUrl": "/docs/studies/object/02_OOP/#20230808-tue"
  },"2": {
    "doc": "OOP",
    "title": "개요",
    "content": "객체지향은 객체를 지향하는 것이다. 대부분은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 생각한다. 하지만 이는 객체지향의 본질이 아니다. 객체지향은 말 그대로 객체를 지향하는 것이다. 클래스가 아닌 객체에 초점을 맞춰야 한다. 이를 위해선 다음을 중점적으로 살펴봐야 한다. 1️⃣ 어떤 클래스가 필요한지를 고민하기 전에, 어떤 객체들이 필요한지 고민하라. 일단 클래스와 객체의 차이점에 대해 살펴봐야 한다. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 예를 들면, 붕어빵이라는 객체를 만들기 위해 붕어빵 틀이라는 클래스를 구현하였다고 할 수 있다. 클래스를 구현하기 위해서는 어떤 객체들이 어떤 상태와 행동들을 가지는지를 먼저 봐야 한다는 것이다. 2️⃣ 객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원이라고 생각한다. 유지보수 가능한, 유연한 객체지향 코드를 만들기 위해서는 객체들이 다른 객체들에게 도음을 주거나 의존하는 그림이 되어야 한다. 붕어빵과 붕어빵 틀처럼, 붕어빵 기계들의 부품들이 붕어빵 틀이 잘 돌아가게 하고, 그 붕어빵 틀이 질 좋은 붕어빵을 만들게 된다. ",
    "url": "/docs/studies/object/02_OOP/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/object/02_OOP/#개요"
  },"3": {
    "doc": "OOP",
    "title": "도메인",
    "content": "도메인은 [문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야]라고 할 수 있다. ",
    "url": "/docs/studies/object/02_OOP/#%EB%8F%84%EB%A9%94%EC%9D%B8",
    
    "relUrl": "/docs/studies/object/02_OOP/#도메인"
  },"4": {
    "doc": "OOP",
    "title": "OOP",
    "content": " ",
    "url": "/docs/studies/object/02_OOP/",
    
    "relUrl": "/docs/studies/object/02_OOP/"
  },"5": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "1.1 인터넷의 작동 원리 🌐",
    "content": ". ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#11-%EC%9D%B8%ED%84%B0%EB%84%B7%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC-",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#11-인터넷의-작동-원리-"
  },"6": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "📖 개요",
    "content": "인터넷이 어떻게 작동하는지 이해하는 것은 백엔드 개발의 첫 걸음이다. 컴퓨터들이 어떻게 서로 연결되어 통신하는지 알아본다. ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-개요"
  },"7": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🔢 1. IP 주소 (IP Address)",
    "content": "인터넷에 연결된 모든 장치는 숫자로 된 주소를 가진다. IPv4 . | 192.168.0.1 같은 형태 | 주소 고갈 문제가 있다 | . IPv6 . | 2001:0db8:85a3... 같은 형태 | 더 많은 주소 할당 가능 | . 공인 IP vs 사설 IP . | 외부에서 접속 가능한 주소인지, 내부 공유기 안에서만 쓰이는 주소인지 구분하는 것이 백엔드 설정 시 매우 중요하다. | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-1-ip-%EC%A3%BC%EC%86%8C-ip-address",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-1-ip-주소-ip-address"
  },"8": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🔌 2. 컴퓨터 연결의 시작",
    "content": "2.1 인터넷이 어떻게 작동하는가? . 컴퓨터들이 웹상에서 서로를 찾아내는 방법은 두 가지이다: . 물리적 연결 . | 케이블을 통한 직접 연결 | . 무선 연결 . | WiFi | Bluetooth 등 | . 2.2 연결의 복잡성 문제 . | 2개의 컴퓨터를 연결하는 것은 간단하다 | 하지만 더 많은 컴퓨터를 연결하려면? | 10개의 컴퓨터를 모두 연결하려면 45개의 케이블이 필요하다! | 이런 방식으로는 관리가 너무 어려워진다 | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%97%B0%EA%B2%B0%EC%9D%98-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-2-컴퓨터-연결의-시작"
  },"9": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🔄 3. 라우터의 등장",
    "content": "3.1 물리적 연결 문제 해결 . 그래서 물리적 연결을 해결하기 위해 나온 것이 “라우터”이다! . 3.2 라우터가 있는 네트워크 . | 라우터가 있으면 n개의 케이블이 2-3개만 있어도 된다 | 각 컴퓨터는 라우터에만 연결하면 된다 | 라우터가 PC와 서버를 연결할 수 있게 해준다 | . [컴퓨터1] ──┐ [컴퓨터2] ──┤── [라우터] ──── [서버] [컴퓨터3] ──┘ . 3.3 라우터의 역할 . | 여러 컴퓨터들을 하나의 네트워크로 연결 | 데이터를 적절한 목적지로 전달 | 네트워크 관리를 단순화 | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-3-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%EB%93%B1%EC%9E%A5",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-3-라우터의-등장"
  },"10": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🌐 4. 네트워크에서 인터넷으로",
    "content": "4.1 네트워크의 확장 . | 처음에는 작은 네트워크에서 시작 | 하지만 더 멀리 있는 네트워크와도 통신하고 싶어진다 | 그래서 여러 네트워크들을 연결하게 된다 | . 4.2 인터넷이란? . 인터넷은 네트워크들의 네트워크이다! . | 작은 네트워크들이 모여서 더 큰 네트워크를 만든다 | 전 세계의 컴퓨터들이 서로 연결된다 | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%97%90%EC%84%9C-%EC%9D%B8%ED%84%B0%EB%84%B7%EC%9C%BC%EB%A1%9C",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-4-네트워크에서-인터넷으로"
  },"11": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🌍 5. ISP의 역할",
    "content": "5.1 ISP란? . ISP(Internet Service Provider)는 인터넷 서비스 제공업체이다. | 우리가 집에서 인터넷을 사용할 수 있게 해주는 회사들 | 예: KT, SK브로드밴드, LG유플러스 | . 5.2 ISP가 하는 일 . | 각 네트워크를 더 큰 인터넷과 연결 | 인터넷 연결 서비스 제공 | 전 세계 네트워크들을 중계 | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-5-isp%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-5-isp의-역할"
  },"12": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🏠 6. 호스팅 (Hosting)",
    "content": "웹사이트 파일(HTML, 서버 코드 등)을 24시간 켜져 있는 컴퓨터(서버)에 올려두는 서비스이다. 전통적 방식 . | 서버 컴퓨터 한 대를 빌리거나(Dedicated), 공간을 나눠 쓴다(Shared). | . 현대적 방식 (Cloud) . | AWS, GCP 같은 클라우드 서비스에서 필요한 만큼 자원을 빌려 쓰는 방식이 대세이다. | . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-6-%ED%98%B8%EC%8A%A4%ED%8C%85-hosting",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-6-호스팅-hosting"
  },"13": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🔍 7. DNS(Domain Name System)의 작동 원리",
    "content": "7.1 DNS란? . DNS(Domain Name System)는 사람이 읽을 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 읽을 수 있는 IP 주소(예: 192.168.1.0)로 변환하는 시스템이다. 이는 마치 전화번호부와 같은 역할을 하며, 인터넷 상의 모든 도메인에 대한 주소록이라고 할 수 있다. 7.2 DNS의 기본 작동 원리 . DNS의 작동 원리는 크게 두 가지 형태로 나눌 수 있다: . 1. 작동원리의 기본적인 형태 . | 클라이언트가 DNS 서버에 도메인에 대한 IP 주소를 요청 | DNS 서버가 해당 도메인의 IP 주소를 가지고 있다면 응답 | 클라이언트는 받은 IP 주소로 웹사이트에 접속 | . 2. 복잡한 형태 (다수의 도메인과 외부 DNS) . | 클라이언트가 Local DNS에 도메인 질의 | Local DNS가 Root DNS에 질의 | Root DNS가 TLD DNS 서버 정보 제공 | Local DNS가 TLD DNS에 질의하여 도메인의 권한 있는 DNS 서버 정보 획득 | Local DNS가 권한 있는 DNS 서버에 질의하여 IP 주소 획득 | 최종적으로 도메인의 IP 주소를 클라이언트에게 전달 | . 7.3 DNS 서버의 종류 . DNS 시스템에는 여러 종류의 DNS 서버가 존재한다: . 1. Local DNS 서버 . | ISP(인터넷 서비스 제공자)가 제공하는 DNS 서버 | 도메인에 대한 IP 주소가 캐시되어 있으면 즉시 응답 | 캐시가 없는 경우 다른 DNS 서버에 질의 | . 2. Root DNS 서버 . | DNS 시스템의 최상위 서버 | 전 세계에 13개의 루트 DNS 서버가 존재 | TLD DNS 서버의 정보를 제공 | . 3. TLD(Top Level Domain) DNS 서버 . | .com, .net, .org, .kr 등 최상위 도메인을 관리 | 해당 도메인의 권한 있는 DNS 서버 정보를 제공 | . 4. 권한 있는 DNS 서버(Authoritative DNS Server) . | 실제 도메인의 IP 주소 정보를 가지고 있는 서버 | 도메인 등록 시 지정한 네임서버 | 최종적으로 도메인에 대한 IP 주소를 제공 | . 7.4 DNS Cache . DNS 시스템의 효율성을 높이기 위해 캐시 시스템을 사용한다: . | DNS Cache의 목적 . | 매번 DNS에 요청을 통해 IP를 찾아야 하는 비효율 감소 | PC와 Local DNS 서버의 캐시를 활용하여 빠른 접속 가능 | 캐시는 TTL(Time To Live) 값에 따라 일정 시간 후 만료 | . | . 7.5 정리 . DNS는 인터넷의 핵심 인프라로, 도메인 이름과 IP 주소를 매핑하는 중요한 역할을 수행한다. 계층적인 구조를 통해 효율적으로 도메인 정보를 관리하며, 캐시 시스템을 통해 빠른 응답 속도를 제공한다. 이러한 시스템 덕분에 우리는 복잡한 IP 주소 대신 기억하기 쉬운 도메인 이름으로 웹사이트에 접속할 수 있다. ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-7-dnsdomain-name-system%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-7-dnsdomain-name-system의-작동-원리"
  },"14": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🌐 8. 브라우저의 작동 원리",
    "content": "8.1 웹 브라우저 . 웹 서버에서 양방향 통신을 하며 HTML 등의 컨텐츠를 열고 하게 해주는 GUI 기반 프로그램이다. 8.2 통신 흐름도 . graph LR 사용자 --&gt;|핸들링| 브라우저 브라우저 --&gt;|요청| 서버 서버 --&gt;|응답| 브라우저 브라우저 --&gt;|출력| 사용자 . 8.3 동작 원리 - 자원 요청 . 1. HTTP 프로토콜 . | DNS 서버에서 전달받은 IP주소와 URL 정보로 | HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성 | . 2. TCP/IP 프로토콜 . | HTTP 요청 메시지를 TCP 프로토콜로 사용하여 | 인터넷을 거쳐 해당 IP의 컴퓨터로 전송 | . 3. 응답 처리 . | 그렇게 도착한 HTTP 요청 메시지는 다시 | HTTP 프로토콜을 이용하여 URL 정보로 변환 | 응답은 역순으로 전달 | . 8.4 정리 . 브라우저는 웹 서버와의 통신에서 HTTP와 TCP/IP 프로토콜을 사용하여 자원을 요청하고 응답을 받아 처리하는 GUI 기반의 프로그램이다. 이를 통해 사용자는 웹 페이지를 쉽게 탐색하고 상호작용할 수 있다. ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-8-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-8-브라우저의-작동-원리"
  },"15": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🔐 9. HTTP/HTTPS 프로토콜 이해",
    "content": "9.1 HTTP란? . HTTP는 HyperText Transfer Protocol의 약자이다. 웹 브라우저와 웹 서버가 서로 통신할 때, 사용되는 약속이다. 즉, 웹에서 데이터를 주고받기 위한 통신 규약이다. HTTP의 통신과정: 클라이언트의 요청 -&gt; 서버의 응답 이 요청 메시지에는 무엇을(naver.com, index.html, …), 어떻게(GET,POST, …), 누가(브라우저에 대한 정보) 등이 적혀있다. 서버의 응답은 크게 두가지가 있다. | 처리 결과 (Status Code) . | 200 OK, 404 Not Found, … | . | 실제 데이터 (Body) . | 요청한 웹페이지의 실제 내용(HTML, CSS, Javascript 파일 등)을 보여준다. | . | . 이렇게 간단한 요청과 응답의 반복이다. 9.2 HTTPS의 등장 . HTTP는 평문 통신이기 때문에, 중간에 패킷을 가로채면 내용이 노출되는 보안 이슈가 있다. 이러한 보안 문제를 해결하기 위해 등장한 것이 HTTPS이다. HTTPS는 SSL/TLS라는 특별한 기술을 사용해서 주고받는 데이터를 안전하게 암호화 한다. 그럼 여기서, 서버와 브라우저는 어떻게 서로만 알아볼 수 있는 암호화를 할 수 있을까? . 9.3 SSL/TLS Handshake . 1. Client Hello . | 브라우저가 서버에게 (너 진짜임?) 증명을 요구한다. | . 2. Server Hello &amp; Certificate . | 서버는 신뢰할 수 있는 기관에서 발급받은 인증서(SSL 인가?)를 보여준다. | 이 인증서 안에는 웹사이트의 정보와 데이터를 암호화할 수 있는 공개키(Public key)가 있다. | . 3. Key Exchange . | 브라우저는 서버가 준 인증서를 검증하고, 서버의 공개키를 사용하여 둘만 사용할 대칭키를 만든다. | 서버의 공개키로 잠겨있기 때문에, 그에 맞는 서버만 확인할 수 있다. | . 4. Secure Communication . | 이제 브라우저와 서버는 둘만 아는 비밀 암호로 모든 데이터를 암호화해서 주고받는다. | . 9.4 HTTPS 필수인 시대 . 데이터의 중요성이 높아지는 만큼, 기본적인 웹사이트 보안은 HTTPS에서 시작한다. ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-9-httphttps-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%9D%B4%ED%95%B4",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-9-httphttps-프로토콜-이해"
  },"16": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "🎯 10. 핵심 정리",
    "content": "10.1 인터넷 작동 원리 요약 . | 물리적/무선 연결: 컴퓨터들을 연결하는 기본 방법 | 라우터: 복잡한 연결 문제를 해결하는 핵심 장비 | 네트워크: 라우터로 연결된 컴퓨터들의 그룹 | 인터넷: 네트워크들이 연결된 거대한 네트워크 | ISP: 우리를 인터넷에 연결해주는 서비스 제공업체 | . 10.2 연결 흐름 . [내 컴퓨터] → [라우터] → [ISP] → [인터넷] → [목적지 서버] . ",
    "url": "/docs/studies/backend/1.1-how-internet-works/#-10-%ED%95%B5%EC%8B%AC-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/#-10-핵심-정리"
  },"17": {
    "doc": "1.1 인터넷의 작동 원리",
    "title": "1.1 인터넷의 작동 원리",
    "content": " ",
    "url": "/docs/studies/backend/1.1-how-internet-works/",
    
    "relUrl": "/docs/studies/backend/1.1-how-internet-works/"
  },"18": {
    "doc": "1.2 버전 관리 시스템",
    "title": "1.2 버전 관리 시스템 📦",
    "content": ". ",
    "url": "/docs/studies/backend/1.2-version-control-system/#12-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C-",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#12-버전-관리-시스템-"
  },"19": {
    "doc": "1.2 버전 관리 시스템",
    "title": "📖 개요",
    "content": "버전 관리 시스템(VCS)은 코드의 변경 이력을 추적하고, 언제든 특정 시점으로 되돌릴 수 있으며, 여러 명의 개발자가 동시에 협업할 수 있게 해주는 필수 도구이다. 현재 업계 표준은 Git이다. ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-개요"
  },"20": {
    "doc": "1.2 버전 관리 시스템",
    "title": "🔧 1. 버전 관리란?",
    "content": "1.1 버전 관리의 필요성 . 코드의 변경 이력 추적 . | 누가, 언제, 무엇을, 왜 변경했는지 모든 기록을 남긴다 | 문제가 생기면 이전 버전으로 되돌릴 수 있다 | . 협업 지원 . | 여러 명의 개발자가 동시에 작업할 수 있다 | 코드 충돌을 관리하고 해결할 수 있다 | . 백업 및 복구 . | 코드를 안전하게 보관한다 | 실수로 삭제한 파일도 복구할 수 있다 | . 1.2 Git의 특징 . 분산 버전 관리 . | 중앙 서버뿐만 아니라 각 개발자의 컴퓨터에도 전체 이력이 저장된다 | 네트워크가 없어도 대부분의 작업을 수행할 수 있다 | . 빠른 성능 . | 대부분의 작업이 로컬에서 이루어져 매우 빠르다 | 브랜치 생성과 병합이 가볍고 빠르다 | . 강력한 브랜치 시스템 . | 실험적인 작업을 안전하게 진행할 수 있다 | 여러 기능을 동시에 개발할 수 있다 | . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-1-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC%EB%9E%80",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-1-버전-관리란"
  },"21": {
    "doc": "1.2 버전 관리 시스템",
    "title": "🌐 2. 주요 플랫폼",
    "content": "2.1 GitHub . 특징 . | 전 세계 개발자들이 가장 많이 사용하는 플랫폼 | 오픈 소스 프로젝트와 커뮤니티 형성이 잘 되어 있다 | 무료 플랜으로도 충분한 기능 제공 | . 주요 기능 . | Pull Request를 통한 코드 리뷰 | GitHub Actions를 통한 CI/CD | Issues를 통한 프로젝트 관리 | GitHub Pages를 통한 정적 사이트 호스팅 | . 적합한 용도 . | 오픈 소스 프로젝트 | 개인 포트폴리오 | 소규모 팀 프로젝트 | . 2.2 GitLab . 특징 . | 강력한 CI/CD 기능이 내장되어 있다 | 기업이 사내 서버에 직접 설치해 사용하기에 적합하다 | 무료 플랜에서도 프라이빗 저장소 무제한 | . 주요 기능 . | 내장된 CI/CD 파이프라인 | 자체 호스팅 가능 (GitLab CE) | 강력한 보안 기능 | 이슈 보드와 프로젝트 관리 도구 | . 적합한 용도 . | 기업 내부 프로젝트 | DevOps 자동화가 중요한 프로젝트 | 보안이 중요한 프로젝트 | . 2.3 Bitbucket . 특징 . | Jira, Confluence 등 Atlassian 제품군과의 연동성이 뛰어나다 | 프로젝트 관리가 용이하다 | 소규모 팀에게 무료 플랜 제공 | . 주요 기능 . | Jira와의 완벽한 통합 | Pull Request 기능 | 파이프라인을 통한 CI/CD | 브랜치 권한 관리 | . 적합한 용도 . | Atlassian 생태계를 사용하는 팀 | 프로젝트 관리와 개발을 통합하고 싶은 경우 | 소규모 팀 협업 | . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-2-%EC%A3%BC%EC%9A%94-%ED%94%8C%EB%9E%AB%ED%8F%BC",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-2-주요-플랫폼"
  },"22": {
    "doc": "1.2 버전 관리 시스템",
    "title": "💻 3. Git 기초 명령어",
    "content": "3.1 저장소 초기화 . 새로운 저장소 생성 . git init . | 현재 디렉토리를 Git 저장소로 초기화한다 | .git 폴더가 생성된다 | . 기존 저장소 복제 . git clone [저장소 URL] . | 원격 저장소의 전체 내용을 복사한다 | . 3.2 기본 워크플로우 . 1. 상태 확인 . git status . | 변경된 파일을 확인한다 | 스테이징 영역의 상태를 확인한다 | . 2. 스테이징 (Staging) . git add . # 모든 변경사항 추가 git add [파일명] # 특정 파일만 추가 . | 커밋할 파일을 선택한다 | 스테이징 영역에 파일을 추가한다 | . 3. 커밋 (Commit) . git commit -m \"커밋 메시지\" . | 스테이징된 변경사항을 기록한다 | 의미 있는 커밋 메시지를 작성한다 | . 4. 원격 저장소 연결 . git remote add origin [저장소 URL] . | 로컬 저장소와 원격 저장소를 연결한다 | . 5. 푸시 (Push) . git push origin main . | 로컬 커밋을 원격 저장소로 전송한다 | . 6. 풀 (Pull) . git pull origin main . | 원격 저장소의 최신 변경사항을 가져온다 | 자동으로 병합을 시도한다 | . 3.3 이력 확인 . 커밋 이력 보기 . git log # 상세한 이력 git log --oneline # 간략한 이력 git log --graph # 그래프 형태로 보기 . 변경사항 확인 . git diff # 작업 디렉토리의 변경사항 git diff --staged # 스테이징된 변경사항 . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-3-git-%EA%B8%B0%EC%B4%88-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-3-git-기초-명령어"
  },"23": {
    "doc": "1.2 버전 관리 시스템",
    "title": "🌿 4. 브랜치 전략",
    "content": "4.1 Git Flow . 개요 . | 5가지 브랜치를 엄격하게 관리하는 대규모 프로젝트용 전략 | 명확한 역할 분담과 릴리즈 관리가 가능하다 | . 브랜치 종류 . 1. Main (Master) . | 배포 가능한 상태만 유지 | 언제든 프로덕션에 배포할 수 있는 코드 | . 2. Develop . | 다음 릴리즈를 위한 개발 브랜치 | Feature 브랜치들이 병합되는 곳 | . 3. Feature . | 새로운 기능 개발용 브랜치 | feature/기능명 형태로 명명 | 개발 완료 후 Develop에 병합 | . 4. Release . | 배포 준비를 위한 브랜치 | release/버전 형태로 명명 | 버그 수정만 가능 | . 5. Hotfix . | 긴급 버그 수정용 브랜치 | Main에서 분기하여 수정 후 Main과 Develop 모두에 병합 | . 장점 . | 체계적인 릴리즈 관리 | 명확한 브랜치 역할 구분 | 대규모 프로젝트에 적합 | . 단점 . | 복잡한 구조 | 작은 프로젝트에는 과도할 수 있음 | . 4.2 GitHub Flow . 개요 . | Main 브랜치를 항상 배포 가능한 상태로 유지 | 기능 개발 시 Feature 브랜치를 만들어 작업 후 바로 병합하는 단순한 전략 | . 워크플로우 . | Main 브랜치에서 Feature 브랜치 생성 | Feature 브랜치에서 개발 진행 | 커밋을 자주 하고 원격 저장소에 푸시 | Pull Request 생성 | 코드 리뷰 및 토론 | Main 브랜치에 병합 | 즉시 배포 | . 장점 . | 단순하고 이해하기 쉬움 | 빠른 배포 주기에 적합 | 지속적 배포(Continuous Deployment)에 적합 | . 단점 . | 릴리즈 관리가 명확하지 않음 | 여러 버전을 동시에 관리하기 어려움 | . 4.3 브랜치 기본 명령어 . 브랜치 생성 . git branch [브랜치명] # 브랜치 생성 git checkout -b [브랜치명] # 생성과 동시에 전환 git switch -c [브랜치명] # 최신 명령어 . 브랜치 전환 . git checkout [브랜치명] git switch [브랜치명] # 최신 명령어 . 브랜치 확인 . git branch # 로컬 브랜치 목록 git branch -r # 원격 브랜치 목록 git branch -a # 모든 브랜치 목록 . 브랜치 병합 . git merge [브랜치명] # 현재 브랜치에 병합 . 브랜치 삭제 . git branch -d [브랜치명] # 로컬 브랜치 삭제 git push origin --delete [브랜치명] # 원격 브랜치 삭제 . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-4-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-4-브랜치-전략"
  },"24": {
    "doc": "1.2 버전 관리 시스템",
    "title": "👥 5. 협업 워크플로우",
    "content": "5.1 Pull Request (PR) 프로세스 . 1. 브랜치 생성 . git checkout -b feature/new-feature . | 기능별로 브랜치를 생성한다 | 명확한 이름을 사용한다 | . 2. 개발 및 커밋 . git add . git commit -m \"feat: 새로운 기능 추가\" . | 의미 있는 단위로 커밋한다 | 명확한 커밋 메시지를 작성한다 | . 3. 원격 저장소에 푸시 . git push origin feature/new-feature . 4. Pull Request 생성 . | GitHub/GitLab/Bitbucket에서 PR 생성 | 변경 사항을 명확하게 설명 | 관련 이슈가 있다면 연결 | . 5. 코드 리뷰 . | 동료 개발자들이 코드를 검토 | 피드백을 주고받는다 | 필요시 수정 후 추가 커밋 | . 6. 승인 및 병합 . | 승인(Approve)을 받은 후 병합 | 병합 후 브랜치 삭제 고려 | . 5.2 커밋 메시지 컨벤션 . 기본 형식 . 타입: 제목 본문 (선택사항) 푸터 (선택사항) . 주요 타입 . | feat: 새로운 기능 추가 | fix: 버그 수정 | docs: 문서 수정 | style: 코드 포맷팅, 세미콜론 누락 등 | refactor: 코드 리팩토링 | test: 테스트 코드 추가 | chore: 빌드 업무, 패키지 매니저 수정 등 | . 예시 . git commit -m \"feat: 사용자 로그인 기능 추가\" git commit -m \"fix: 회원가입 시 이메일 유효성 검증 오류 수정\" git commit -m \"docs: README에 설치 방법 추가\" . 5.3 충돌 해결 . 충돌이 발생하는 경우 . | 같은 파일의 같은 부분을 서로 다르게 수정했을 때 | Pull이나 Merge 시 발생 | . 충돌 해결 방법 . | 충돌이 발생한 파일을 확인 git status . | 파일을 열어 충돌 부분 확인 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 현재 브랜치의 내용 ======= 병합하려는 브랜치의 내용 &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/new-feature . | 충돌을 해결하고 마커 제거 . | 수정된 파일을 스테이징 git add [파일명] . | 병합 완료 git commit . | . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-5-%ED%98%91%EC%97%85-%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-5-협업-워크플로우"
  },"25": {
    "doc": "1.2 버전 관리 시스템",
    "title": "⚙️ 6. Git 설정 및 최적화",
    "content": "6.1 전역 설정 . 사용자 정보 설정 . git config --global user.name \"이름\" git config --global user.email \"이메일\" . 기본 에디터 설정 . git config --global core.editor \"code\" # VS Code git config --global core.editor \"vim\" # Vim . 줄바꿈 설정 . # Windows git config --global core.autocrlf true # Mac/Linux git config --global core.autocrlf input . 6.2 .gitignore . 개념 . | Git이 추적하지 않을 파일과 디렉토리를 지정한다 | 민감한 정보나 빌드 산출물을 제외한다 | . Java 프로젝트 예시 . # 컴파일된 클래스 파일 *.class *.jar *.war *.ear # 빌드 디렉토리 /build/ /out/ /target/ # IDE 설정 파일 .idea/ .vscode/ *.iml # 민감한 설정 파일 application-prod.properties application-secret.yml # 로그 파일 *.log # OS 파일 .DS_Store Thumbs.db . 중요 주의사항 . | 민감한 정보(API 키, 비밀번호 등)는 절대 커밋하지 않는다 | 이미 커밋된 파일은 .gitignore에 추가해도 계속 추적된다 | 이미 커밋된 파일을 제거하려면: git rm --cached [파일명] git commit -m \"Remove sensitive file\" . | . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#%EF%B8%8F-6-git-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#️-6-git-설정-및-최적화"
  },"26": {
    "doc": "1.2 버전 관리 시스템",
    "title": "🎯 7. 핵심 정리",
    "content": "7.1 버전 관리 시스템 요약 . 핵심 개념 . | 코드 변경 이력 추적 및 관리 | 협업을 위한 필수 도구 | Git이 업계 표준 | . 주요 플랫폼 . | GitHub: 오픈소스와 커뮤니티 | GitLab: CI/CD와 기업용 | Bitbucket: Atlassian 생태계 통합 | . 기본 워크플로우 . 초기화 → 작업 → 스테이징 → 커밋 → 푸시 → 풀 . 브랜치 전략 . | Git Flow: 대규모 프로젝트용 | GitHub Flow: 단순하고 빠른 배포 | . 협업 방식 . | Feature 브랜치 생성 | Pull Request를 통한 코드 리뷰 | 승인 후 병합 | . 7.2 실무 팁 . 좋은 커밋 습관 . | 의미 있는 단위로 자주 커밋 | 명확한 커밋 메시지 작성 | 한 커밋에는 한 가지 변경사항만 | . 안전한 협업 . | 작업 전 항상 최신 코드 pull | Feature 브랜치에서 작업 | 정기적으로 원격 저장소에 push | . 보안 주의사항 . | .gitignore 적극 활용 | 민감한 정보는 환경변수로 관리 | 실수로 커밋한 민감 정보는 즉시 제거 | . 7.3 다음 단계 . 버전 관리 시스템을 익힌 후에는: . | 실제 프로젝트에 적용하며 연습 | 오픈 소스 프로젝트에 기여 | 팀 프로젝트에서 협업 경험 | CI/CD 파이프라인 구축 학습 | . ",
    "url": "/docs/studies/backend/1.2-version-control-system/#-7-%ED%95%B5%EC%8B%AC-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/#-7-핵심-정리"
  },"27": {
    "doc": "1.2 버전 관리 시스템",
    "title": "1.2 버전 관리 시스템",
    "content": " ",
    "url": "/docs/studies/backend/1.2-version-control-system/",
    
    "relUrl": "/docs/studies/backend/1.2-version-control-system/"
  },"28": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "1.3 관계형 데이터베이스 🗄️",
    "content": ". ",
    "url": "/docs/studies/backend/1.3-relational-database/#13-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EF%B8%8F",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#13-관계형-데이터베이스-️"
  },"29": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "📖 개요",
    "content": "관계형 데이터베이스(RDBMS)의 기본 개념과 SQL에 대해 학습합니다. ",
    "url": "/docs/studies/backend/1.3-relational-database/#-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#-개요"
  },"30": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "1. 관계형 데이터베이스란?",
    "content": "관계형 데이터베이스는 데이터를 Table 형식으로 저장하며, 각 테이블 간의 관계를 정의하여 만들어지는 데이터베이스이다. 특징 : 고정된 스키마(구조), 데이터 무결성(정확성), SQL을 이용한 데이터 조작 . | 스키마 : 데이터의 구조와 규칙을 정의하는 설계도 | . ",
    "url": "/docs/studies/backend/1.3-relational-database/#1-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%9E%80",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#1-관계형-데이터베이스란"
  },"31": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "2. SQL 기초",
    "content": "SQL은 관계형 데이터베이스와 대화하기 위한 표준언어. | DDL(Definition): 데이터 테이블을 생성, 수정 (CREATE, DROP, ALTER) | DML(Maipulation): 데이터 자체를 조작 (SELECT, INSERT, DELETE, UPDATE) | DCL(Control): 권한을 부여하거나 회수 (GRANT, REVOKE) | . ",
    "url": "/docs/studies/backend/1.3-relational-database/#2-sql-%EA%B8%B0%EC%B4%88",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#2-sql-기초"
  },"32": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "3. 데이터베이스 설계",
    "content": "데이터베이스를 설계는 올바른 데이터베이스 테이블을 정의하기 위한 과정이다. 크게 3개의 단계로 구성된다. | 개념적 설계 (ERD 그리기) 비즈니스 요구사항을 바탕으로 개념적 설계에 들어간다. (어떤 데이터가 필요한가?) | . | 엔티티: 관리해야할 대상 | 속성: 대상이 가진 특성 | 관계: 대상 간의 연결 | . | 논리적 설계 (정규화) 개념적 설계로 실제 테이블 형태로 만든 후, 데이터 중복을 제거하는 과정 | . | 제1정규화: 각 Cell에는 하나의 값만 들어가야 함. | 제2정규화: 기본키(PK)가 아닌 컬럼은 기본키 전체에 의존해야함. | 이게 무슨 말이야? -&gt; 관련 없는 애들 싹 다 쳐내! | . | 제3정규화: 기본키(PK)가 아닌 컬럼들끼리 의존관계가 있으면 안됨. | 이게 또 뭔 말이야.. -&gt; 다리 건너 아는 걸 방지 (A -&gt; B -&gt; C) | . | . | 물리적 설계 (성능 최적화) 실제 DBMS에 맞게 최적화하는 작업 | . | 데이터 타입 결정, 인덱스 설정, 반정규화(의도적으로 성능 향상을 위해 정규화를 위반) | . ",
    "url": "/docs/studies/backend/1.3-relational-database/#3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#3-데이터베이스-설계"
  },"33": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "4. 트랜잭션과 ACID",
    "content": "데이터의 일관성을 위해 작업의 단위를 지정하는데, 이를 트랜잭션이라고 한다. 예를 들어, 은행의 돈을 A에서 B로 이동하는데 A의 출금과 B의 입금 중 하나만 진행되면 큰 문제가 발생한다. 때문에, 이를 묶어서 둘다 성공하거나 둘다 실패하게 하는 작업의 단위로 만드는 것이다. ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하는 4가지 조건이다. | Atomaicity (원자성) | Consistency (일관성) | Isolation (격리성) | Durability (지속성) | . ",
    "url": "/docs/studies/backend/1.3-relational-database/#4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#4-트랜잭션과-acid"
  },"34": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "5. 인덱스",
    "content": "인덱스는 “색인 번호”와 유사하다. 수만 페이지를 처음부터 세지 않고, 페이지 번호를 바로 찾는 것 . 가장 일반적으로 사용되는 인덱스의 자료구조는 “B-Tree” 검색(SELECT)에 유리해짐, 하지만 수정(INSERT) 발생 시에는 자료구조를 다시 만들어야 하기 때문에 성능 저하. 또한 저장공간을 차지해서 유의해야 함. ",
    "url": "/docs/studies/backend/1.3-relational-database/#5-%EC%9D%B8%EB%8D%B1%EC%8A%A4",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#5-인덱스"
  },"35": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "6. Migration",
    "content": "데이터베이스의 Git 버전 공유나 관리가 필요할 때, Migration.sql 파일을 생성하여 버전 관리를 할 수 있다. ",
    "url": "/docs/studies/backend/1.3-relational-database/#6-migration",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#6-migration"
  },"36": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "7. N+1문제",
    "content": "데이터를 1개를 조회 했을때, 그와 연관된 N개의 데이터베이스가 추가로 조회될 때 발생하는 성능 저하 . ",
    "url": "/docs/studies/backend/1.3-relational-database/#7-n1%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/#7-n1문제"
  },"37": {
    "doc": "1.3 관계형 데이터베이스",
    "title": "1.3 관계형 데이터베이스",
    "content": " ",
    "url": "/docs/studies/backend/1.3-relational-database/",
    
    "relUrl": "/docs/studies/backend/1.3-relational-database/"
  },"38": {
    "doc": "1.4.1 API 스타일",
    "title": "1.4.1 API 스타일 🎨",
    "content": ". ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#141-api-%EC%8A%A4%ED%83%80%EC%9D%BC-",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#141-api-스타일-"
  },"39": {
    "doc": "1.4.1 API 스타일",
    "title": "1. REST",
    "content": "Rest Api를 학습한 코드는 devzip에 게시하였습니다. 1️⃣ React 상태 관리 (useState) . // 요청에 필요한 데이터 const [method, setMethod] = useState('GET'); // HTTP 메서드 const [url, setUrl] = useState('https://...'); // 요청 URL const [headers, setHeaders] = useState('{...}'); // 헤더 (문자열) const [body, setBody] = useState(''); // 바디 // 응답 결과 저장 const [response, setResponse] = useState(null); // 응답 데이터 const [loading, setLoading] = useState(false); // 로딩 상태 const [error, setError] = useState(null); // 에러 메시지 . 핵심: 화면에 보여줄 데이터는 useState로 관리하고, set함수로 업데이트 . 2️⃣ fetch API 기본 구조 . const res = await fetch(url, { method: method, // 'GET', 'POST', 'PUT', 'DELETE' 등 headers: headerObj, // { \"Content-Type\": \"application/json\" } body: body // POST/PUT일 때만 사용 }); . 핵심: fetch(URL, 옵션객체) 형태로 HTTP 요청을 보냄 . 3️⃣ async/await 비동기 처리 . const executeRequest = async () =&gt; { // async 함수 선언 const res = await fetch(url); // await로 응답 기다림 const data = await res.json(); // await로 JSON 파싱 기다림 }; . 핵심: . | async = “이 함수는 비동기 작업을 합니다” | await = “이 작업이 끝날 때까지 기다립니다” | . 4️⃣ try/catch/finally 에러 처리 패턴 . try { // 성공할 수도 있는 코드 const res = await fetch(url); } catch (err) { // 실패했을 때 실행 setError(err.message); } finally { // 성공/실패 상관없이 항상 실행 setLoading(false); } . 핵심: 네트워크 요청은 항상 실패할 수 있으므로 try/catch 필수! . 5️⃣ 응답(Response) 처리 . // 응답 객체에서 정보 추출 res.status // 200, 404, 500 등 상태 코드 res.statusText // \"OK\", \"Not Found\" 등 res.headers // 응답 헤더들 // 응답 바디 파싱 await res.json() // JSON 형태일 때 await res.text() // 텍스트 형태일 때 . 핵심: res.json()도 비동기라서 await 필요! . 6️⃣ HTTP 상태 코드 의미 . 200-299 → 성공 (초록색) 300-399 → 리다이렉트 (주황색) 400-499 → 클라이언트 오류 (빨간색) - 내 잘못 500-599 → 서버 오류 (보라색) - 서버 잘못 . 전체 흐름 요약 . [전송 버튼 클릭] ↓ [로딩 시작, 이전 결과 초기화] ↓ [헤더 문자열 → JSON 객체로 변환] ↓ [fetch()로 HTTP 요청 전송] ↓ [응답 대기 (await)] ↓ [응답 헤더, 바디 파싱] ↓ [화면에 결과 표시] ↓ [로딩 종료] . ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#1-rest",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#1-rest"
  },"40": {
    "doc": "1.4.1 API 스타일",
    "title": "2. JSON APIs",
    "content": "1️⃣ JSON 기본 개념 . JSON이란? . | JavaScript Object Notation | 데이터를 저장하고 전송하기 위한 텍스트 형식 | 모든 프로그래밍 언어에서 사용 가능 | . JSON 데이터 타입 . | 문자열: 쌍따옴표만 사용 “hello” | 숫자: 42, 3.14 | 불리언: true, false | null: null | 배열: [1, 2, 3] | 객체: {“key”: “value”} | . 2️⃣ 핵심 메서드 두 가지 . JSON.parse() - 문자열을 객체로 변환 const obj = JSON.parse(‘{“name”:”철수”}’); // obj.name === “철수” . JSON.stringify() - 객체를 문자열로 변환 JSON.stringify(obj) // 압축 (한 줄) JSON.stringify(obj, null, 2) // 포맷 (들여쓰기 2칸) . 3️⃣ 구현 과정에서 배운 것들 . try/catch 올바른 사용법 // 잘못된 예 - finally에서 성공 처리 try { JSON.parse(input); } catch (err) { setError(err.message); } finally { setResult(“성공”); // 에러가 나도 실행됨 } . // 올바른 예 - try 안에서 성공 처리 try { JSON.parse(input); setResult(“성공”); // 성공할 때만 실행 } catch (err) { setError(err.message); } . 템플릿 리터럴 // 작은따옴표 - 변수 삽입 안 됨 ‘오류: ${err.message}’ // 그대로 출력됨 . // 백틱 - 변수 삽입 가능 오류: ${err.message} // 실제 에러 메시지 출력 . 함수 반환값 사용하기 // 잘못된 예 - 결과를 버림 JSON.stringify(parsed); setInputJson(parsed); // 객체 전달 (오류) . // 올바른 예 - 결과를 변수에 저장 const result = JSON.stringify(parsed); setInputJson(result); // 문자열 전달 (정상) . React setState는 반환값이 없다 const result = setInputJson(x); // result는 undefined . 4️⃣ 최종 구현 코드 . 유효성 검사 try { JSON.parse(inputJson); setResult({ type: ‘validate’, message: ‘유효한 JSON입니다.’ }); } catch (err) { setError(오류: ${err.message}); } . 포맷터 try { const parsed = JSON.parse(inputJson); const formatted = JSON.stringify(parsed, null, 2); setInputJson(formatted); } catch (err) { setError(오류: ${err.message}); } . 압축 try { const parsed = JSON.parse(inputJson); const minified = JSON.stringify(parsed); setInputJson(minified); } catch (err) { setError(오류: ${err.message}); } . 5️⃣ 핵심 패턴 요약 . | JSON 처리는 항상 try/catch로 감싸기 (파싱 실패 대비) | 성공 처리는 try 블록 안에서 | 함수 반환값은 변수에 저장해서 사용 | 문자열 안에 변수 넣을 때는 백틱 사용 | . ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#2-json-apis",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#2-json-apis"
  },"41": {
    "doc": "1.4.1 API 스타일",
    "title": "3. SOAP API",
    "content": "SOAP API는 추후에 학습 예정입니다. ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#3-soap-api",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#3-soap-api"
  },"42": {
    "doc": "1.4.1 API 스타일",
    "title": "4. gRPC",
    "content": "gRPC (gRPC Remote Procedure Call)는 Google이 개발한 고성능 RPC 프레임워크이다. RPC: 원격 프로시저 호출 . ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#4-grpc",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#4-grpc"
  },"43": {
    "doc": "1.4.1 API 스타일",
    "title": "5. GraphQL",
    "content": "GraphQL은 API를 위한 쿼리 언어이자, 그 쿼리를 실행하는 서버 측 런타임. REST의 한계(여러 엔드포인트, 오버 페칭 등)을 극복하기 위한 쿼리 언어. 장점: 필요한 필드만, 한 번의 쿼리로 연관된 데이터를 묶어서. ",
    "url": "/docs/studies/backend/1.4.1-api-styles/#5-graphql",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/#5-graphql"
  },"44": {
    "doc": "1.4.1 API 스타일",
    "title": "1.4.1 API 스타일",
    "content": " ",
    "url": "/docs/studies/backend/1.4.1-api-styles/",
    
    "relUrl": "/docs/studies/backend/1.4.1-api-styles/"
  },"45": {
    "doc": "1일 1코딩",
    "title": "1일 1코테연습",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/1day1coding/#1%EC%9D%BC-1%EC%BD%94%ED%85%8C%EC%97%B0%EC%8A%B5",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/#1일-1코테연습"
  },"46": {
    "doc": "1일 1코딩",
    "title": "This Page has been written since July 11, 2023.",
    "content": ". | Links | . 이전 코테 연습 풀이 . ",
    "url": "/docs/codingtest/1day1coding/1day1coding/#this-page-has-been-written-since-july-11-2023",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/#this-page-has-been-written-since-july-11-2023"
  },"47": {
    "doc": "1일 1코딩",
    "title": "1일 1코딩",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/1day1coding/",
    
    "relUrl": "/docs/codingtest/1day1coding/1day1coding/"
  },"48": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "Github Actions를 활용한 프로젝트 무중단 배포",
    "content": " ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/"
  },"49": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "2024.10.23 (WED)",
    "content": ". Devzip 프로젝트를 진행하면서, 매번 console에 접속하여 git pull 및 빌드, 재시작하는 것이 굉장히 비효율적으로 느껴졌다. 그 때, 현재 Github.io 블로그에서 깃헙 커밋 변화에 따른 자동 빌드 시스템이 생각나서 이를 활용해보기로 하였다. ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/#20241023-wed",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/#20241023-wed"
  },"50": {
    "doc": "Github Actions를 활용한 프로젝트 무중단 배포",
    "title": "Github Actions",
    "content": "Github Actions는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼이다. GitHub Actions를 사용하면 자동으로 코드 저장소에서 어떤 이벤트(event)가 발생했을 때 특정 작업이 일어나게 하거나 주기적으로 어떤 작업들을 반복해서 실행시킬 수 있다.github/workflows 내부의 나의 설정 파일은 아래와 같다. name: dev branch auto ci process script on: # 아래 job을 실행시킬 상황 push: branches: [ master ] jobs: deploy: name: deploy runs-on: ubuntu-latest # 실행될 인스턴스 OS와 버전 steps: - name: excuting remote ssh commands uses: appleboy/ssh-action@v0.1.6 # ssh 접속하는 오픈소스 with: host: $ # 인스턴스 IP username: $ # 우분투 아이디 key: $ # ec2 instance pem key port: $ # 접속포트 script: | # 실행할 스크립트 # ~~~ . 5번째 줄: push이벤트가 발생할 때, 실행 시킨다. 이외의 코드는 AWS EC2에 접속하고 명령을 실행하는 코드로 이루어져 있다. | push 시, 자동 실행된 모습 | . ",
    "url": "/docs/projects/devzip/2024-10-23-githubactions/#github-actions",
    
    "relUrl": "/docs/projects/devzip/2024-10-23-githubactions/#github-actions"
  },"51": {
    "doc": "TIL (23-06-29)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230629/#til",
    
    "relUrl": "/docs/tils/230629/#til"
  },"52": {
    "doc": "TIL (23-06-29)",
    "title": "2023.06.29 (WED)",
    "content": ". 📌 오늘의 TIL . | 💻 깃허브 블로그 제작 . | just the Docs Theme 적용 및 틀 구현 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 구현 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 가슴 | . ",
    "url": "/docs/tils/230629/#20230629-wed",
    
    "relUrl": "/docs/tils/230629/#20230629-wed"
  },"53": {
    "doc": "TIL (23-06-29)",
    "title": "TIL (23-06-29)",
    "content": " ",
    "url": "/docs/tils/230629/",
    
    "relUrl": "/docs/tils/230629/"
  },"54": {
    "doc": "제작 일지 <1>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230702/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/pongdang/230702/#퐁당-웹-매거진-프로젝트-제작-일지-1"
  },"55": {
    "doc": "제작 일지 <1>",
    "title": "2023.07.02 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230702/#20230702-wed",
    
    "relUrl": "/docs/projects/pongdang/230702/#20230702-wed"
  },"56": {
    "doc": "제작 일지 <1>",
    "title": "1. 프로젝트 빌드 후, Servlet.service() for sevlet 오류 발생 시",
    "content": "해결법 1. 프로젝트 클린(clean)과 재빌드(rebuild)는 빌드 도구(Maven, Gradle 등)를 사용하여 프로젝트를 초기화하고 의존성을 새롭게 다운로드하여 프로젝트를 다시 빌드하는 작업입니다. 이를 통해 이전에 캐시된 클래스 파일이나 의존성 문제로 인해 발생하는 오류를 해결할 수 있습니다. 아래는 Maven과 Gradle에서 프로젝트 클린과 재빌드를 수행하는 방법입니다: . Maven을 사용하는 경우: . 프로젝트 디렉토리로 이동합니다. 명령줄 또는 터미널에서 다음 명령어를 실행합니다: mvn clean install clean: 이전 빌드에 의해 생성된 클래스 파일과 빌드 아티팩트를 제거합니다. install: 프로젝트를 빌드하고 로컬 Maven 저장소에 라이브러리를 설치합니다. Gradle을 사용하는 경우: . 프로젝트 디렉토리로 이동합니다. 명령줄 또는 터미널에서 다음 명령어를 실행합니다: gradlew clean build clean: 이전 빌드에 의해 생성된 클래스 파일과 빌드 아티팩트를 제거합니다. build: 프로젝트를 빌드하고 필요한 의존성을 다운로드합니다. 프로젝트 클린(clean)과 재빌드(rebuild)를 실행하면 이전에 발생한 빌드 오류와 관련된 문제를 해결할 수 있습니다. 이는 캐시된 클래스 파일이나 의존성이 변경되어 다시 다운로드되고 빌드되기 때문입니다. clean으로 재빌드 하니, 정상 작동한다. ",
    "url": "/docs/projects/pongdang/230702/#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B9%8C%EB%93%9C-%ED%9B%84-servletservice-for-sevlet-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D-%EC%8B%9C",
    
    "relUrl": "/docs/projects/pongdang/230702/#1-프로젝트-빌드-후-servletservice-for-sevlet-오류-발생-시"
  },"57": {
    "doc": "제작 일지 <1>",
    "title": "2. 스프링부트 스냅샷 실행 시",
    "content": "nohup이 작동하지 않는다. java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log . 없이는 정상 작동한다. 3. 동기화 순서 . | ./gradlew clean build | pkill -f Pongdang_Server2-0.0.1-SNAPSHOT.jar | java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log &amp; | . ",
    "url": "/docs/projects/pongdang/230702/#2-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%8B%A4%ED%96%89-%EC%8B%9C",
    
    "relUrl": "/docs/projects/pongdang/230702/#2-스프링부트-스냅샷-실행-시"
  },"58": {
    "doc": "제작 일지 <1>",
    "title": "제작 일지 <1>",
    "content": " ",
    "url": "/docs/projects/pongdang/230702/",
    
    "relUrl": "/docs/projects/pongdang/230702/"
  },"59": {
    "doc": "TIL (23-07-02)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230702/#til",
    
    "relUrl": "/docs/tils/230702/#til"
  },"60": {
    "doc": "TIL (23-07-02)",
    "title": "2023.07.02 (SUN)",
    "content": ". 📌 오늘의 TIL . | 💻 깃허브 블로그 제작 . | 프로젝트 메뉴 생성 및 퐁당 웹매거진 프로젝트 업로드 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 동기화 매뉴얼 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230702/#20230702-sun",
    
    "relUrl": "/docs/tils/230702/#20230702-sun"
  },"61": {
    "doc": "TIL (23-07-02)",
    "title": "TIL (23-07-02)",
    "content": " ",
    "url": "/docs/tils/230702/",
    
    "relUrl": "/docs/tils/230702/"
  },"62": {
    "doc": "제작 일지 <2>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;2&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230706/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-2",
    
    "relUrl": "/docs/projects/pongdang/230706/#퐁당-웹-매거진-프로젝트-제작-일지-2"
  },"63": {
    "doc": "제작 일지 <2>",
    "title": "2023.07.06 (THU)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230706/#20230706-thu",
    
    "relUrl": "/docs/projects/pongdang/230706/#20230706-thu"
  },"64": {
    "doc": "제작 일지 <2>",
    "title": "1. 메뉴 ul margin 없애기",
    "content": ".menu ul { width : 100%; list-style-type: none; display: flex; flex-direction: row; justify-content: space-around; padding-inline-start: 0; } .menu li { text-align: center; } . padding-inline-start로 왼쪽의 padding을 없애주었다. ",
    "url": "/docs/projects/pongdang/230706/#1-%EB%A9%94%EB%89%B4-ul-margin-%EC%97%86%EC%95%A0%EA%B8%B0",
    
    "relUrl": "/docs/projects/pongdang/230706/#1-메뉴-ul-margin-없애기"
  },"65": {
    "doc": "제작 일지 <2>",
    "title": "2. 기반 정리",
    "content": ". ",
    "url": "/docs/projects/pongdang/230706/#2-%EA%B8%B0%EB%B0%98-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/projects/pongdang/230706/#2-기반-정리"
  },"66": {
    "doc": "제작 일지 <2>",
    "title": "3. 이후 계획",
    "content": "css or js 라이버리를 사용하여, 슬라이드 및 애니메이션 효과를 적용하도록 한다. ",
    "url": "/docs/projects/pongdang/230706/#3-%EC%9D%B4%ED%9B%84-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/pongdang/230706/#3-이후-계획"
  },"67": {
    "doc": "제작 일지 <2>",
    "title": "제작 일지 <2>",
    "content": " ",
    "url": "/docs/projects/pongdang/230706/",
    
    "relUrl": "/docs/projects/pongdang/230706/"
  },"68": {
    "doc": "TIL (23-07-06)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230706/#til",
    
    "relUrl": "/docs/tils/230706/#til"
  },"69": {
    "doc": "TIL (23-07-06)",
    "title": "2023.07.06 (THU)",
    "content": ". 📌 오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 회의 | 오늘의 제작 일지 | . | . ✏️ 오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230706/#20230706-thu",
    
    "relUrl": "/docs/tils/230706/#20230706-thu"
  },"70": {
    "doc": "TIL (23-07-06)",
    "title": "TIL (23-07-06)",
    "content": " ",
    "url": "/docs/tils/230706/",
    
    "relUrl": "/docs/tils/230706/"
  },"71": {
    "doc": "과제 진행하기",
    "title": "과제 진행하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230711/",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/"
  },"72": {
    "doc": "과제 진행하기",
    "title": "2023.07.11 (TUE)",
    "content": ". 문제 : 프로그래머스 - LV2. 과제 진행하기 . ",
    "url": "/docs/codingtest/1day1coding/230711/#20230711-tue",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#20230711-tue"
  },"73": {
    "doc": "과제 진행하기",
    "title": "접근법",
    "content": "조건 . | 과제는 시작하기로 한 시각이 되면 시작 | 새로운 과제를 할 시간이면, 기존에 하고 있던 과제를 멈추고 새로운 과제를 시작 . | 만약, 과제를 끝낸 시각에 우선순위는, 새로 시작해야 하는 과제 &gt; 잠시 멈춰둔 과제 | . | 멈춰둔 과제는 가장 최근에 멈춘 과제부터 시작 | . 해결법 . | plans 배열을 시작 시간을 기준으로 정렬한다. | 스택을 활용하여 잠시 멈춘 과제를 넣는다. | 조건 우선순위에 맞게 코드를 구현한다. | . ",
    "url": "/docs/codingtest/1day1coding/230711/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#접근법"
  },"74": {
    "doc": "과제 진행하기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public String[] solution(String[][] plans) { String[] answer = new String[plans.length]; int answer_count = 0; Queue&lt;String&gt; q_name = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; q_time = new LinkedList&lt;&gt;(); // plans 정렬 Arrays.sort(plans, new Comparator&lt;String[]&gt;() { @Override public int compare(String[] arr1, String[] arr2) { String[] time1 = arr1[1].split(\":\"); String[] time2 = arr2[1].split(\":\"); int hourCompare = Integer.parseInt(time1[0]) - Integer.parseInt(time2[0]); int minuteCompare = Integer.parseInt(time1[1]) - Integer.parseInt(time2[1]); return hourCompare != 0 ? hourCompare : minuteCompare; } }); // 시작 시간 정하기 int curTime = toMin(plans[0]); // 현재 시각 String curPlan = plans[0][0]; // 현재 과제명 int remainTime = Integer.parseInt(plans[0][2]); // 현재 과제 남은 시간 int count = 1; // 대기 중인 과제 순서 Stack&lt;String&gt; s_String = new Stack&lt;&gt;(); // 잠시 멈춘 과제명 Stack&lt;Integer&gt; s_Int = new Stack&lt;&gt;(); // 잠시 멈춘 과제 남은 시간 // 진행 while (answer_count &lt; plans.length) { curTime++; remainTime--; if (remainTime == 0) { // 시간이 다 되면 answer[answer_count] = curPlan; answer_count++; curPlan = \"\"; if (curTime == toMin(plans[count])) { // 다음 과제 시간이라면 curPlan = plans[count][0]; remainTime = Integer.parseInt(plans[count][2]); count++; if (count == plans.length) { count = 0; } } else if (!s_String.empty()) { // 잠시 멈춘 과제가 있다면 curPlan = s_String.pop(); remainTime = s_Int.pop(); } } else if (curTime == toMin(plans[count])) { // 다음 과제를 시작해야 한다면 // 저장 if (!curPlan.equals(\"\")) { s_String.push(curPlan); s_Int.push(remainTime); } curPlan = plans[count][0]; remainTime = Integer.parseInt(plans[count][2]); count++; if (count == plans.length) { count = 0; } } } return answer; } public static int toMin(String[] strs) { String[] time = strs[1].split(\":\"); return Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]); } } . ",
    "url": "/docs/codingtest/1day1coding/230711/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230711/#결과-코드"
  },"75": {
    "doc": "TIL (23-07-11)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230711/#til",
    
    "relUrl": "/docs/tils/230711/#til"
  },"76": {
    "doc": "TIL (23-07-11)",
    "title": "2023.07.11 (TUE)",
    "content": ". 📌  오늘의 TIL . | 프로그래머스 자바 코딩테스트 강의 신청 | 😵‍💫 코테 연습 . | 과제 진행하기 | . | . 📔 To Do Plan . | 1일 1코테연습 | 퐁당 매거진 프로젝트 | ? 백엔드 오픈소스 프로젝트 | ? 게임 서버 제작 | . ✏️  오늘의 체크 사항 . | 운동 - 어깨 | . ",
    "url": "/docs/tils/230711/#20230711-tue",
    
    "relUrl": "/docs/tils/230711/#20230711-tue"
  },"77": {
    "doc": "TIL (23-07-11)",
    "title": "TIL (23-07-11)",
    "content": " ",
    "url": "/docs/tils/230711/",
    
    "relUrl": "/docs/tils/230711/"
  },"78": {
    "doc": "TIL (23-07-13)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230713/#til",
    
    "relUrl": "/docs/tils/230713/#til"
  },"79": {
    "doc": "TIL (23-07-13)",
    "title": "2023.07.13 (THU)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 연습 . | 과제 진행하기 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어깨 | . ",
    "url": "/docs/tils/230713/#20230713-thu",
    
    "relUrl": "/docs/tils/230713/#20230713-thu"
  },"80": {
    "doc": "TIL (23-07-13)",
    "title": "TIL (23-07-13)",
    "content": " ",
    "url": "/docs/tils/230713/",
    
    "relUrl": "/docs/tils/230713/"
  },"81": {
    "doc": "제작 일지 <3>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;3&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-3",
    
    "relUrl": "/docs/projects/pongdang/230713/#퐁당-웹-매거진-프로젝트-제작-일지-3"
  },"82": {
    "doc": "제작 일지 <3>",
    "title": "2023.07.13 (THU)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230713/#20230713-thu",
    
    "relUrl": "/docs/projects/pongdang/230713/#20230713-thu"
  },"83": {
    "doc": "제작 일지 <3>",
    "title": "1. Font CSS 적용",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#1-font-css-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/projects/pongdang/230713/#1-font-css-적용"
  },"84": {
    "doc": "제작 일지 <3>",
    "title": "2. 부트스트랩 라이브러리 적용",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/#2-%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/projects/pongdang/230713/#2-부트스트랩-라이브러리-적용"
  },"85": {
    "doc": "제작 일지 <3>",
    "title": "제작 일지 <3>",
    "content": " ",
    "url": "/docs/projects/pongdang/230713/",
    
    "relUrl": "/docs/projects/pongdang/230713/"
  },"86": {
    "doc": "TIL (23-07-17)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230717/#til",
    
    "relUrl": "/docs/tils/230717/#til"
  },"87": {
    "doc": "TIL (23-07-17)",
    "title": "2023.07.17 (MON)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 연습 . | 과제 진행하기 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230717/#20230717-mon",
    
    "relUrl": "/docs/tils/230717/#20230717-mon"
  },"88": {
    "doc": "TIL (23-07-17)",
    "title": "TIL (23-07-17)",
    "content": " ",
    "url": "/docs/tils/230717/",
    
    "relUrl": "/docs/tils/230717/"
  },"89": {
    "doc": "제작 일지 <4>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;4&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230717/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-4",
    
    "relUrl": "/docs/projects/pongdang/230717/#퐁당-웹-매거진-프로젝트-제작-일지-4"
  },"90": {
    "doc": "제작 일지 <4>",
    "title": "2023.07.17 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230717/#20230717-mon",
    
    "relUrl": "/docs/projects/pongdang/230717/#20230717-mon"
  },"91": {
    "doc": "제작 일지 <4>",
    "title": "1. 슬라이드",
    "content": ". 구현 코드 . import React, { useState } from 'react'; import \"./Slider.css\"; import Carousel from 'react-bootstrap/Carousel'; export default function Slider() { const [index, setIndex] = useState(0); const handleSelect = (selectedIndex) =&gt; { setIndex(selectedIndex); }; return ( &lt;Carousel activeIndex={index} onSelect={handleSelect}&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;/Carousel&gt; ); } . ",
    "url": "/docs/projects/pongdang/230717/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/projects/pongdang/230717/#1-슬라이드"
  },"92": {
    "doc": "제작 일지 <4>",
    "title": "제작 일지 <4>",
    "content": " ",
    "url": "/docs/projects/pongdang/230717/",
    
    "relUrl": "/docs/projects/pongdang/230717/"
  },"93": {
    "doc": "전력망을 둘로 나누기",
    "title": "과제 진행하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230719/#%EA%B3%BC%EC%A0%9C-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#과제-진행하기"
  },"94": {
    "doc": "전력망을 둘로 나누기",
    "title": "2023.07.19 (WED)",
    "content": ". 문제 : 프로그래머스 - LV2. 전력망을 둘로 나누기 . ",
    "url": "/docs/codingtest/1day1coding/230719/#20230719-wed",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#20230719-wed"
  },"95": {
    "doc": "전력망을 둘로 나누기",
    "title": "접근법",
    "content": "조건 및 설명 . | n개의 송전탑이 하나의 트리 형태로 연결 | 전선들 중 하나를 끊어서, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 한다. | 두 전력망의 송전탑 개수의 차이를 return | . 해결법 . | 모두 탐색을 해도 되는 문제기 때문에, BFS를 사용한다. | 매번 가장 작은 값을 저장한다. | 자른 기준으로, 두 개의 노드를 탐색하여 갯수를 센다. | . ",
    "url": "/docs/codingtest/1day1coding/230719/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#접근법"
  },"96": {
    "doc": "전력망을 둘로 나누기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int solution(int n, int[][] wires) { int answer = -1; public static boolean[] visited = new boolean[n]; for (int i = 0; i &lt; n; i ++) { } return answer; } public static int bfs(int start, boolean[] visited) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(start); // current node visited visited[start] = true; while(!q.isEmpty()) { int x = q.poll(); for (int i = 0; i &lt; visited.length; i++) { // ... } } } } . ",
    "url": "/docs/codingtest/1day1coding/230719/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/#결과-코드"
  },"97": {
    "doc": "전력망을 둘로 나누기",
    "title": "전력망을 둘로 나누기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230719/",
    
    "relUrl": "/docs/codingtest/1day1coding/230719/"
  },"98": {
    "doc": "(!) 경험치 - 정규식",
    "title": "(!)경험치 - 정규식",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230720/#%EA%B2%BD%ED%97%98%EC%B9%98---%EC%A0%95%EA%B7%9C%EC%8B%9D",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#경험치---정규식"
  },"99": {
    "doc": "(!) 경험치 - 정규식",
    "title": "2023.07.20 (THU)",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/230720/#20230720-thu",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#20230720-thu"
  },"100": {
    "doc": "(!) 경험치 - 정규식",
    "title": "코딩 테스트를 보았다.",
    "content": "쉬운 문제에서 나를 붙잡는 이슈가 생겨버렸다. ",
    "url": "/docs/codingtest/1day1coding/230720/#%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%B3%B4%EC%95%98%EB%8B%A4",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#코딩-테스트를-보았다"
  },"101": {
    "doc": "(!) 경험치 - 정규식",
    "title": "정규식…",
    "content": "나는 지금까지 정규식에 대해 그렇게 깊이 알고 있지 않았다. 그 문제 또한, 사실 정규식이 없어도 풀 수 있는 문제라고 생각하고 풀었지만, 나의 엄청난 무지로 인해 계속 집착하게 되었다.. 문제의 코드다. str.split(\".\"); . 내 생각 : 외 않되..? (ㅋㅋ) . 자세히 알아보기 위해서는 split 함수에 대해서 알아보자. public String[] split(String regex) // 옳게된 함수 public String[] split(String string) // 멍청한 나의 머리에서 나온.. 나는 매개변수로 단지 string을 기준으로 나누는 함수 정도로 알고 있었다. 하지만 매개변수는 정규식이었다. 정규식에서의 ”.”은 개행 문자(\\n)을 제외한 모든 문자를 나타내는 메타 문자이다. 그래서 코드가 작동하지 않은건 당연한 것이였다.. 때문에 이스케이프 문자를 사용하여 다음과 같이 수정해야 한다. str.split(\"\\\\.\"); . 이런 사소한 지식들은 경험치처럼 쌓이고 쌓여, 나의 레벨업을 돕는다.. ",
    "url": "/docs/codingtest/1day1coding/230720/#%EC%A0%95%EA%B7%9C%EC%8B%9D",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/#정규식"
  },"102": {
    "doc": "(!) 경험치 - 정규식",
    "title": "(!) 경험치 - 정규식",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230720/",
    
    "relUrl": "/docs/codingtest/1day1coding/230720/"
  },"103": {
    "doc": "TIL (23-07-20)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230720/#til",
    
    "relUrl": "/docs/tils/230720/#til"
  },"104": {
    "doc": "TIL (23-07-20)",
    "title": "2023.07.20 (THU)",
    "content": ". 📌  오늘의 TIL . | 😵‍💫 코테 피드백 . | (!) 경험치 - 정규식 | . | . ✏️  오늘의 체크 사항 . | 운동 - 등 | . ",
    "url": "/docs/tils/230720/#20230720-thu",
    
    "relUrl": "/docs/tils/230720/#20230720-thu"
  },"105": {
    "doc": "TIL (23-07-20)",
    "title": "TIL (23-07-20)",
    "content": " ",
    "url": "/docs/tils/230720/",
    
    "relUrl": "/docs/tils/230720/"
  },"106": {
    "doc": "TIL (23-07-25)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230725/#til",
    
    "relUrl": "/docs/tils/230725/#til"
  },"107": {
    "doc": "TIL (23-07-25)",
    "title": "2023.07.25 (TUE)",
    "content": ". 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230725/#20230725-tue",
    
    "relUrl": "/docs/tils/230725/#20230725-tue"
  },"108": {
    "doc": "TIL (23-07-25)",
    "title": "TIL (23-07-25)",
    "content": " ",
    "url": "/docs/tils/230725/",
    
    "relUrl": "/docs/tils/230725/"
  },"109": {
    "doc": "제작 일지 <5>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;5&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230725/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-5",
    
    "relUrl": "/docs/projects/pongdang/230725/#퐁당-웹-매거진-프로젝트-제작-일지-5"
  },"110": {
    "doc": "제작 일지 <5>",
    "title": "2023.07.25 (TUE)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230725/#20230725-tue",
    
    "relUrl": "/docs/projects/pongdang/230725/#20230725-tue"
  },"111": {
    "doc": "제작 일지 <5>",
    "title": "1. 슬라이드",
    "content": ". 구현 코드 . import React, { useState } from 'react'; import \"./Slider.css\"; import Carousel from 'react-bootstrap/Carousel'; export default function Slider() { const [index, setIndex] = useState(0); const handleSelect = (selectedIndex) =&gt; { setIndex(selectedIndex); }; return ( &lt;Carousel activeIndex={index} onSelect={handleSelect}&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;Carousel.Item&gt; &lt;img className=\"slideImage\" alt=\"slide_01\" src=\"/imgs/Main/Slider/Slider1.png\"/&gt; &lt;/Carousel.Item&gt; &lt;/Carousel&gt; ); } . ",
    "url": "/docs/projects/pongdang/230725/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/projects/pongdang/230725/#1-슬라이드"
  },"112": {
    "doc": "제작 일지 <5>",
    "title": "제작 일지 <5>",
    "content": " ",
    "url": "/docs/projects/pongdang/230725/",
    
    "relUrl": "/docs/projects/pongdang/230725/"
  },"113": {
    "doc": "TIL (23-07-31)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230731/#til",
    
    "relUrl": "/docs/tils/230731/#til"
  },"114": {
    "doc": "TIL (23-07-31)",
    "title": "2023.07.25 (MON)",
    "content": ". 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230731/#20230725-mon",
    
    "relUrl": "/docs/tils/230731/#20230725-mon"
  },"115": {
    "doc": "TIL (23-07-31)",
    "title": "TIL (23-07-31)",
    "content": " ",
    "url": "/docs/tils/230731/",
    
    "relUrl": "/docs/tils/230731/"
  },"116": {
    "doc": "제작 일지 <6>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;6&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230731/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-6",
    
    "relUrl": "/docs/projects/pongdang/230731/#퐁당-웹-매거진-프로젝트-제작-일지-6"
  },"117": {
    "doc": "제작 일지 <6>",
    "title": "2023.07.31 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230731/#20230731-mon",
    
    "relUrl": "/docs/projects/pongdang/230731/#20230731-mon"
  },"118": {
    "doc": "제작 일지 <6>",
    "title": "1. 슬라이드 재조정",
    "content": "사이드 버튼들을 투명화 시켜, 조금 더 자연스럽게 만들어 준다. ",
    "url": "/docs/projects/pongdang/230731/#1-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%9E%AC%EC%A1%B0%EC%A0%95",
    
    "relUrl": "/docs/projects/pongdang/230731/#1-슬라이드-재조정"
  },"119": {
    "doc": "제작 일지 <6>",
    "title": "제작 일지 <6>",
    "content": " ",
    "url": "/docs/projects/pongdang/230731/",
    
    "relUrl": "/docs/projects/pongdang/230731/"
  },"120": {
    "doc": "TIL (23-08-08)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230808/#til",
    
    "relUrl": "/docs/tils/230808/#til"
  },"121": {
    "doc": "TIL (23-08-08)",
    "title": "2023.08.08 (TUE)",
    "content": ". 📔 To Do . | 1일 1코테연습 | 책 “오브젝트” | 퐁당 매거진 프로젝트 | . 📌  오늘의 TIL . | !! | . ✏️  오늘의 체크 사항 . | 운동 - 어꺠 | . ",
    "url": "/docs/tils/230808/#20230808-tue",
    
    "relUrl": "/docs/tils/230808/#20230808-tue"
  },"122": {
    "doc": "TIL (23-08-08)",
    "title": "TIL (23-08-08)",
    "content": " ",
    "url": "/docs/tils/230808/",
    
    "relUrl": "/docs/tils/230808/"
  },"123": {
    "doc": "TIL (23-08-16)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230816/#til",
    
    "relUrl": "/docs/tils/230816/#til"
  },"124": {
    "doc": "TIL (23-08-16)",
    "title": "2023.08.08 (WED)",
    "content": ". 📔 To Do . | 1일 1코테연습 | 퐁당 매거진 프로젝트 | AWS 자격증 시험 | 책 “오브젝트” | . 📌  오늘의 TIL . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . ✏️  오늘의 체크 사항 . | 운동 - 가슴 | . ",
    "url": "/docs/tils/230816/#20230808-wed",
    
    "relUrl": "/docs/tils/230816/#20230808-wed"
  },"125": {
    "doc": "TIL (23-08-16)",
    "title": "TIL (23-08-16)",
    "content": " ",
    "url": "/docs/tils/230816/",
    
    "relUrl": "/docs/tils/230816/"
  },"126": {
    "doc": "제작 일지 <7>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;7&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230816/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-7",
    
    "relUrl": "/docs/projects/pongdang/230816/#퐁당-웹-매거진-프로젝트-제작-일지-7"
  },"127": {
    "doc": "제작 일지 <7>",
    "title": "2023.08.16 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230816/#20230816-wed",
    
    "relUrl": "/docs/projects/pongdang/230816/#20230816-wed"
  },"128": {
    "doc": "제작 일지 <7>",
    "title": "1. 메인페이지 1차 완성",
    "content": ". | 퐁당 매거진 홈페이지 | . 전체적으로 사이즈를 키웠고, 요구사항에 맞는 디자인을 하였다. 새롭게 깨달은 점은, 리액트에서 컴포넌트를 모을 때, ClassName을 다른 모듈이더라도 같은 이름을 쓰면 안된다는 것이였다. 이것 때문에 충돌나서 헤맸던 적이.. ",
    "url": "/docs/projects/pongdang/230816/#1-%EB%A9%94%EC%9D%B8%ED%8E%98%EC%9D%B4%EC%A7%80-1%EC%B0%A8-%EC%99%84%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/230816/#1-메인페이지-1차-완성"
  },"129": {
    "doc": "제작 일지 <7>",
    "title": "제작 일지 <7>",
    "content": " ",
    "url": "/docs/projects/pongdang/230816/",
    
    "relUrl": "/docs/projects/pongdang/230816/"
  },"130": {
    "doc": "이론 일지 <1>",
    "title": "토이 프로젝트 - 게임 서버 - 이론 일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/230819/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%EC%9D%B4%EB%A1%A0-%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/gameServer/230819/#토이-프로젝트---게임-서버---이론-일지-1"
  },"131": {
    "doc": "이론 일지 <1>",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230819/#20230819-sat",
    
    "relUrl": "/docs/projects/gameServer/230819/#20230819-sat"
  },"132": {
    "doc": "이론 일지 <1>",
    "title": "1. 프로세스",
    "content": "프로그램에 있는 코드와 데이터를 프로세스 메모리로 불러들이는데, 이를 로딩된다고 할 수 있다. 프로세스는 RAM에 있다. 프로세스가 여러 개 실행되고 있는 것을 멀티프로세싱이라고 한다. ",
    "url": "/docs/projects/gameServer/230819/#1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4",
    
    "relUrl": "/docs/projects/gameServer/230819/#1-프로세스"
  },"133": {
    "doc": "이론 일지 <1>",
    "title": "2. 스레드",
    "content": "기본 적으로 서로 다른 프로세스는 상대방의 메모리 공간을 읽고 쓸 수 없다. 하미잔, 한 프로세스 안에 있는 스레드들은, 프로세스 안에 있는 메모리 공간을 같이 사용할 수 있다. 스레드 = 프로그램이 실행되는 기본 단위 . ",
    "url": "/docs/projects/gameServer/230819/#2-%EC%8A%A4%EB%A0%88%EB%93%9C",
    
    "relUrl": "/docs/projects/gameServer/230819/#2-스레드"
  },"134": {
    "doc": "이론 일지 <1>",
    "title": "이론 일지 <1>",
    "content": " ",
    "url": "/docs/projects/gameServer/230819/",
    
    "relUrl": "/docs/projects/gameServer/230819/"
  },"135": {
    "doc": "숫자 게임",
    "title": "숫자 게임",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230819/",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/"
  },"136": {
    "doc": "숫자 게임",
    "title": "2023.08.19 (SAT)",
    "content": ". 문제 : 프로그래머스 - LV3. 숫자 게임 . ",
    "url": "/docs/codingtest/1day1coding/230819/#20230819-sat",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#20230819-sat"
  },"137": {
    "doc": "숫자 게임",
    "title": "조건 및 설명",
    "content": ". | N명의 팀원 | . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#조건-및-설명"
  },"138": {
    "doc": "숫자 게임",
    "title": "접근법",
    "content": ". | 남은 팀원들 중, 최소한의 숫자로 이길 수 있는 사람으로 대려감 | 두 배열을 Sort 후, 앞에서부터 서로 비교하여 count | . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#접근법"
  },"139": {
    "doc": "숫자 게임",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int solution(int[] A, int[] B) { int answer = 0; int count = 0; Arrays.sort(A); Arrays.sort(B); // Game Start for (int i = 0; i &lt; A.length; i++) { for (int j = count; j &lt; A.length; j++) { if (A[i] &lt; B[j]) { // 이기면 answer++; count++; break; } else { // 비기거나 지면 count++; } } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/230819/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230819/#결과-코드"
  },"140": {
    "doc": "TIL (23-08-19)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230819/#til",
    
    "relUrl": "/docs/tils/230819/#til"
  },"141": {
    "doc": "TIL (23-08-19)",
    "title": "2023.08.19 (SAT)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | 숫자 게임 | . | AWS 자격증 시험 | 책 “오브젝트” | 퐁당 매거진 프로젝트 (업로드 사항 있을 경우) | . 😄 Want To Do (하고 싶은 것) . | 게임 서버 개발 . | 프로젝트 계획 | . | 마인크래프트 코드 개조 해보기 | 깃헙 블로그 포트폴리오 | 지원서 넣기 | . ",
    "url": "/docs/tils/230819/#20230819-sat",
    
    "relUrl": "/docs/tils/230819/#20230819-sat"
  },"142": {
    "doc": "TIL (23-08-19)",
    "title": "TIL (23-08-19)",
    "content": " ",
    "url": "/docs/tils/230819/",
    
    "relUrl": "/docs/tils/230819/"
  },"143": {
    "doc": "프로젝트 계획",
    "title": "토이 프로젝트 - 게임 서버 - 프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230819_2/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#토이-프로젝트---게임-서버---프로젝트-계획"
  },"144": {
    "doc": "프로젝트 계획",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230819_2/#20230819-sat",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#20230819-sat"
  },"145": {
    "doc": "프로젝트 계획",
    "title": "프레임워크",
    "content": "서버(스프링부트) + 게임 프레임워크(LibGDX, 일단 써보기) . ",
    "url": "/docs/projects/gameServer/230819_2/#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#프레임워크"
  },"146": {
    "doc": "프로젝트 계획",
    "title": "순서",
    "content": ". | 스프링 부트 프로젝트 생성: 우선 스프링 부트 프로젝트를 생성합니다. Spring Initializr를 이용하면 간단하게 프로젝트를 생성할 수 있습니다. https://start.spring.io/ | 게임 개발 프레임워크 선택: 자바 게임 개발에서는 여러 가지 프레임워크와 라이브러리를 사용할 수 있습니다. 대표적인 예로는 LibGDX, jMonkeyEngine, LWJGL 등이 있습니다. 이 중에서 가장 인기 있는 LibGDX를 선택하고 해당 라이브러리를 스프링 부트 프로젝트에 포함시킵니다. | 게임 API 연결: 선택한 게임 프레임워크의 API를 스프링 부트에 연결합니다. 이를 위해서는 라이브러리를 확인하고 관련 API 연동 방법을 찾아보는 것이 좋습니다. | 게임 서버 개발: 스프링 부트를 이용하여 게임 서버를 구현합니다. 게임 프레임워크에서 제공하는 서버 기능을 활용하여 스프링 부트 서버와 연동합니다. | 게임 클라이언트 개발: 게임 클라이언트에서는 개발한 스프링 부트 서버와 통신하여 게임을 실행합니다. HTTP와 WebSocket을 이용하여 통신할 수 있습니다. | 요청과 응답 처리: 게임 클라이언트에서 서버로 요청을 보내고, 서버에서는 그에 대한 응답을 처리합니다. 스프링 부트에서 HTTP 요청 및 WebSocket 연결을 처리하는 Controller를 개발하면 됩니다. 이러한 방법으로 스프링 부트와 자바 게임 개발을 연결할 수 있습니다. 하지만, 이는 어려운 작업이므로 충분한 경험과 지식이 필요합니다. 또한, 자바 게임 개발과 스프링 부트가 서로 다른 도메인이므로 그에 따른 요구사항과 성능 이슈 등을 고려해야 합니다. | . ",
    "url": "/docs/projects/gameServer/230819_2/#%EC%88%9C%EC%84%9C",
    
    "relUrl": "/docs/projects/gameServer/230819_2/#순서"
  },"147": {
    "doc": "프로젝트 계획",
    "title": "프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230819_2/",
    
    "relUrl": "/docs/projects/gameServer/230819_2/"
  },"148": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "토이 프로젝트 - 게임 서버 - 프로젝트 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/230822/#토이-프로젝트---게임-서버---프로젝트-계획"
  },"149": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "2023.08.22 (TUE)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230822/#20230822-tue",
    
    "relUrl": "/docs/projects/gameServer/230822/#20230822-tue"
  },"150": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "기본 세팅 끝",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/#%EA%B8%B0%EB%B3%B8-%EC%84%B8%ED%8C%85-%EB%81%9D",
    
    "relUrl": "/docs/projects/gameServer/230822/#기본-세팅-끝"
  },"151": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "개발 순서 설계",
    "content": ". | 맵, 플레이어 만들기 | 서버 연결 (2023.08.24 ~) | . ",
    "url": "/docs/projects/gameServer/230822/#%EA%B0%9C%EB%B0%9C-%EC%88%9C%EC%84%9C-%EC%84%A4%EA%B3%84",
    
    "relUrl": "/docs/projects/gameServer/230822/#개발-순서-설계"
  },"152": {
    "doc": "GDX 프로젝트 생성 및 개발 시작",
    "title": "GDX 프로젝트 생성 및 개발 시작",
    "content": " ",
    "url": "/docs/projects/gameServer/230822/",
    
    "relUrl": "/docs/projects/gameServer/230822/"
  },"153": {
    "doc": "TIL (23-08-24)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230824/#til",
    
    "relUrl": "/docs/tils/230824/#til"
  },"154": {
    "doc": "TIL (23-08-24)",
    "title": "2023.08.24 (SAT)",
    "content": ". 📔 To Do (반드시!!) . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . | 게임 서버 개발 . | 프로젝트 계획 | . | . ",
    "url": "/docs/tils/230824/#20230824-sat",
    
    "relUrl": "/docs/tils/230824/#20230824-sat"
  },"155": {
    "doc": "TIL (23-08-24)",
    "title": "TIL (23-08-24)",
    "content": " ",
    "url": "/docs/tils/230824/",
    
    "relUrl": "/docs/tils/230824/"
  },"156": {
    "doc": "One Walk",
    "title": "One Walk",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230830/",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/"
  },"157": {
    "doc": "One Walk",
    "title": "2023.08.19 (SAT)",
    "content": ". 문제 : 백준 - 29333. One Walk . ",
    "url": "/docs/codingtest/1day1coding/230830/#20230819-sat",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#20230819-sat"
  },"158": {
    "doc": "One Walk",
    "title": "조건 및 설명",
    "content": ". | 무방향 단순 그래프 G | 주어지는 변수 : 정점의 개수 N, 간선의 개수 M, 시작점 번호 S, 도착점 번호 E | 그 다음은 M개의 줄에서 간선으로 연결된 두 정점의 번호(u,v)가 주어진다. | 단 하나가 되도록 만들 수 없다면 -1을 출력, 그렇지 않으면 모든 간선의 방향을 입력된 순서대로 한 줄에 출력 (u -&gt; v : 0, v -&gt; u : 1) | . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#조건-및-설명"
  },"159": {
    "doc": "One Walk",
    "title": "접근법",
    "content": ". | 시작점부터 시작하여, 도착점까지 한 가지만 나오는 경우를 탐색한다. | 이럴 때는, | . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#접근법"
  },"160": {
    "doc": "One Walk",
    "title": "결과 코드",
    "content": "import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { int N, M, S, E; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); M = Integer.parseInt(st.nextToken()); S = Integer.parseInt(st.nextToken()) - 1; E = Integer.parseInt(st.nextToken()) - 1; int[] answer = new int[M]; int[][] edge = new int[M][2]; for (int i = 0; i &lt; M; i++) { st = new StringTokenizer(br.readLine()); edge[i][0] = Integer.parseInt(st.nextToken()) - 1; edge[i][1] = Integer.parseInt(st.nextToken()) - 1; } } } . ",
    "url": "/docs/codingtest/1day1coding/230830/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230830/#결과-코드"
  },"161": {
    "doc": "TIL (23-08-30)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230830/#til",
    
    "relUrl": "/docs/tils/230830/#til"
  },"162": {
    "doc": "TIL (23-08-30)",
    "title": "2023.08.30 (WED)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | 입력 할 때는, Scanner보다 BufferedReader가 훨씬 빠르다! . | BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); . | . | . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230830/#20230830-wed",
    
    "relUrl": "/docs/tils/230830/#20230830-wed"
  },"163": {
    "doc": "TIL (23-08-30)",
    "title": "TIL (23-08-30)",
    "content": " ",
    "url": "/docs/tils/230830/",
    
    "relUrl": "/docs/tils/230830/"
  },"164": {
    "doc": "TIL (23-09-01)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230901/#til",
    
    "relUrl": "/docs/tils/230901/#til"
  },"165": {
    "doc": "TIL (23-09-01)",
    "title": "2023.09.01 (FRI)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230901/#20230901-fri",
    
    "relUrl": "/docs/tils/230901/#20230901-fri"
  },"166": {
    "doc": "TIL (23-09-01)",
    "title": "TIL (23-09-01)",
    "content": " ",
    "url": "/docs/tils/230901/",
    
    "relUrl": "/docs/tils/230901/"
  },"167": {
    "doc": "TIL (23-09-04)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230904/#til",
    
    "relUrl": "/docs/tils/230904/#til"
  },"168": {
    "doc": "TIL (23-09-04)",
    "title": "2023.09.04 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 - 1 | 기본 요약 - 2 | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230904/#20230904-mon",
    
    "relUrl": "/docs/tils/230904/#20230904-mon"
  },"169": {
    "doc": "TIL (23-09-04)",
    "title": "TIL (23-09-04)",
    "content": " ",
    "url": "/docs/tils/230904/",
    
    "relUrl": "/docs/tils/230904/"
  },"170": {
    "doc": "TIL (23-09-04)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230905/#til",
    
    "relUrl": "/docs/tils/230905/#til"
  },"171": {
    "doc": "TIL (23-09-04)",
    "title": "2023.09.04 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 1일 1코테연습 . | One Walk | . | AWS 자격증 시험 . | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230905/#20230904-mon",
    
    "relUrl": "/docs/tils/230905/#20230904-mon"
  },"172": {
    "doc": "TIL (23-09-04)",
    "title": "TIL (23-09-04)",
    "content": " ",
    "url": "/docs/tils/230905/",
    
    "relUrl": "/docs/tils/230905/"
  },"173": {
    "doc": "제작 일지 <8>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;8&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/230906/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-8",
    
    "relUrl": "/docs/projects/pongdang/230906/#퐁당-웹-매거진-프로젝트-제작-일지-8"
  },"174": {
    "doc": "제작 일지 <8>",
    "title": "2023.09.07 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/230906/#20230907-wed",
    
    "relUrl": "/docs/projects/pongdang/230906/#20230907-wed"
  },"175": {
    "doc": "제작 일지 <8>",
    "title": "1. 라우팅 처리",
    "content": "스프링부트와 리액트를 함꼐 쓰는 중에, 다른 페이지로 가기 위한 라우팅을 해야할 때가 왔다. 1-1. 리액트 . 리액트에서는 컴포넌트로 나누어 App.js에서 라우팅 처리를 한다. function App() { return ( &lt;BrowserRouter&gt; &lt;div className=\"App\"&gt; &lt;Route path=\"/\" exact component={Main}&gt;&lt;/Route&gt; &lt;Route path=\"/test\" component={Test}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ); } . 1-2. 스프링부트 . 로컬에서는 ‘/’, ‘/test’ 모두 접속이 가능하다. 하지만 스프링부트에 연결한 서버에 접속하면, ‘/test’엔 접속이 되지 않고 404에러가 나온다. Controller를 사용하면 이 문제가 해결된다. 일단 임시로 모든 경로를 연결해준다. @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } } . ",
    "url": "/docs/projects/pongdang/230906/#1-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/projects/pongdang/230906/#1-라우팅-처리"
  },"176": {
    "doc": "제작 일지 <8>",
    "title": "제작 일지 <8>",
    "content": " ",
    "url": "/docs/projects/pongdang/230906/",
    
    "relUrl": "/docs/projects/pongdang/230906/"
  },"177": {
    "doc": "적록색약",
    "title": "적록색약",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230911/",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/"
  },"178": {
    "doc": "적록색약",
    "title": "2023.09.11 (MON)",
    "content": ". 문제 : 백준 - 10026. 적록색약 . ",
    "url": "/docs/codingtest/1day1coding/230911/#20230911-mon",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#20230911-mon"
  },"179": {
    "doc": "적록색약",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230911/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#조건-및-설명"
  },"180": {
    "doc": "적록색약",
    "title": "접근법",
    "content": ". | 두 가지(색약, 색약이 아닌)으로 나눈다. | BFS로 한 구역씩 정한다. | . ",
    "url": "/docs/codingtest/1day1coding/230911/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#접근법"
  },"181": {
    "doc": "적록색약",
    "title": "결과 코드",
    "content": "import java.util.*; import java.io.*; public class Main { static char[][] map; static boolean[][] visited; static ArrayDeque&lt;Char&gt; queue = new ArrayDeque&lt;&gt;(); static int no_Cb = 0; static int yes_Cb = 0; public static void main(String[] args) throws Exception { int size; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); size = Integer.parseInt(st.nextToken()); // input size // init map = new char[size][size]; bvisited = new boolean[size][size]; // input for (int i = 0; i &lt; size; i++) { st = new StringTokenizer(br.readLine()); String str = st.nextToken(); for (int j = 0; j &lt; size; j++) { map[i][j] = str.charAt(j); visited[i][j] = false; } } } // 1. no Color blindness public static int bfs_no(int start_x, int start_y char[][] map, boolean[][] visited) { visited[start_x][start_y] = true; queue.add(map[start_x][start_y]); while (!queue.isEmpty()) { char ch = queue.poll(); } } } . ",
    "url": "/docs/codingtest/1day1coding/230911/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230911/#결과-코드"
  },"182": {
    "doc": "TIL (23-09-11)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230911/#til",
    
    "relUrl": "/docs/tils/230911/#til"
  },"183": {
    "doc": "TIL (23-09-11)",
    "title": "2023.09.11 (MON)",
    "content": ". 📔 To Do (반드시!!) . | 😵‍💫 1일 1코테연습 . | 적록색약 | . | 🧑‍💻 퐁당 웹페이지 Ver.02 . | 오늘의 제작 일지 | . | . 😄 Want To Do (하고 싶은 것) . | AWS 워크샵 강의 . | AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기 | . | . ",
    "url": "/docs/tils/230911/#20230911-mon",
    
    "relUrl": "/docs/tils/230911/#20230911-mon"
  },"184": {
    "doc": "TIL (23-09-11)",
    "title": "TIL (23-09-11)",
    "content": " ",
    "url": "/docs/tils/230911/",
    
    "relUrl": "/docs/tils/230911/"
  },"185": {
    "doc": "TIL (23-09-12)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230912/#til",
    
    "relUrl": "/docs/tils/230912/#til"
  },"186": {
    "doc": "TIL (23-09-12)",
    "title": "2023.09.12 (TUE)",
    "content": ". 📔 To Do (반드시!!) . | AWS 자격증 시험 . | 기본 요약 - 3 | . | . 😄 Want To Do (하고 싶은 것) . ",
    "url": "/docs/tils/230912/#20230912-tue",
    
    "relUrl": "/docs/tils/230912/#20230912-tue"
  },"187": {
    "doc": "TIL (23-09-12)",
    "title": "TIL (23-09-12)",
    "content": " ",
    "url": "/docs/tils/230912/",
    
    "relUrl": "/docs/tils/230912/"
  },"188": {
    "doc": "TIL (23-09-13)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230913/#til",
    
    "relUrl": "/docs/tils/230913/#til"
  },"189": {
    "doc": "TIL (23-09-13)",
    "title": "2023.09.13 (WED)",
    "content": ". AWS 자격증 시험 . SAA에서 DA로 변경하였다. 아무래도 지금 프로젝트와 직무 연관성이 DA쪽이 더 높은 것 같다고 판단하였다. 강의는 Udemy에서 제공하는 강사 스테판 마렉 (Stephane Maarek)의 AWS 자격증 강의이다. 평이 매우 좋고, 프리뷰를 봤는데 매우 호감이었다! . 글로벌 서비스는 리전 선택이 나오지 않는 것이 정상. EC2와 같은 서비스는 리전 선택이 필수. 또한, AWS의 모든 서비스는 모든 리전에 존재하는 것이 아니다. ",
    "url": "/docs/tils/230913/#20230913-wed",
    
    "relUrl": "/docs/tils/230913/#20230913-wed"
  },"190": {
    "doc": "TIL (23-09-13)",
    "title": "TIL (23-09-13)",
    "content": " ",
    "url": "/docs/tils/230913/",
    
    "relUrl": "/docs/tils/230913/"
  },"191": {
    "doc": "TIL (23-09-14)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230914/#til",
    
    "relUrl": "/docs/tils/230914/#til"
  },"192": {
    "doc": "TIL (23-09-14)",
    "title": "2023.09.14 (THU)",
    "content": ". IAM: Users &amp; Groups . | IAM에서는 사용자를 생성하고 그룹에 배치하기 때문에, 글로벌 서비스이다. | 루트 어카운트는 기본으로 만들어진다. 이후, 루트는 사용되거나 공유되면 안된다. | 사용자와 그룹을 만들어 사용한다. | . ",
    "url": "/docs/tils/230914/#20230914-thu",
    
    "relUrl": "/docs/tils/230914/#20230914-thu"
  },"193": {
    "doc": "TIL (23-09-14)",
    "title": "TIL (23-09-14)",
    "content": " ",
    "url": "/docs/tils/230914/",
    
    "relUrl": "/docs/tils/230914/"
  },"194": {
    "doc": "ATM",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230915/",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/"
  },"195": {
    "doc": "ATM",
    "title": "2023.09.15 (FRI)",
    "content": ". 문제 : 백준 - 11399. ATM . ",
    "url": "/docs/codingtest/1day1coding/230915/#20230915-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#20230915-fri"
  },"196": {
    "doc": "ATM",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230915/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#조건-및-설명"
  },"197": {
    "doc": "ATM",
    "title": "접근법",
    "content": ". | 그리디를 사용하여 작은 숫자부터 Sort한 후, 계산한다. | . ",
    "url": "/docs/codingtest/1day1coding/230915/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#접근법"
  },"198": {
    "doc": "ATM",
    "title": "결과 코드",
    "content": "/* * Title : ATM * Link : https://www.acmicpc.net/problem/11399 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { int size; int arr[]; int answer = 0; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); size = Integer.parseInt(st.nextToken()); arr = new int[size]; st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; size; i++) { arr[i] = Integer.parseInt(st.nextToken()); } // sort Arrays.sort(arr); // sum for (int i = 0; i &lt; size; i++) { answer += arr[i] * (size - i); } System.out.println(answer); } } . ",
    "url": "/docs/codingtest/1day1coding/230915/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230915/#결과-코드"
  },"199": {
    "doc": "상근이의 여행",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/#atm",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#atm"
  },"200": {
    "doc": "상근이의 여행",
    "title": "2023.09.17 (SUN)",
    "content": ". 문제 : 백준 - 9372. 상근이의 여행 . ",
    "url": "/docs/codingtest/1day1coding/230917/#20230917-sun",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#20230917-sun"
  },"201": {
    "doc": "상근이의 여행",
    "title": "조건 및 설명",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#조건-및-설명"
  },"202": {
    "doc": "상근이의 여행",
    "title": "접근법",
    "content": "1. 인접리스트로 그래프를 구현하고 2. 신장 트리로 최소 비용을 구한다. | 사실 이 문제는, 입력된 그래프가 항상 연결 그래프이므로 국가 - 1가 정답이다. | . ",
    "url": "/docs/codingtest/1day1coding/230917/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#접근법"
  },"203": {
    "doc": "상근이의 여행",
    "title": "결과 코드",
    "content": "/* * Title : 상근이의 여행 * Link : https://www.acmicpc.net/problem/9372 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; // input int tc = Integer.parseInt(br.readLine()); // each TestCase for (int t = 0; t &lt; tc; t++) { st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // number of countries int M = Integer.parseInt(st.nextToken()); // number of planes for (int i = 0; i &lt; M; i++) { br.readLine(); // we don't need to process the plane information for this problem. } System.out.println(N-1); // the minimum number of planes Sanggeun needs to take is always N-1. } } } . ",
    "url": "/docs/codingtest/1day1coding/230917/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/#결과-코드"
  },"204": {
    "doc": "상근이의 여행",
    "title": "상근이의 여행",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230917/",
    
    "relUrl": "/docs/codingtest/1day1coding/230917/"
  },"205": {
    "doc": "TIL (23-09-17)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230917/#til",
    
    "relUrl": "/docs/tils/230917/#til"
  },"206": {
    "doc": "TIL (23-09-17)",
    "title": "2023.09.17 (SUN)",
    "content": ". 그래프 - 인접 리스트 . /* * Title : 상근이의 여행 * Link : https://www.acmicpc.net/problem/9372 */ import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int result[]; // input int tc = Integer.parseInt(br.readLine()); result = new int[tc]; // each TestCase for (int t = 0; t &lt; tc; t++) { int answer = Integer.MAX_VALUE; st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); // input &amp; 인접 리스트 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= N; i++) graph.add(new ArrayList&lt;&gt;()); // 각 노드 별 리스트를 만든다. for (int i = 0; i &lt; M; i++) { // make graph st = new StringTokenizer(br.readLine()); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); putEdge(graph, x, y); } for (int i = 0; i &lt; N ; i++) { int check = checkEdge(graph, i); if (check &lt; answer) { answer = check; } } result[t] = answer; } for (int r:result) System.out.println(r); } public static void putEdge(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, int x, int y) { graph.get(x).add(y); graph.get(y).add(x); } public static int checkEdge(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, int x) { } } . 그래프를 표현할 때, 가장 효율적인 방법인 듯 . 신장 트리 / 최소 신장 트리 (MST) . 신장 트리란 : 그래프의 모든 정점을 사이클 없이 잇는 트리 . 최소 신장 트리 : 신장 트리에서 간선의 가중치의 합이 최소가 되는 트리 . MST는 내일 다루도록 해보고, 오늘은 신장트리를 구현하였다. | 신장트리 알고리즘 문제 . | 입력된 그래프가 항상 연결 그래프이면 정점 - 1가 정답이다. | . ",
    "url": "/docs/tils/230917/#20230917-sun",
    
    "relUrl": "/docs/tils/230917/#20230917-sun"
  },"207": {
    "doc": "TIL (23-09-17)",
    "title": "TIL (23-09-17)",
    "content": " ",
    "url": "/docs/tils/230917/",
    
    "relUrl": "/docs/tils/230917/"
  },"208": {
    "doc": "TIL (23-09-18)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230918/#til",
    
    "relUrl": "/docs/tils/230918/#til"
  },"209": {
    "doc": "TIL (23-09-18)",
    "title": "2023.09.18 (MON)",
    "content": ". Message Broker . 애플리케이션, 시스템 및 서비스가 서로 간에 통신하고 정보를 교환할 수 있도록 해주는 SW . | 상호 의존적인 서비스들이 서로 다른 언어나 플랫폼으로 개발된 경우에도 통신이 가능해진다. | 메시지를 검증, 저장, 라우팅하고 이를 적절한 대상에 전달할 수 있음 | 메시지 큐를 이용함 | . ",
    "url": "/docs/tils/230918/#20230918-mon",
    
    "relUrl": "/docs/tils/230918/#20230918-mon"
  },"210": {
    "doc": "TIL (23-09-18)",
    "title": "TIL (23-09-18)",
    "content": " ",
    "url": "/docs/tils/230918/",
    
    "relUrl": "/docs/tils/230918/"
  },"211": {
    "doc": "웹 소켓 프로그래밍",
    "title": "웹 소켓 프로그래밍",
    "content": " ",
    "url": "/docs/projects/gameServer/230920/",
    
    "relUrl": "/docs/projects/gameServer/230920/"
  },"212": {
    "doc": "웹 소켓 프로그래밍",
    "title": "2023.09.20 (WED)",
    "content": ". ",
    "url": "/docs/projects/gameServer/230920/#20230920-wed",
    
    "relUrl": "/docs/projects/gameServer/230920/#20230920-wed"
  },"213": {
    "doc": "웹 소켓 프로그래밍",
    "title": "웹 소켓 프로그래밍",
    "content": "P . ",
    "url": "/docs/projects/gameServer/230920/",
    
    "relUrl": "/docs/projects/gameServer/230920/"
  },"214": {
    "doc": "TIL (23-09-21)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230921/#til",
    
    "relUrl": "/docs/tils/230921/#til"
  },"215": {
    "doc": "TIL (23-09-21)",
    "title": "2023.09.21 (THU)",
    "content": ". EC2 접속 시, 타임아웃 . 거의 99확률로, 보안그룹 때문이다. 인바운드 및 아웃바운드 규칙을 확인하자. EC2 콘솔에서 IAM 유저를 확인할 때, . $ aws iam list-users Unable to locate credentials. You can configure credentials by running \"aws configure\". 유저를 확인하려면, ‘aws configure’을 실행시키라고 나온다. 그래서 실행 시켜보면, . $ aws configure AWS Access Key ID [None]: AWS Secret Access Key [None]: Default region name [None]: Default output format [None]: . 라고 나오면서, 비밀 Access 키를 입력하라고 나온다… . ",
    "url": "/docs/tils/230921/#20230921-thu",
    
    "relUrl": "/docs/tils/230921/#20230921-thu"
  },"216": {
    "doc": "TIL (23-09-21)",
    "title": "절대 IAM API 키를 직접 입력하지 않는다.",
    "content": ". | 자격 증명 정보를 누군가 EC2에 접속하여 회수할 수 있다. | . ",
    "url": "/docs/tils/230921/#%EC%A0%88%EB%8C%80-iam-api-%ED%82%A4%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%9E%85%EB%A0%A5%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4",
    
    "relUrl": "/docs/tils/230921/#절대-iam-api-키를-직접-입력하지-않는다"
  },"217": {
    "doc": "TIL (23-09-21)",
    "title": "TIL (23-09-21)",
    "content": " ",
    "url": "/docs/tils/230921/",
    
    "relUrl": "/docs/tils/230921/"
  },"218": {
    "doc": "보디빌딩",
    "title": "ATM",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/#atm",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#atm"
  },"219": {
    "doc": "보디빌딩",
    "title": "2023.09.22 (FRI)",
    "content": ". 문제 : 백준 - 27952. 보디빌딩 . ",
    "url": "/docs/codingtest/1day1coding/230922/#20230922-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#20230922-fri"
  },"220": {
    "doc": "보디빌딩",
    "title": "조건 및 설명",
    "content": ". | 루틴을 진행할 떄마다, 몸무게가 Xkg 만큼 빠진다. | 이 루틴을 하루에 여러번 가능 | . | 보디빌딩이 남은 N일 동안, 식단으로 i번째 날에 Bikg만큼 찐다. | 최소 몸무게가 Aikg 이상이어야 한다. | . ",
    "url": "/docs/codingtest/1day1coding/230922/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#조건-및-설명"
  },"221": {
    "doc": "보디빌딩",
    "title": "접근법",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#접근법"
  },"222": {
    "doc": "보디빌딩",
    "title": "결과 코드",
    "content": "/* * Title : 보디빌딩 * Link : https://www.acmicpc.net/problem/27952 */ import java.io.*; import java.util.*; public class Main { private static int N; // 보디빌딩 대회까지 남은 일수 private static int X; // 루틴을 진행할 떄마다 빠지는 몸무게 private static int[] A; // i번째 날 최종 몸무게의 하한 private static int[] B; // i번째 날에 늘어나는 몸무게 public static void main(String[] args) throws Exception { int answer = 0; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int current_weight = 0; // input st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); X = Integer.parseInt(st.nextToken()); A = new int[N]; B = new int[N]; st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; N; i ++) A[i] = Integer.parseInt(st.nextToken()); st = new StringTokenizer(br.readLine()); for (int i = 0; i &lt; N; i ++) B[i] = Integer.parseInt(st.nextToken()); // calculation for (int i = 0; i &lt; N; i++) { current_weight += B[i]; int routine = (current_weight - A[i]) / X; // if, he falls down if (current_weight &lt; A[i]) { answer = -1; break; } // if, he can do routine if (routine &gt; 0) { current_weight -= X * routine; answer += routine; } } System.out.println(answer); } } . ",
    "url": "/docs/codingtest/1day1coding/230922/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/#결과-코드"
  },"223": {
    "doc": "보디빌딩",
    "title": "보디빌딩",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/230922/",
    
    "relUrl": "/docs/codingtest/1day1coding/230922/"
  },"224": {
    "doc": "TIL (23-09-26)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/230926/#til",
    
    "relUrl": "/docs/tils/230926/#til"
  },"225": {
    "doc": "TIL (23-09-26)",
    "title": "2023.09.26 (TUE)",
    "content": ". 자바스크립트의 using . 기존 const와 같은 JS 키워드는 수동으로 변수를 해제/종료시켜줘야 했다. 하지만 using을 사용하면 DB 변수와 같이, 반드시 종료를 시켜줘야 하는 변수들을 종료시켜줄 수 있다. 발동 조건은 using 변수가 범위를 벗어나 더 이상 사용되지 않으면 폐기된다. ",
    "url": "/docs/tils/230926/#20230926-tue",
    
    "relUrl": "/docs/tils/230926/#20230926-tue"
  },"226": {
    "doc": "TIL (23-09-26)",
    "title": "TIL (23-09-26)",
    "content": " ",
    "url": "/docs/tils/230926/",
    
    "relUrl": "/docs/tils/230926/"
  },"227": {
    "doc": "제작 일지 <9>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;9&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231003/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-9",
    
    "relUrl": "/docs/projects/pongdang/231003/#퐁당-웹-매거진-프로젝트-제작-일지-9"
  },"228": {
    "doc": "제작 일지 <9>",
    "title": "2023.10.03 (TUE)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231003/#20231003-tue",
    
    "relUrl": "/docs/projects/pongdang/231003/#20231003-tue"
  },"229": {
    "doc": "제작 일지 <9>",
    "title": "1. 오프라인 회의",
    "content": "오프라인 회의 진행하면서, 개발 진행 . ",
    "url": "/docs/projects/pongdang/231003/#1-%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%ED%9A%8C%EC%9D%98",
    
    "relUrl": "/docs/projects/pongdang/231003/#1-오프라인-회의"
  },"230": {
    "doc": "제작 일지 <9>",
    "title": "2. 11월 14일 전까지 해야 할 업무",
    "content": ". | 검색 DB | 검색 알고리즘 | 인터뷰 페이지 | 수시로 피드백 받은거 바로바로 수정 | . ",
    "url": "/docs/projects/pongdang/231003/#2-11%EC%9B%94-14%EC%9D%BC-%EC%A0%84%EA%B9%8C%EC%A7%80-%ED%95%B4%EC%95%BC-%ED%95%A0-%EC%97%85%EB%AC%B4",
    
    "relUrl": "/docs/projects/pongdang/231003/#2-11월-14일-전까지-해야-할-업무"
  },"231": {
    "doc": "제작 일지 <9>",
    "title": "제작 일지 <9>",
    "content": " ",
    "url": "/docs/projects/pongdang/231003/",
    
    "relUrl": "/docs/projects/pongdang/231003/"
  },"232": {
    "doc": "제작 일지 <_10>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;10&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-10",
    
    "relUrl": "/docs/projects/pongdang/231009/#퐁당-웹-매거진-프로젝트-제작-일지-10"
  },"233": {
    "doc": "제작 일지 <_10>",
    "title": "2023.10.09 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231009/#20231009-mon",
    
    "relUrl": "/docs/projects/pongdang/231009/#20231009-mon"
  },"234": {
    "doc": "제작 일지 <_10>",
    "title": "1. 검색용 DB 생성",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/#1-%EA%B2%80%EC%83%89%EC%9A%A9-db-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/231009/#1-검색용-db-생성"
  },"235": {
    "doc": "제작 일지 <_10>",
    "title": "제작 일지 <_10>",
    "content": " ",
    "url": "/docs/projects/pongdang/231009/",
    
    "relUrl": "/docs/projects/pongdang/231009/"
  },"236": {
    "doc": "TIL (23-10-10)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231010/#til",
    
    "relUrl": "/docs/tils/231010/#til"
  },"237": {
    "doc": "TIL (23-10-10)",
    "title": "2023.10.10 (TUE)",
    "content": ". ",
    "url": "/docs/tils/231010/#20231010-tue",
    
    "relUrl": "/docs/tils/231010/#20231010-tue"
  },"238": {
    "doc": "TIL (23-10-10)",
    "title": "Entity, Repository",
    "content": "Entity . 데이터베이스에 쓰일 필드와 여러 엔티티간 연관관계를 정의한다. Repository . Entity에 의해 생성된 DB에 접근하는 메서드들을 사용하기 위한 인터페이스이다. ",
    "url": "/docs/tils/231010/#entity-repository",
    
    "relUrl": "/docs/tils/231010/#entity-repository"
  },"239": {
    "doc": "TIL (23-10-10)",
    "title": "TIL (23-10-10)",
    "content": " ",
    "url": "/docs/tils/231010/",
    
    "relUrl": "/docs/tils/231010/"
  },"240": {
    "doc": "기지국 설치",
    "title": "기지국 설치",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/231016/",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/"
  },"241": {
    "doc": "기지국 설치",
    "title": "2023.10.16 (FRI)",
    "content": ". 문제 : 프로그래머스 LV.3 - 기지국 설치 . ",
    "url": "/docs/codingtest/1day1coding/231016/#20231016-fri",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#20231016-fri"
  },"242": {
    "doc": "기지국 설치",
    "title": "조건 및 설명",
    "content": ". | N개의 아파트가 일렬로 서있음 | 일부 아파트는 원래 4g 기지국이 설치되어 있었음 | w는 전파의 도달거리 (양 옆) | 설치해야하는 기지국 개수의 최솟값을 구하라. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#조건-및-설명"
  },"243": {
    "doc": "기지국 설치",
    "title": "접근법 1",
    "content": ". | 아파트의 갯수만큼 visited[] 배열을 만든다. | 이미 기지국의 전파 범위안에 있는 아파트를 true로 바꾼다. | 일렬로 세워져있기 때문에, 앞부터 2w+1개씩 세어준다. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A0%91%EA%B7%BC%EB%B2%95-1",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#접근법-1"
  },"244": {
    "doc": "기지국 설치",
    "title": "임시 결과 코드 1번",
    "content": "/* * Title : 기지국 설치 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12979?language=java */ import java.util.*; class Solution { public int solution(int n, int[] stations, int w) { int answer = 0; // 1 . boolean[] visited = new boolean[n]; for (boolean v : visited) { v = false; } // 2. for (int st : stations) { int low = st-1-w; int high = st-1+w &gt; n-1 ? n-1 : st-1+w; for (int i = low; i &lt;= high; i++) visited[i] = true; } // 3. int counter = 0; int range = 2*w+1; for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; counter &lt; range) { counter++; } if (counter == range) { for (int j = i; j &gt; i-range; j--) visited[j] = true; counter = 0; answer++; } else if ((visited[i] &amp;&amp; counter != 0) || (i == n-1 &amp;&amp; counter !=0)) { for (int j = i-1; j &gt; i-counter-1; j--) visited[j] = true; counter = 0; answer++; } } return answer; } } . 채점 결과 정확성: 53.7 효율성: 0.0 합계: 53.7 / 100.0 . 방법은 맞지만, 정확성 채점에서도 런타임 에러가 발생하였다. 더 효율적이여야 한다. 해당 방법 말고, 새로운 접근법으로 가보자. ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%9E%84%EC%8B%9C-%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C-1%EB%B2%88",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#임시-결과-코드-1번"
  },"245": {
    "doc": "기지국 설치",
    "title": "접근법 2.",
    "content": ". | 기지국 전파가 닿지 않는 구간의 개수를 센다. | 그 개수를 range를 이용하여 최소 기지국 설치 개수를 센다. | stations이 한개 이상 있기 때문에, 처음-중간-끝을 나눠서 계산한다. | . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%A0%91%EA%B7%BC%EB%B2%95-2",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#접근법-2"
  },"246": {
    "doc": "기지국 설치",
    "title": "임시 결과 코드 2번",
    "content": "/* * Title : 기지국 설치 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12979?language=java */ import java.util.*; class Solution { public int solution(int n, int[] stations, int w) { int answer = 0; int range = 2*w+1; int empty_num; // 처음 empty_num = stations[0] - w - 1; // ex) 9 - 2 - 1 = 6 if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } // 중간 for (int i = 1; i &lt; stations.length; i++) { empty_num = (stations[i] - w) - (stations[i-1] + w) - 1; // ex) 10 - 5 -1 if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } } // 끝 empty_num = n - (stations[stations.length - 1] + w); if (empty_num &gt; 0) { answer += empty_num / range; if (empty_num % range != 0) answer++; } return answer; } } . 채점 결과 정확성: 70.5 효율성: 29.5 합계: 100.0 / 100.0 . ",
    "url": "/docs/codingtest/1day1coding/231016/#%EC%9E%84%EC%8B%9C-%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C-2%EB%B2%88",
    
    "relUrl": "/docs/codingtest/1day1coding/231016/#임시-결과-코드-2번"
  },"247": {
    "doc": "TIL (23-10-16)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231016/#til",
    
    "relUrl": "/docs/tils/231016/#til"
  },"248": {
    "doc": "TIL (23-10-16)",
    "title": "2023.10.16 (MON)",
    "content": ". ",
    "url": "/docs/tils/231016/#20231016-mon",
    
    "relUrl": "/docs/tils/231016/#20231016-mon"
  },"249": {
    "doc": "TIL (23-10-16)",
    "title": "코테 연습 팁",
    "content": ". | 노가다는 제일 최후의 수단이다. | 수식을 세울 수 있을 것 같으면, 한번 도전해라!! | . ",
    "url": "/docs/tils/231016/#%EC%BD%94%ED%85%8C-%EC%97%B0%EC%8A%B5-%ED%8C%81",
    
    "relUrl": "/docs/tils/231016/#코테-연습-팁"
  },"250": {
    "doc": "TIL (23-10-16)",
    "title": "TIL (23-10-16)",
    "content": " ",
    "url": "/docs/tils/231016/",
    
    "relUrl": "/docs/tils/231016/"
  },"251": {
    "doc": "제작 일지 <_11>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;11&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231018/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-11",
    
    "relUrl": "/docs/projects/pongdang/231018/#퐁당-웹-매거진-프로젝트-제작-일지-11"
  },"252": {
    "doc": "제작 일지 <_11>",
    "title": "2023.10.18 (WED)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231018/#20231018-wed",
    
    "relUrl": "/docs/projects/pongdang/231018/#20231018-wed"
  },"253": {
    "doc": "제작 일지 <_11>",
    "title": "1. 검색용 DB 생성 후, 불러오기 테스트",
    "content": "리액트와 스프링부트 연동을 하는데, 중점을 두었다. 예제로, 테이블의 json을 받아와 출력하도록 하였다. Result.js . import React, { useEffect, useState } from 'react'; import \"./Result.css\"; export default function SearchBar() { const [interviews, setInterviews] = useState([]); useEffect(() =&gt; { fetch('/v1/interview') // Endpoint .then(response =&gt; response.json()) .then(data =&gt; setInterviews(data)) .catch(error =&gt; console.error(error)); }, []) return ( &lt;div className=\"Result_Search\"&gt; {/* interviews 배열에 맞게 데이터 렌더링 */} {interviews.map(interview =&gt; ( &lt;div key={interview.id}&gt; &lt;h3&gt;{interview.interview_title}&lt;/h3&gt; &lt;p&gt;{interview.interviewee}&lt;/p&gt; &lt;/div&gt; ))} &lt;/div&gt; ) } . InterviewController.java . @RestController // Json 형태 결과값 반환 @RequiredArgsConstructor // final 객체를 Constructor Injection (Autowired 역할) @RequestMapping(\"/v1\") // version1의 api public class InterviewController { private final InterviewRepository interviewRepository; /** * 조회 * * @return */ @GetMapping(\"interview\") public List&lt;InterviewEntity&gt; findAllInterview() { return interviewRepository.findAll(); } } . 결과 화면 . ",
    "url": "/docs/projects/pongdang/231018/#1-%EA%B2%80%EC%83%89%EC%9A%A9-db-%EC%83%9D%EC%84%B1-%ED%9B%84-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/projects/pongdang/231018/#1-검색용-db-생성-후-불러오기-테스트"
  },"254": {
    "doc": "제작 일지 <_11>",
    "title": "제작 일지 <_11>",
    "content": " ",
    "url": "/docs/projects/pongdang/231018/",
    
    "relUrl": "/docs/projects/pongdang/231018/"
  },"255": {
    "doc": "TIL (23-10-20)",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils/231020/#til",
    
    "relUrl": "/docs/tils/231020/#til"
  },"256": {
    "doc": "TIL (23-10-20)",
    "title": "2023.10.20 (FRI)",
    "content": ". ",
    "url": "/docs/tils/231020/#20231020-fri",
    
    "relUrl": "/docs/tils/231020/#20231020-fri"
  },"257": {
    "doc": "TIL (23-10-20)",
    "title": "JPA와 MySQL에서의 컬럼명",
    "content": "분명 동일하게 네이밍을 했음에도 불구하고, 자꾸 컬럼명을 못찾는다고 나온다. 원인을 찾아보았다. Java는 카멜케이스(camelCase), SQL은 스테이크 케이스(snake_case)를 주로 사용한다. 그래서 MySQL에서 컬럼명을 대문자로 표기했을 때, 오류가 있었을 수도,,,? . 그래서 아래처럼 변경하였다. Spring -&gt; interviewTitle MySQL -&gt; interview_title . 정상 동작 한다!!! . ",
    "url": "/docs/tils/231020/#jpa%EC%99%80-mysql%EC%97%90%EC%84%9C%EC%9D%98-%EC%BB%AC%EB%9F%BC%EB%AA%85",
    
    "relUrl": "/docs/tils/231020/#jpa와-mysql에서의-컬럼명"
  },"258": {
    "doc": "TIL (23-10-20)",
    "title": "TIL (23-10-20)",
    "content": " ",
    "url": "/docs/tils/231020/",
    
    "relUrl": "/docs/tils/231020/"
  },"259": {
    "doc": "제작 일지 <_12>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;12&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231020/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-12",
    
    "relUrl": "/docs/projects/pongdang/231020/#퐁당-웹-매거진-프로젝트-제작-일지-12"
  },"260": {
    "doc": "제작 일지 <_12>",
    "title": "2023.10.20 (FRI)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231020/#20231020-fri",
    
    "relUrl": "/docs/projects/pongdang/231020/#20231020-fri"
  },"261": {
    "doc": "제작 일지 <_12>",
    "title": "1. 검색 알고리즘 생성",
    "content": "일단, title에서 검색어에 단어가 포함되면 리스트를 출력하도록 먼저 세팅해놓았다. ",
    "url": "/docs/projects/pongdang/231020/#1-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/pongdang/231020/#1-검색-알고리즘-생성"
  },"262": {
    "doc": "제작 일지 <_12>",
    "title": "제작 일지 <_12>",
    "content": " ",
    "url": "/docs/projects/pongdang/231020/",
    
    "relUrl": "/docs/projects/pongdang/231020/"
  },"263": {
    "doc": "영어 끝말잇기",
    "title": "영어 끝말잇기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/231116/",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/"
  },"264": {
    "doc": "영어 끝말잇기",
    "title": "2023.11.16 (THU)",
    "content": ". 문제 : 프로그래머스 LV.3 - 영어 끝말잇기 . ",
    "url": "/docs/codingtest/1day1coding/231116/#20231116-thu",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#20231116-thu"
  },"265": {
    "doc": "영어 끝말잇기",
    "title": "조건 및 설명",
    "content": ". | 똑같은 걸 말하거나, 끝말잇기가 되지 않으면 탈락 | . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EC%A1%B0%EA%B1%B4-%EB%B0%8F-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#조건-및-설명"
  },"266": {
    "doc": "영어 끝말잇기",
    "title": "접근법",
    "content": ". | 출력은 현재 인덱스에서 나머지 연산 등으로 구한다. | 단어수가 크지 않다. | 매번 인덱스마다 체크해보자. | . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EC%A0%91%EA%B7%BC%EB%B2%95",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#접근법"
  },"267": {
    "doc": "영어 끝말잇기",
    "title": "결과 코드",
    "content": "import java.util.*; class Solution { public int[] solution(int n, String[] words) { int[] answer = {0, 0}; ArrayList&lt;String&gt; usedWords = new ArrayList&lt;&gt;(); // 사용한 단어 usedWords.add(words[0]); // 첫 단어 추가 for (int i = 1; i &lt; words.length; i++) { // 1. 끝 알파벳과 첫 알파벳이 같지 않을 경우 // 2. 똑같은 단어를 말했을 경우 if (words[i].charAt(0) != words[i-1].charAt(words[i-1].length()-1) || usedWords.contains(words[i])) { answer[0] = i % n + 1; answer[1] = i / n + 1; break; } usedWords.add(words[i]); } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/231116/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/231116/#결과-코드"
  },"268": {
    "doc": "TIL (23-11-22)",
    "title": "TIL - (스프링+리액트) 특정 주소만 작동하지 않는 상황",
    "content": " ",
    "url": "/docs/tils/231122/#til---%EC%8A%A4%ED%94%84%EB%A7%81%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8A%B9%EC%A0%95-%EC%A3%BC%EC%86%8C%EB%A7%8C-%EC%9E%91%EB%8F%99%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/tils/231122/#til---스프링리액트-특정-주소만-작동하지-않는-상황"
  },"269": {
    "doc": "TIL (23-11-22)",
    "title": "2023.11.22 (WED)",
    "content": ". '/', '/test'는 정상작동 하지만, '/test/test'는 정상작동하지 않는 오류가 생겼다. | 기존 controller @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } } . | . 리다이렉트의 추가 수정이 필요하다. @Controller public class WebController implements ErrorController { @RequestMapping({\"/{path:[^\\\\.]*}\"}) public String redirect() { return \"forward:/\"; } @RequestMapping({\"/**/{path:^(?!.*\\\\.).*}\"}) public String deepRedirect() { return \"forward:/\"; } } . 근데 이후, 아래와 같은 오류가 발생하였다. Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2023-11-22 09:16:38.850 ERROR 30399 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter : APPLICATION FAILED TO START Description: Invalid mapping pattern detected: /**/{path:^(?!..).} ^ No more pattern data allowed after {*...} or ** pattern element Action: Fix this pattern in your application or switch to the legacy parser implementation with 'spring.mvc.pathmatch.matching-strategy=ant_path_matcher'. 해당 오류는 스프링부트에서 제공하는 기본 경로 패턴 매칭 알고리즘은 복잡한 정규 표현식을 지원하지 않기 때문에 발생하는 오류이다. 이를 해결하기 위해서는 스프링 부트의 설정을 변경하여, 이전 버전의 경로 매칭 알고리즘(AntPathMatcher)을 사용하면 된다. spring.mvc.pathmatch.matching-strategy=ant_path_matcher . ",
    "url": "/docs/tils/231122/#20231122-wed",
    
    "relUrl": "/docs/tils/231122/#20231122-wed"
  },"270": {
    "doc": "TIL (23-11-22)",
    "title": "TIL (23-11-22)",
    "content": " ",
    "url": "/docs/tils/231122/",
    
    "relUrl": "/docs/tils/231122/"
  },"271": {
    "doc": "TIL (23-11-25)",
    "title": "TIL - Jekyll(just-the-docs) 한국 검색 기능 추가",
    "content": " ",
    "url": "/docs/tils/231125/#til---jekylljust-the-docs-%ED%95%9C%EA%B5%AD-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80",
    
    "relUrl": "/docs/tils/231125/#til---jekylljust-the-docs-한국-검색-기능-추가"
  },"272": {
    "doc": "TIL (23-11-25)",
    "title": "2023.11.25 (SAT)",
    "content": ". 기존 Just the Docs에서는 lunr.js를 이용한 검색 기능을 제공한다. 하지만, 한국어는 정식으로 지원하지 않는 lunr다.. 그래서 해결책은 lunr-languages에서 제공한 js를 이용하는 것이다. | lunr.ko.js, lunr.multi.js, lunr.stemmer.support.js를 다운 받아, assets/js/vendor 디렉토리(lunr.min.js가 존재하는 디렉토리)에 넣어준다. | lunr.min.js가 임포트 된 head.html에 다음과 같은 순서로 임포트한다. 가장 오랜 시간을 잡아먹은,,, 순서를 지키지 않았더니, 한글 검색은 물론이고 영어 검색도 먹통이 되었다. | just-the-docs.js 파일에 아래 코드를 추가시켜준다. var index = lunr(function(){ this.use(lunr.multiLanguage('en', 'ko')); // ... | . | 아래와 같이 한글 검색 기능도 된다! | . ",
    "url": "/docs/tils/231125/#20231125-sat",
    
    "relUrl": "/docs/tils/231125/#20231125-sat"
  },"273": {
    "doc": "TIL (23-11-25)",
    "title": "TIL (23-11-25)",
    "content": " ",
    "url": "/docs/tils/231125/",
    
    "relUrl": "/docs/tils/231125/"
  },"274": {
    "doc": "TIL (23-12-04)",
    "title": "TIL - CSS 버튼이나 링크 위에 이미지를 올릴 때, 이미지의 클릭 비활성화",
    "content": " ",
    "url": "/docs/tils/231204/#til---css-%EB%B2%84%ED%8A%BC%EC%9D%B4%EB%82%98-%EB%A7%81%ED%81%AC-%EC%9C%84%EC%97%90-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A5%BC-%EC%98%AC%EB%A6%B4-%EB%95%8C-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%9D%98-%ED%81%B4%EB%A6%AD-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/tils/231204/#til---css-버튼이나-링크-위에-이미지를-올릴-때-이미지의-클릭-비활성화"
  },"275": {
    "doc": "TIL (23-12-04)",
    "title": "2023.12.04 (MON)",
    "content": ". 앞에 그라데이션 효과를 주면서 뒤에 요소를 클릭하게 만들고 싶었다.gradation_container &gt; img { width: 100%; position: absolute; bottom: 0; left: 0; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -o-user-select: none; user-select: none; -webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -o-user-drag: none; user-drag: none; pointer-events: none; /* 이미지 위에서의 이벤트 처리 막기 */ } . pointer-events를 none으로 설정하면, 이미지 위에서의 이벤트 처리를 차단할 수 있다. ",
    "url": "/docs/tils/231204/#20231204-mon",
    
    "relUrl": "/docs/tils/231204/#20231204-mon"
  },"276": {
    "doc": "TIL (23-12-04)",
    "title": "TIL (23-12-04)",
    "content": " ",
    "url": "/docs/tils/231204/",
    
    "relUrl": "/docs/tils/231204/"
  },"277": {
    "doc": "제작 일지 <_13>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;13&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/231204/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-13",
    
    "relUrl": "/docs/projects/pongdang/231204/#퐁당-웹-매거진-프로젝트-제작-일지-13"
  },"278": {
    "doc": "제작 일지 <_13>",
    "title": "2023.12.04 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/231204/#20231204-mon",
    
    "relUrl": "/docs/projects/pongdang/231204/#20231204-mon"
  },"279": {
    "doc": "제작 일지 <_13>",
    "title": "1. 검색 페이지 완성 및 라우팅",
    "content": ". MySQL 데이터베이스와 연결하여, 검색 기능을 구현하였다. 그 중에서도 조금 오래걸렸던 부분은, 이 부분인데, 앞에 그라데이션 효과를 주면서 뒤에 요소를 클릭하게 만들고 싶었다.gradation_container &gt; img { width: 100%; position: absolute; bottom: 0; left: 0; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -o-user-select: none; user-select: none; -webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -o-user-drag: none; user-drag: none; pointer-events: none; /* 이미지 위에서의 이벤트 처리 막기 */ } . pointer-events를 none으로 설정하면, 이미지 위에서의 이벤트 처리를 차단할 수 있다. ",
    "url": "/docs/projects/pongdang/231204/#1-%EA%B2%80%EC%83%89-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%99%84%EC%84%B1-%EB%B0%8F-%EB%9D%BC%EC%9A%B0%ED%8C%85",
    
    "relUrl": "/docs/projects/pongdang/231204/#1-검색-페이지-완성-및-라우팅"
  },"280": {
    "doc": "제작 일지 <_13>",
    "title": "제작 일지 <_13>",
    "content": " ",
    "url": "/docs/projects/pongdang/231204/",
    
    "relUrl": "/docs/projects/pongdang/231204/"
  },"281": {
    "doc": "TIL (23-12-12)",
    "title": "TIL - CS 지식 복기",
    "content": " ",
    "url": "/docs/tils/231211/#til---cs-%EC%A7%80%EC%8B%9D-%EB%B3%B5%EA%B8%B0",
    
    "relUrl": "/docs/tils/231211/#til---cs-지식-복기"
  },"282": {
    "doc": "TIL (23-12-12)",
    "title": "2023.12.12 (TUE)",
    "content": ". ",
    "url": "/docs/tils/231211/#20231212-tue",
    
    "relUrl": "/docs/tils/231211/#20231212-tue"
  },"283": {
    "doc": "TIL (23-12-12)",
    "title": "1️⃣ TCP, UDP",
    "content": "TCP와 UDP는 모두 데이터를 보내기 위해 사용하는 프로토콜이다. | TCP (Transmission Control Protocol) . 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. | 일반적으로 TCP와 IP를 함께 사용하여, TCP/IP라고도 불린다. | IP가 데이터의 배달을 처리한다면, TCP는 패킷을 추적 및 관리한다. | IP는 Internet Protocol의 약자로, 인터넷에서 데이터 주소를 지정하고 라우팅하기 위한 요구 사항의 집합이다. | . | TCP의 특징 . | 연결 지향 방식으로 패킷 교환 방식을 사용한다. | 3-way handshaking을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다. (그래서 연결 지향 방식이다.) | 높은 신뢰성 (연결형 서비스이기 때문에) | UDP보다 속도가 느리다. | 연속성 보다 신뢰성 있는 전송이 중요할 때! | . | TCP 서버의 특징 . | 서버 소켓은 연결만을 담당한다. | 연결 과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다. | 이게 무슨 말이야? -&gt; 왜 반환? -&gt; 요청자가 close() 함수를 사용하면 호출 즉시 OS에게 소켓의 리소스를 반환하며 모든 스트림이 파기된다. | 반환하면 재전송을 요청한다. -&gt; 그러면 전체적인 속도가 느려지겠지? | . | . | 서버와 클라이언트는 1대1로 연결된다. | 스트림 전송으로 전송 데이터의 크기가 무제한이다. | 왜? -&gt; TCP는 데이터를 세그먼트로 분할하여 패킷을 전송하는데, 이때 세그먼트의 크기에는 제한이 있지만, 스트림으로 전송되는 데이터의 크기에는 제한이 없다. 이는 TCP가 대량의 데이터를 효율적으로 전송하기 위해 사용되는 프로토콜이기 때문이다. -&gt; 즉, TCP가 데이터를 조각내어 전송하는 방식 때문에 데이터의 크기에 대한 제한이 없다는 의미다. | . | 패킷에 대한 응답을 해야하기 때문에, 성능이 낮다. | 패킷이란, 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송하는데, 그 조각을 패킷이라고 한다. | . | . | . | . | TCP는 패킷을 어떻게 추적하고 관리하나? 데이터는 패킷 단위로 나누어 같은 목적지(IP계층)으로 전송된다. A, B, C가 같은 목적지로 간다고 할 때, B가 분실되었다고 해보자. 하지만 목적지 입장에서는 A, B, C가 전부 필요한지 모른다. 그래서 1, 2, 3과 같은 마킹을 하여, 패킷의 분실 확인과 같은 처리를 하여 목적지에서 재조립을 한다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립한다. | . | UDP (User Datagram Protocol) . 데이터를 ‘데이터그램’ 단위로 처리하는 프로토콜이다. -&gt; 데이터 그램이란, 독립적인 관계를 지니는 패킷 (자세한 설명은 아래에) . UDP는 TCP와 달리 비연결형 프로토콜이다. 즉, 연결을 위한 논리적인 경로가 없다. 그래서 각각의 패킷은 다른 경로로 전송되며, 자동적으로 패킷은 독립적인 관계를 지니게 된다. | UDP 특징 . | 비연결형 서비스로 데이터그램을 방식을 제공한다. | 정보를 주고 받을 때, 정보를 보내거나 받는다는 신호절차를 거치지 않는다. | 그래서 TCP보다 속도가 빠르다 | . | UDP의 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다. | 대신, 신뢰성이 낮다. | . | . UDP는 비연결형 서비스이기 때문에, TCP처럼 연결을 설정하고 해제하는 과정이 존재하지 않는다. 하지만, 그런 특징 때문에 신뢰성 있는 데이터의 전송을 보장하지 못한다. | UDP 서버의 특징 . | UDP에는 연결 자체가 없다. -&gt; connect() 함수 불필요 -&gt; 서버 소켓과 클라이언트 소켓의 구분이 없다. | 소켓 대신 IP를 기반으로 데이터를 전송한다. | 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다. | 데이터그램(메시지) 단위로 전송되며 크기는 65535 바이트이다. (크기가 초과되면 잘라서 보낸다.) | 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인 불가 | 신뢰성보단 성능이 중요시 되는 경우 사용 | . | . 흐름제어(flow control)는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것이다. | . ",
    "url": "/docs/tils/231211/#1%EF%B8%8F%E2%83%A3-tcp-udp",
    
    "relUrl": "/docs/tils/231211/#1️⃣-tcp-udp"
  },"284": {
    "doc": "TIL (23-12-12)",
    "title": "2️⃣ 객체와 클래스 차이",
    "content": "객체 : 자신 고유의 속성을 가지는 물리적, 추상적인 모든 대상을 일컫는다. 클래스 : 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도이다. ",
    "url": "/docs/tils/231211/#2%EF%B8%8F%E2%83%A3-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4",
    
    "relUrl": "/docs/tils/231211/#2️⃣-객체와-클래스-차이"
  },"285": {
    "doc": "TIL (23-12-12)",
    "title": "3️⃣ 사용자가 도메인을 입력했을때, 웹페이지가 불러와지는 과정",
    "content": "1. 사용자가 웹 브라우저에 도메인 주소(예: www.example.com)를 입력한다. 2. 브라우저는 입력된 도메인 주소를 DNS 서버로 보낸다. (DNS 서버는 도메인 주소를 해당 도메인의 IP주소로 변환해주는 역할을 한다.) 3. DNS 서버는 도메인 주소에 대응하는 IP 주소를 찾아 브라우저에게 응답한다. 4. 브라우저는 IP 주소를 통해 웹서버에 접속을 시도한다. 5. 웹 서버는 해당 도메인에 대한 요청을 받고, 요청된 웹페이즈를 찾아서 브라우저에게 전송한다. 6. 브라우저는 받은 웹페이지를 해석하여 화면에 표시한다. ",
    "url": "/docs/tils/231211/#3%EF%B8%8F%E2%83%A3-%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B0%80-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84%EB%95%8C-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%B6%88%EB%9F%AC%EC%99%80%EC%A7%80%EB%8A%94-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/tils/231211/#3️⃣-사용자가-도메인을-입력했을때-웹페이지가-불러와지는-과정"
  },"286": {
    "doc": "TIL (23-12-12)",
    "title": "TIL (23-12-12)",
    "content": " ",
    "url": "/docs/tils/231211/",
    
    "relUrl": "/docs/tils/231211/"
  },"287": {
    "doc": "TIL (24-01-08)",
    "title": "TIL - 퐁당 프로젝트 / 서버 백그라운드 실행",
    "content": " ",
    "url": "/docs/tils/240108/#til---%ED%90%81%EB%8B%B9-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8--%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#til---퐁당-프로젝트--서버-백그라운드-실행"
  },"288": {
    "doc": "TIL (24-01-08)",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/tils/240108/#20240108-mon",
    
    "relUrl": "/docs/tils/240108/#20240108-mon"
  },"289": {
    "doc": "TIL (24-01-08)",
    "title": "1️⃣ SpringBoot 서버 백그라운드 실행",
    "content": "서버를 24시간 돌려야하기 때문에, nohup 명령어를 통해 백그라운드에 돌아가게 한다. nohup java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log 2&gt;&amp;1 &amp; . ",
    "url": "/docs/tils/240108/#1%EF%B8%8F%E2%83%A3-springboot-%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#1️⃣-springboot-서버-백그라운드-실행"
  },"290": {
    "doc": "TIL (24-01-08)",
    "title": "2️⃣ 서버가 켜지지 않음",
    "content": "인스턴스 재시작시에는, 서비스들이 종료되어 있다. 때문에, nginx를 재시작해준다. sudo systemctl restart nginx . ",
    "url": "/docs/tils/240108/#2%EF%B8%8F%E2%83%A3-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EC%A7%80-%EC%95%8A%EC%9D%8C",
    
    "relUrl": "/docs/tils/240108/#2️⃣-서버가-켜지지-않음"
  },"291": {
    "doc": "TIL (24-01-08)",
    "title": "3️⃣ Date 자동 출력",
    "content": "Command + Shift + i . ",
    "url": "/docs/tils/240108/#3%EF%B8%8F%E2%83%A3-date-%EC%9E%90%EB%8F%99-%EC%B6%9C%EB%A0%A5",
    
    "relUrl": "/docs/tils/240108/#3️⃣-date-자동-출력"
  },"292": {
    "doc": "TIL (24-01-08)",
    "title": "4️⃣ AWS 인스턴스 시작 시, 자동 명령어 실행",
    "content": "위의 1, 2번을 자동 실행 되게 하였다. ",
    "url": "/docs/tils/240108/#4%EF%B8%8F%E2%83%A3-aws-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%9C%EC%9E%91-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/tils/240108/#4️⃣-aws-인스턴스-시작-시-자동-명령어-실행"
  },"293": {
    "doc": "TIL (24-01-08)",
    "title": "5️⃣ 구글 애널리틱스 연동 및 시작",
    "content": " ",
    "url": "/docs/tils/240108/#5%EF%B8%8F%E2%83%A3-%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4-%EC%97%B0%EB%8F%99-%EB%B0%8F-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/tils/240108/#5️⃣-구글-애널리틱스-연동-및-시작"
  },"294": {
    "doc": "TIL (24-01-08)",
    "title": "TIL (24-01-08)",
    "content": " ",
    "url": "/docs/tils/240108/",
    
    "relUrl": "/docs/tils/240108/"
  },"295": {
    "doc": "제작 일지 <_14>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;14&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-14",
    
    "relUrl": "/docs/projects/pongdang/240108/#퐁당-웹-매거진-프로젝트-제작-일지-14"
  },"296": {
    "doc": "제작 일지 <_14>",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/240108/#20240108-mon",
    
    "relUrl": "/docs/projects/pongdang/240108/#20240108-mon"
  },"297": {
    "doc": "제작 일지 <_14>",
    "title": "1️⃣ SpringBoot 서버 백그라운드 실행",
    "content": "서버를 24시간 돌려야하기 때문에, nohup 명령어를 통해 백그라운드에 돌아가게 한다. nohup java -jar build/libs/Pongdang_Server2-0.0.1-SNAPSHOT.jar &gt; test.log 2&gt;&amp;1 &amp; . ",
    "url": "/docs/projects/pongdang/240108/#1%EF%B8%8F%E2%83%A3-springboot-%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/pongdang/240108/#1️⃣-springboot-서버-백그라운드-실행"
  },"298": {
    "doc": "제작 일지 <_14>",
    "title": "2️⃣ 서버가 켜지지 않음",
    "content": "인스턴스 재시작시에는, 서비스들이 종료되어 있다. 때문에, nginx를 재시작해준다. sudo systemctl restart nginx . ",
    "url": "/docs/projects/pongdang/240108/#2%EF%B8%8F%E2%83%A3-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EC%A7%80-%EC%95%8A%EC%9D%8C",
    
    "relUrl": "/docs/projects/pongdang/240108/#2️⃣-서버가-켜지지-않음"
  },"299": {
    "doc": "제작 일지 <_14>",
    "title": "3️⃣ Date 자동 출력",
    "content": "Command + Shift + i . ",
    "url": "/docs/projects/pongdang/240108/#3%EF%B8%8F%E2%83%A3-date-%EC%9E%90%EB%8F%99-%EC%B6%9C%EB%A0%A5",
    
    "relUrl": "/docs/projects/pongdang/240108/#3️⃣-date-자동-출력"
  },"300": {
    "doc": "제작 일지 <_14>",
    "title": "4️⃣ AWS 인스턴스 시작 시, 자동 명령어 실행",
    "content": "위의 1, 2번을 자동 실행 되게 하였다. ",
    "url": "/docs/projects/pongdang/240108/#4%EF%B8%8F%E2%83%A3-aws-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%9C%EC%9E%91-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/pongdang/240108/#4️⃣-aws-인스턴스-시작-시-자동-명령어-실행"
  },"301": {
    "doc": "제작 일지 <_14>",
    "title": "5️⃣ 구글 애널리틱스 연동 및 시작",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/#5%EF%B8%8F%E2%83%A3-%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4-%EC%97%B0%EB%8F%99-%EB%B0%8F-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/projects/pongdang/240108/#5️⃣-구글-애널리틱스-연동-및-시작"
  },"302": {
    "doc": "제작 일지 <_14>",
    "title": "제작 일지 <_14>",
    "content": " ",
    "url": "/docs/projects/pongdang/240108/",
    
    "relUrl": "/docs/projects/pongdang/240108/"
  },"303": {
    "doc": "GameChat 계획",
    "title": "토이 프로젝트 - 게임 서버 - GameChat 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/240108/#%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84---gamechat-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameServer/240108/#토이-프로젝트---게임-서버---gamechat-계획"
  },"304": {
    "doc": "GameChat 계획",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240108/#20240108-mon",
    
    "relUrl": "/docs/projects/gameServer/240108/#20240108-mon"
  },"305": {
    "doc": "GameChat 계획",
    "title": "프레임워크",
    "content": "React + SpringBoot . React 내부 페이지에 게임 구동 . ",
    "url": "/docs/projects/gameServer/240108/#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/docs/projects/gameServer/240108/#프레임워크"
  },"306": {
    "doc": "GameChat 계획",
    "title": "게임 구상",
    "content": "채팅과 게임의 결합이다. 현재는 온라인 채팅과 게임 모두 스마트폰안에서 해결할 수 있는 시대이다. 또는 Web으로도 게임 및 채팅이 가능하다. 그래서 이 둘을 함께 즐기는 웹페이지라면, 지속적인 채팅과 게임을 동시에 즐길 수 있지 않을까? 생각하였다. ",
    "url": "/docs/projects/gameServer/240108/#%EA%B2%8C%EC%9E%84-%EA%B5%AC%EC%83%81",
    
    "relUrl": "/docs/projects/gameServer/240108/#게임-구상"
  },"307": {
    "doc": "GameChat 계획",
    "title": "GameChat 계획",
    "content": " ",
    "url": "/docs/projects/gameServer/240108/",
    
    "relUrl": "/docs/projects/gameServer/240108/"
  },"308": {
    "doc": "GameChat 개발일지 <1>",
    "title": "GameChat 개발일지 &lt;1&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240108_2/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-1",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#gamechat-개발일지-1"
  },"309": {
    "doc": "GameChat 개발일지 <1>",
    "title": "2024.01.08 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240108_2/#20240108-mon",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#20240108-mon"
  },"310": {
    "doc": "GameChat 개발일지 <1>",
    "title": "리액트, 스프링 연동 성공",
    "content": "3000은 리액트, 8080은 스프링 . React Connect . ",
    "url": "/docs/projects/gameServer/240108_2/#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%97%B0%EB%8F%99-%EC%84%B1%EA%B3%B5",
    
    "relUrl": "/docs/projects/gameServer/240108_2/#리액트-스프링-연동-성공"
  },"311": {
    "doc": "GameChat 개발일지 <1>",
    "title": "GameChat 개발일지 <1>",
    "content": " ",
    "url": "/docs/projects/gameServer/240108_2/",
    
    "relUrl": "/docs/projects/gameServer/240108_2/"
  },"312": {
    "doc": "GameChat 개발일지 <2>",
    "title": "GameChat 개발일지 &lt;2&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240113/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-2",
    
    "relUrl": "/docs/projects/gameServer/240113/#gamechat-개발일지-2"
  },"313": {
    "doc": "GameChat 개발일지 <2>",
    "title": "2024.01.13 (SAT)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240113/#20240113-sat",
    
    "relUrl": "/docs/projects/gameServer/240113/#20240113-sat"
  },"314": {
    "doc": "GameChat 개발일지 <2>",
    "title": "Room 페이지 제작 중 …",
    "content": "계획이 뭔가!? . | Room의 디자인 | . 해당 페이지는 본격적으로 채팅 + 게임이 포함된다. 배치는 왼쪽 게임, 오른쪽 채팅을 생각하고 있다. 그렇지만 많은 게임들이 채팅은 필수이며, 없는 곳을 찾기 힘들다.(온라인 게임) 그래서 차별점을 주어야 한다. 그래서 준 차별점이 게임과 채팅의 상호작용이다! . ",
    "url": "/docs/projects/gameServer/240113/#room-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%A0%9C%EC%9E%91-%EC%A4%91-",
    
    "relUrl": "/docs/projects/gameServer/240113/#room-페이지-제작-중-"
  },"315": {
    "doc": "GameChat 개발일지 <2>",
    "title": "게임과 채팅의 상호작용을 통한 차별점",
    "content": "그거 어떻게 하는건데? . 게임에서의 점수나 이벤트들을 채팅에 적용시키거나, 그 거꾸로의 상황도 충족시키는 것이다. ",
    "url": "/docs/projects/gameServer/240113/#%EA%B2%8C%EC%9E%84%EA%B3%BC-%EC%B1%84%ED%8C%85%EC%9D%98-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%B0%A8%EB%B3%84%EC%A0%90",
    
    "relUrl": "/docs/projects/gameServer/240113/#게임과-채팅의-상호작용을-통한-차별점"
  },"316": {
    "doc": "GameChat 개발일지 <2>",
    "title": "GameChat 개발일지 <2>",
    "content": " ",
    "url": "/docs/projects/gameServer/240113/",
    
    "relUrl": "/docs/projects/gameServer/240113/"
  },"317": {
    "doc": "GameChat 개발일지 <3>",
    "title": "GameChat 개발일지 &lt;3&gt;",
    "content": " ",
    "url": "/docs/projects/gameServer/240115/#gamechat-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-3",
    
    "relUrl": "/docs/projects/gameServer/240115/#gamechat-개발일지-3"
  },"318": {
    "doc": "GameChat 개발일지 <3>",
    "title": "2024.01.15 (MON)",
    "content": ". ",
    "url": "/docs/projects/gameServer/240115/#20240115-mon",
    
    "relUrl": "/docs/projects/gameServer/240115/#20240115-mon"
  },"319": {
    "doc": "GameChat 개발일지 <3>",
    "title": "방명록 느낌을 메인에 만들기",
    "content": "사람들이 자유롭게 와서 글을 남기는 것 게임에 대한, 채팅에 대한 토론도 좋다. 글을 작성한 사람의 ip를 저장하여 로그 관리 . ",
    "url": "/docs/projects/gameServer/240115/#%EB%B0%A9%EB%AA%85%EB%A1%9D-%EB%8A%90%EB%82%8C%EC%9D%84-%EB%A9%94%EC%9D%B8%EC%97%90-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/projects/gameServer/240115/#방명록-느낌을-메인에-만들기"
  },"320": {
    "doc": "GameChat 개발일지 <3>",
    "title": "GameChat 개발일지 <3>",
    "content": " ",
    "url": "/docs/projects/gameServer/240115/",
    
    "relUrl": "/docs/projects/gameServer/240115/"
  },"321": {
    "doc": "제작 일지 <_15>",
    "title": "퐁당 웹 매거진 프로젝트 제작 일지 &lt;15&gt;",
    "content": " ",
    "url": "/docs/projects/pongdang/240115/#%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%9C%EC%9E%91-%EC%9D%BC%EC%A7%80-15",
    
    "relUrl": "/docs/projects/pongdang/240115/#퐁당-웹-매거진-프로젝트-제작-일지-15"
  },"322": {
    "doc": "제작 일지 <_15>",
    "title": "2024.01.15 (MON)",
    "content": ". ",
    "url": "/docs/projects/pongdang/240115/#20240115-mon",
    
    "relUrl": "/docs/projects/pongdang/240115/#20240115-mon"
  },"323": {
    "doc": "제작 일지 <_15>",
    "title": "1️⃣ 해외 아이피 차단",
    "content": "국내 사용자가 대부분이라, 해외 아이피를 차단하였다. AWS를 사용하고 있어서 AWS WAF의 Web ACLs를 사용하여 차단해주었다. ",
    "url": "/docs/projects/pongdang/240115/#1%EF%B8%8F%E2%83%A3-%ED%95%B4%EC%99%B8-%EC%95%84%EC%9D%B4%ED%94%BC-%EC%B0%A8%EB%8B%A8",
    
    "relUrl": "/docs/projects/pongdang/240115/#1️⃣-해외-아이피-차단"
  },"324": {
    "doc": "제작 일지 <_15>",
    "title": "제작 일지 <_15>",
    "content": " ",
    "url": "/docs/projects/pongdang/240115/",
    
    "relUrl": "/docs/projects/pongdang/240115/"
  },"325": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "프로그래머스 Lv.1 - 예산",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240122/",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/"
  },"326": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "2024.01.23 (TUE)",
    "content": ". 문제 : 예산 . ",
    "url": "/docs/codingtest/1day1coding/240122/#20240123-tue",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#20240123-tue"
  },"327": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "풀이",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/240122/#%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#풀이"
  },"328": {
    "doc": "프로그래머스 Lv.1 - 예산",
    "title": "결과 코드",
    "content": "/* * Date : 2024.01.23 (TUE) * Title : 프로그래머스 Lv.1 - 예산 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/12982 */ import java.util.*; class Solution { public int solution(int[] d, int budget) { int answer = 0; Arrays.sort(d); for(int i = 0; i &lt; d.length; i++) { if (budget &lt; d[i]) { break; } budget -= d[i]; answer++; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240122/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240122/#결과-코드"
  },"329": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240205/",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/"
  },"330": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "2024.02.05 (MON)",
    "content": ". 문제 : 성격 유형 검사하기 . ",
    "url": "/docs/codingtest/1day1coding/240205/#20240205-mon",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#20240205-mon"
  },"331": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "풀이",
    "content": ". ",
    "url": "/docs/codingtest/1day1coding/240205/#%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#풀이"
  },"332": {
    "doc": "프로그래머스 Lv.1 - 성격 유형 검사하기",
    "title": "결과 코드",
    "content": "/* * Date : 2024.02.05 (MON) * Title : 프로그래머스 Lv.1 - 성격 유형 검사하기 * Link : https://school.programmers.co.kr/learn/courses/30/lessons/118666 */ import java.util.*; class Solution { public String solution(String[] survey, int[] choices) { String answer = \"\"; int index = 0; char[] words = new char[8]; int[] counts = new int[8]; words[0] = 'R'; words[1] = 'T'; words[2] = 'C'; words[3] = 'F'; words[4] = 'J'; words[5] = 'M'; words[6] = 'A'; words[7] = 'N'; for (int i = 0; i &lt; counts.length; i++) { counts[i] = 0; } // 점수 매기기 while (index &lt; survey.length) { if (choices[index] &gt; 4) { // 동의 for (int i = 0; i &lt; words.length; i++) { if (survey[index].charAt(1) == words[i]) { counts[i] += choices[index] - 4; } } } else if (choices[index] &lt; 4) { // 비동의 for (int i = 0; i &lt; words.length; i++) { if (survey[index].charAt(0) == words[i]) { counts[i] += 4 - choices[index]; } } } index++; } // 유형 결정 if (counts[0] &gt;= counts[1]) { answer += \"R\"; } else { answer += \"T\"; } if (counts[2] &gt;= counts[3]) { answer += \"C\"; } else { answer += \"F\"; } if (counts[4] &gt;= counts[5]) { answer += \"J\"; } else { answer += \"M\"; } if (counts[6] &gt;= counts[7]) { answer += \"A\"; } else { answer += \"N\"; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240205/#%EA%B2%B0%EA%B3%BC-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240205/#결과-코드"
  },"333": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 순위\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/49191?language=java\" . ",
    "url": "/docs/codingtest/1day1coding/240724/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#문제"
  },"334": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "문제 풀이",
    "content": "문제 접근 . | 순위를 매길 수 있는 선수는 모든 선수와 대결을 한 선수? -&gt; X | 모든 경기 결과를 배열에 정리하여 파악해보자. 경기 결과 정리 . public static int[][] calGame(int n, int[][] results) { int[][] allGame = new int[n][n]; // init allGame (7-none, 1-win, -1-lose) for (int i = 0; i &lt; n; i++) { allGame[i][i] = 7; // none } for (int i = 0; i &lt; n; i++) { allGame[results[i][0]-1][results[i][1]-1] = 1; // win allGame[results[i][1]-1][results[i][0]-1] = -1; // lose } return allGame; } . | 결과 7 1 0 0 0 -1 7 -1 -1 1 0 1 7 -1 0 0 1 1 7 0 0 -1 0 0 7 경기 결과 분석 . | 0이 없는 선수는 순위를 정확히 매길 수 있다. | 또한 그 선수들의 순위 기준으로 다른 선수들의 순위를 알 수도 있다. | 자신과 다른 모든 선수 간의 관계를 알 수 있는 선수만이 자신의 정확한 순위를 알 수 있다. | 내가 만약 4위에게 졌다면, 그에게 이긴 3명은 못이긴다. | . | . 간단한 수도 코드 정리 . 1 Initialize the allGame matrix: Create an n x n matrix initialized with 0. For each [A, B] in results: Mark A beats B as 1 Mark B loses to A as -1. 2 Apply Floyd-Warshall algorithm: For each k from 0 to n-1: For each i from 0 to n-1: For each j from 0 to n-1: If i beats k and k beats j, then i beats j. If i loses to k and k loses to j, then i loses to j. 3 Count players with certain ranks: Initialize count to 0. For each player i from 0 to n-1: Check if i has results against all other players. If yes, increment count. 4 Return the count. ",
    "url": "/docs/codingtest/1day1coding/240724/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#문제-풀이"
  },"335": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int n, int[][] results) { int[][] allGame = calGame(n, results); // 플로이드-워셜 알고리즘을 통해 모든 선수 간의 승패 정보를 갱신 for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (allGame[i][k] == 1 &amp;&amp; allGame[k][j] == 1) { allGame[i][j] = 1; } if (allGame[i][k] == -1 &amp;&amp; allGame[k][j] == -1) { allGame[i][j] = -1; } } } } // 선수들의 승패 정보가 확실한 선수의 수를 셉니다. int answer = 0; for (int i = 0; i &lt; n; i++) { boolean certain = true; for (int j = 0; j &lt; n; j++) { if (i != j &amp;&amp; allGame[i][j] == 0) { certain = false; break; } } if (certain) { answer++; } } return answer; } public static int[][] calGame(int n, int[][] results) { int[][] allGame = new int[n][n]; // init allGame (0-unknown, 1-win, -1-lose) for (int i = 0; i &lt; n; i++) { allGame[i][i] = 0; // self match (irrelevant) } for (int i = 0; i &lt; results.length; i++) { allGame[results[i][0] - 1][results[i][1] - 1] = 1; // win allGame[results[i][1] - 1][results[i][0] - 1] = -1; // lose } return allGame; } } . ",
    "url": "/docs/codingtest/1day1coding/240724/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/#풀이-코드"
  },"336": {
    "doc": "프로그래머스 Lv.3 - 순위",
    "title": "프로그래머스 Lv.3 - 순위",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240724/",
    
    "relUrl": "/docs/codingtest/1day1coding/240724/"
  },"337": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 방문 길이\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/49994\" . ",
    "url": "/docs/codingtest/1day1coding/240825/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#문제"
  },"338": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "문제 풀이",
    "content": "문제 접근 . HashSet에 이미 지나간 경로 저장 (양쪽으로) . 간단한 수도 코드 정리 . ",
    "url": "/docs/codingtest/1day1coding/240825/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#문제-풀이"
  },"339": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "풀이 코드",
    "content": "import java.util.HashSet; import java.util.Set; class Solution { public int solution(String dirs) { int answer = 0; int x = 0, y = 0; Set&lt;String&gt; visitedPaths = new HashSet&lt;&gt;(); for (char dir : dirs.toCharArray()) { int nextX = x; int nextY = y; switch (dir) { case 'U': nextY++; break; case 'D': nextY--; break; case 'R': nextX++; break; case 'L': nextX--; break; } if (nextX &lt; -5 || nextX &gt; 5 || nextY &lt; -5 || nextY &gt; 5) { // 경계를 벗어나는 경우 무시 continue; } // 경로 저장 String path1 = x + \"\" + y + \"\" + nextX + \"\" + nextY; String path2 = nextX + \"\" + nextY + \"\" + x + \"\" + y; // 처음 방문한 길이라면 기록 if (!visitedPaths.contains(path1) &amp;&amp; !visitedPaths.contains(path2)) { visitedPaths.add(path1); visitedPaths.add(path2); answer++; } // 좌표 업데이트 x = nextX; y = nextY; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240825/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/#풀이-코드"
  },"340": {
    "doc": "프로그래머스 Lv.2 - 방문 길이",
    "title": "프로그래머스 Lv.2 - 방문 길이",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240825/",
    
    "relUrl": "/docs/codingtest/1day1coding/240825/"
  },"341": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 롤케이크 자르기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/132265\" . | . ",
    "url": "/docs/codingtest/1day1coding/240827/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#문제"
  },"342": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "문제 풀이",
    "content": "문제 접근 . 간단한 수도 코드 정리 . Type/Paste Your Code . ",
    "url": "/docs/codingtest/1day1coding/240827/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#문제-풀이"
  },"343": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int[] topping) { int answer = 0; int left = 0; int right = topping.length - 1; // Initialize sets for left and right side toppings Set&lt;Integer&gt; leftSet = new HashSet&lt;&gt;(); Set&lt;Integer&gt; rightSet = new HashSet&lt;&gt;(); // Array to store unique topping count up to each index from the left int[] leftUnique = new int[topping.length]; for (int i = 0; i &lt; topping.length; i++) { leftSet.add(topping[i]); leftUnique[i] = leftSet.size(); } // Array to store unique topping count up to each index from the right int[] rightUnique = new int[topping.length]; for (int i = topping.length - 1; i &gt;= 0; i--) { rightSet.add(topping[i]); rightUnique[i] = rightSet.size(); } // Compare the unique topping count in left and right part using binary search for (int i = 0; i &lt; topping.length - 1; i++) { if (leftUnique[i] == rightUnique[i + 1]) { answer++; } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240827/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/#풀이-코드"
  },"344": {
    "doc": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "title": "프로그래머스 Lv.2 - 롤케이크 자르기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240827/",
    
    "relUrl": "/docs/codingtest/1day1coding/240827/"
  },"345": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 최솟값 만들기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12941\" . ",
    "url": "/docs/codingtest/1day1coding/240902/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#문제"
  },"346": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 한 배열은 오름차순, 한 배열은 내림차순 정렬 후, 계산 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240902/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#문제-풀이"
  },"347": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int []A, int []B) { int answer = 0; // sort Arrays.sort(A); Integer[] B2 = Arrays.stream(B).boxed().toArray(Integer[]::new); Arrays.sort(B2, Collections.reverseOrder()); // sum for (int i = 0; i &lt; A.length; i++) { answer += A[i] * B2[i]; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240902/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/#풀이-코드"
  },"348": {
    "doc": "프로그래머스 Lv.2 - 최솟값 만들기",
    "title": "프로그래머스 Lv.2 - 최솟값 만들기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240902/",
    
    "relUrl": "/docs/codingtest/1day1coding/240902/"
  },"349": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 주식가격\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/42584?language=java\" . | . ",
    "url": "/docs/codingtest/1day1coding/240911/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#문제"
  },"350": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "문제 풀이",
    "content": "문제 접근 . | Stack 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240911/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#문제-풀이"
  },"351": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "풀이 코드",
    "content": "class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; for (int i = 0; i &lt; prices.length; i++) { int time = 0; for (int j = i + 1; j &lt; prices.length; j++) { time++; if (prices[i] &gt; prices[j]) { break; // 가격이 떨어지면 멈춤 } } answer[i] = time; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240911/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/#풀이-코드"
  },"352": {
    "doc": "프로그래머스 Lv.2 - 주식가격",
    "title": "프로그래머스 Lv.2 - 주식가격",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240911/",
    
    "relUrl": "/docs/codingtest/1day1coding/240911/"
  },"353": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 | 프로그래머스 스쿨\" image: \"https://school.programmers.co.kr/assets/img-meta-programmers-86b32ab1929330ced348f75cf9a8033cbf8da3e78611d80f05dc3a321927f13b.png\" description: \"개발자 취업의 필수 관문 코딩테스트를 철저하게 연습하고 대비할 수 있는 문제를 총망라! 프로그래머스에서 선발한 문제로 유형을 파악하고 실력을 업그레이드해 보세요!\" url: \"https://school.programmers.co.kr/learn/challenges?order=recent&amp;languages=java\" . ",
    "url": "/docs/codingtest/1day1coding/240920/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#문제"
  },"354": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 빈 스택을 생성합니다. | 문자열의 각 문자를 순회합니다. | 현재 문자가 스택의 top과 같으면 스택에서 pop합니다. | 그렇지 않으면 현재 문자를 스택에 push합니다. | 모든 문자를 처리한 후, 스택이 비어있으면 1을 반환하고 그렇지 않으면 0을 반환합니다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/240920/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#문제-풀이"
  },"355": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) { if (!stack.isEmpty() &amp;&amp; stack.peek() == c) { stack.pop(); } else { stack.push(c); } } return stack.isEmpty() ? 1 : 0; } } . ",
    "url": "/docs/codingtest/1day1coding/240920/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/#풀이-코드"
  },"356": {
    "doc": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "title": "프로그래머스 Lv.2 - 짝지어 제거하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240920/",
    
    "relUrl": "/docs/codingtest/1day1coding/240920/"
  },"357": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 124 나라의 숫자\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12899\" . | . ",
    "url": "/docs/codingtest/1day1coding/240921/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#문제"
  },"358": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "문제 풀이",
    "content": "문제 접근 . | 10진법 | 124 나라 | 10진법 | 124 나라 | —- | —— | —- | —— | 1 | 1 | 6 | 14 | 2 | 2 | 7 | 21 | 3 | 4 | 8 | 22 | 4 | 11 | 9 | 24 | 5 | 12 | 10 | 41 | . | 3진법인데, 숫자만 1, 2, 4이다. | 10진법 숫자를 3으로 나눠, 나머지를 정리하고 . | 그것을 124 나라만의 숫자로 변경한다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/240921/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#문제-풀이"
  },"359": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public String solution(int n) { StringBuilder answer = new StringBuilder(); String[] digits = {\"4\", \"1\", \"2\"}; while (n &gt; 0) { int remainder = n % 3; n = (n - 1) / 3; answer.insert(0, digits[remainder]); } return answer.toString(); } } . ",
    "url": "/docs/codingtest/1day1coding/240921/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/#풀이-코드"
  },"360": {
    "doc": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "title": "프로그래머스 Lv.2 - 124 나라의 숫자",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240921/",
    
    "relUrl": "/docs/codingtest/1day1coding/240921/"
  },"361": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 연속된 부분 수열의 합\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/178870\" . | . ",
    "url": "/docs/codingtest/1day1coding/240923/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#문제"
  },"362": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "문제 풀이",
    "content": "문제 접근 . | 투 포인터 기법 사용: left와 right 포인터를 사용하여 연속된 부분 수열을 효율적으로 탐색 | 합계 계산 최적화: 매번 큐의 합을 계산하는 대신, sum 변수를 사용하여 현재 부분 수열의 합을 유지 | 최소 길이 부분 수열 찾기: minLength 변수를 사용하여 조건을 만족하는 가장 짧은 부분 수열 찾기 | 결과 저장: 조건을 만족하는 부분 수열을 찾을 때마다 answer 배열 업데이트 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/240923/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#문제-풀이"
  },"363": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "풀이 코드",
    "content": "class Solution { public int[] solution(int[] sequence, int k) { int left = 0; int right = 0; int sum = 0; int minLength = Integer.MAX_VALUE; int[] answer = new int[2]; while (right &lt; sequence.length) { sum += sequence[right]; while (sum &gt;= k) { if (sum == k &amp;&amp; right - left + 1 &lt; minLength) { minLength = right - left + 1; answer[0] = left; answer[1] = right; } sum -= sequence[left]; left++; } right++; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/240923/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/#풀이-코드"
  },"364": {
    "doc": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "title": "프로그래머스 Lv.2 - 연속된 부분 수열의 합",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240923/",
    
    "relUrl": "/docs/codingtest/1day1coding/240923/"
  },"365": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 4단 고음\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/1831\" . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#문제"
  },"366": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "문제 풀이",
    "content": "문제 접근 . | 모든 경우의 수를 볼 수 없다. | 제일 큰 경우의 문자열은 *++ *++ = 17 | 최소는 **++++ = 13 | 위는 규칙성이 있을까? . | 최대는 *++만큼 증가 (x3 +2) | 최소는 3*n + n*2 | 최종음높이에 따라, 가능한 3단고음의 개수의 범위를 구한다. | . | 이후, 계산 . | 스택을 활용해서, 올바른 문자열인지 확인할까? (효율적인가? 과연?) | 모든 조합은 안된다. -&gt; +로 시작하는 등의 예제가 n과 일치할 수도 있다. | 조건 . | 첫번째는 무조건 * | 마지막 * 뒤는 무조건 +가 두개 이상. | * 는 n-별순서 만큼의 두 배만큼 간단한 수도 코드 정리 . ```pseudocode 함수 solution(n): 초기화 answer = 0 초기화 min_pattern = 0 초기화 max_pattern = 0 . | . | . // 최소 패턴 길이 계산 초기화 tmp = 0 WHILE n &gt;= tmp AND tmp &lt;= Integer.MAX_VALUE: tmp = 3^(min_pattern + 1) + (min_pattern + 1)^2 min_pattern = min_pattern + 1 END WHILE min_pattern = min_pattern - 1 // 최소 패턴 길이 감소 . // 최대 패턴 길이 계산 초기화 tmp = 1 WHILE n &gt;= tmp AND tmp &lt;= Integer.MAX_VALUE: tmp = tmp * 3 + 2 max_pattern = max_pattern + 1 END WHILE . // 결과 계산 FOR i FROM min_pattern TO max_pattern: answer = answer + calResult(n, i) END FOR . RETURN answer . | . 함수 calResult(n, pattern): 초기화 count = 0 초기화 combinations = 빈 리스트 generateCombinations(“”, pattern, pattern * 2, combinations) . FOR 각 조합 s IN combinations: 초기화 sum = 1 FOR 각 문자 c IN s: IF c == '*': sum = sum * 3 ELSE IF c == '+': sum = sum + 1 END IF END FOR IF n == sum: count = count + 1 출력 s END IF END FOR RETURN count . // 재귀적으로 문자열 조합을 생성하는 메소드 함수 generateCombinations(current, remainingStars, remainingPluses, combinations): // 현재 조합에서 ‘*‘와 ‘+’의 개수가 다 사용되었으면 추가 IF remainingStars == 0 AND remainingPluses == 0: 추가 current TO combinations RETURN . // '*'가 남아있다면 추가 IF remainingStars &gt; 0: generateCombinations(current + \"*\", remainingStars - 1, remainingPluses, combinations) END IF // '+'가 남아있다면 추가 IF remainingPluses &gt; 0: generateCombinations(current + \"+\", remainingStars, remainingPluses - 1, combinations) END IF . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(int n) { int answer = 0; int min_pattern = 0; // 3단고음 패턴의 최소 갯수 int max_pattern = 0; // 3단고음 패턴의 최대 갯수 // min max length int tmp = 0; while (n &gt;= tmp || tmp &gt; Integer.MAX_VALUE) { tmp = (int)Math.pow(3, min_pattern+1) + (int)Math.pow(min_pattern+1, 2); min_pattern++; } min_pattern--; tmp = 1; while (n &gt;= tmp || tmp &gt; Integer.MAX_VALUE) { tmp = tmp * 3 + 2; max_pattern++; } // result for (int i = min_pattern; i &lt;= max_pattern; i++) { answer += calResult(n, i); } return answer; } public static int calResult(int n, int pattern) { int count = 0; List&lt;String&gt; combinations = new ArrayList&lt;&gt;(); generateCombinations(\"\", pattern, pattern*2, combinations); for (String s : combinations) { int sum = 1; for (char c : s.toCharArray()) { if (c == '*') { sum *= 3; } else if (c == '+') { sum++; } } if (n == sum) { count++; System.out.println(s); } } return count; } // 재귀적으로 문자열 조합을 생성하는 메소드 private static void generateCombinations(String current, int remainingStars, int remainingPluses, List&lt;String&gt; combinations) { // 현재 조합에서 '*'와 '+'의 개수가 다 사용되었으면 추가 if (remainingStars == 0 &amp;&amp; remainingPluses == 0) { combinations.add(current); return; } // '*'가 남아있다면 추가 if (remainingStars &gt; 0) { generateCombinations(current + \"*\", remainingStars - 1, remainingPluses, combinations); } // '+'가 남아있다면 추가 if (remainingPluses &gt; 0) { generateCombinations(current + \"+\", remainingStars, remainingPluses - 1, combinations); } } } . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#문제-풀이"
  },"367": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "미완성 코드다..",
    "content": "| |—|—|테스트 1| |입력값 〉|15|기댓값 〉|1|실행 결과 〉|테스트를 통과하였습니다.|출력 〉|++++| . |   |   | . | 테스트 2 |   | . | 입력값 〉 | 24 | . | 기댓값 〉 | 0 | . | 실행 결과 〉 | 테스트를 통과하였습니다. | . |   |   | . | 테스트 3 |   | . | 입력값 〉 | 41 | . | 기댓값 〉 | 2 | . | 실행 결과 〉 | 테스트를 통과하였습니다. | . | 출력 〉 | ++++++ ++++++ | . |   |   | . | 테스트 4 |   | . | 입력값 〉 | 2147483647 | . | 기댓값 〉 | 1735 | . | 실행 결과 〉 | 실행 중단 | . ",
    "url": "/docs/codingtest/1day1coding/240925/#%EB%AF%B8%EC%99%84%EC%84%B1-%EC%BD%94%EB%93%9C%EB%8B%A4",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/#미완성-코드다"
  },"368": {
    "doc": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "title": "프로그래머스 Lv.4 - 4단 고음 (정답률 75%)",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240925/",
    
    "relUrl": "/docs/codingtest/1day1coding/240925/"
  },"369": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - [1차] 셔틀버스\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/17678\" . ",
    "url": "/docs/codingtest/1day1coding/240930/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#문제"
  },"370": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 문제는 여러 대의 셔틀버스가 특정 시간 간격으로 운행되며, 각 셔틀에는 제한된 인원만 탑승할 수 있다는 조건이 주어진다. 주어진 크루들의 도착 시간에 따라 셔틀을 이용하는 방법을 계획해야 하며, 주인공인 콘이 가장 늦게 셔틀을 탈 수 있는 시간을 계산하는 문제이다. 핵심은 셔틀 도착 시간과 대기열에서 크루의 탑승 시간을 비교하여, 콘이 가장 늦게 셔틀을 탈 수 있는 시간을 구하는 것이다. 모든 크루가 도착한 시간 순서대로 줄을 서게 되므로, 이 문제는 크루의 도착 시간을 정렬한 후 각 셔틀에 크루들을 적절하게 배치하는 과정에서 답을 찾을 수 있다. 간단한 수도 코드 정리 . 1. 크루들의 도착 시간을 분 단위로 변환한다. 2. 변환된 시간 배열을 정렬한다. 3. 첫 번째 셔틀은 09:00에 도착하며, 이후 n회의 셔틀이 t분 간격으로 도착한다. 4. 각 셔틀 도착 시각마다 최대 m명의 크루를 태울 수 있다. 5. 마지막 셔틀에 콘이 타기 위해 가능한 가장 늦은 시간을 계산한다. - 마지막 셔틀에 자리가 있다면 셔틀 도착 시간에 맞춰 콘이 탈 수 있다. - 자리가 없다면 마지막으로 탄 크루보다 1분 먼저 콘이 도착해야 한다. 6. 콘이 탈 수 있는 가장 늦은 시간을 HH:MM 형식으로 반환한다. ",
    "url": "/docs/codingtest/1day1coding/240930/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#문제-풀이"
  },"371": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public String solution(int n, int t, int m, String[] timetable) { // timetable을 분 단위로 변환 int[] timeNum = new int[timetable.length]; for (int i = 0; i &lt; timetable.length; i++) { String[] time = timetable[i].split(\":\"); timeNum[i] = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]); } // 크루 도착 시간을 정렬 Arrays.sort(timeNum); int busTime = 540; // 첫 셔틀 시간 (09:00) int idx = 0; // 대기열에서 크루 인덱스 int lastTime = 0; // 콘이 탈 수 있는 가장 늦은 시간 // 각 셔틀을 순서대로 처리 for (int i = 0; i &lt; n; i++) { int count = 0; // 셔틀에 탑승한 크루 수 // 셔틀에 탈 수 있는 크루를 체크 while (idx &lt; timeNum.length &amp;&amp; timeNum[idx] &lt;= busTime &amp;&amp; count &lt; m) { count++; idx++; } // 마지막 셔틀일 때 if (i == n - 1) { if (count &lt; m) { // 자리가 있으면 셔틀 도착 시간에 콘이 탑승 lastTime = busTime; } else { // 자리가 없으면 마지막으로 탄 크루보다 1분 먼저 와야 함 lastTime = timeNum[idx - 1] - 1; } } // 다음 셔틀 시간 계산 busTime += t; } // 시각을 HH:MM 형식으로 변환 String hour = String.format(\"%02d\", lastTime / 60); String minute = String.format(\"%02d\", lastTime % 60); return hour + \":\" + minute; } } . ",
    "url": "/docs/codingtest/1day1coding/240930/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/#풀이-코드"
  },"372": {
    "doc": "프로그래머스 Lv.3 - 셔틀 버스",
    "title": "프로그래머스 Lv.3 - 셔틀 버스",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/240930/",
    
    "relUrl": "/docs/codingtest/1day1coding/240930/"
  },"373": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 최고의 집합\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 ”집합”으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12938\" . ",
    "url": "/docs/codingtest/1day1coding/241001/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#문제"
  },"374": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "문제 풀이",
    "content": "문제 접근 . | 간단히 쪼갤 수 있는 수 중, 차이가 가장 적은 수들의 조합을 선택하면 된다. | 입력 검증: | . | n이 s보다 크면 균등하게 나눌 수 없으므로 배열에 -1을 담아서 반환한다. | 배열 초기화: | . | 나눌 수 있는 기본 값 num을 s / n으로 계산한다. | 나머지 값 add를 s % n으로 계산한다. | 큰 값 할당: | . | add 개수만큼 배열의 앞부분에 num + 1을 할당한다. | 작은 값 할당: | . | 나머지 부분에는 num을 할당한다. | 결과 반환: | . | 배열을 오름차순으로 정렬하여 반환한다. | . | . 간단한 수도 코드 정리 . 함수 solution(n, s) { 만약 n &gt; s 이면 배열 answer에 -1을 넣고 반환 배열 answer를 크기 n으로 초기화 num을 s / n으로 설정 (기본 나눌 값) add를 s % n으로 설정 (나머지 값) add만큼 반복 { answer의 앞부분에 num + 1을 넣음 } 나머지 부분에 num을 넣음 answer를 정렬 answer 반환 } . ",
    "url": "/docs/codingtest/1day1coding/241001/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#문제-풀이"
  },"375": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int[] solution(int n, int s) { int[] answer = {}; if (n &gt; s) { answer = new int[1]; answer[0] = -1; } else { answer = new int[n]; int num = 0; // s가 쪼개져서 나온 숫자 int add = 0; // 쪼개고 남는 숫자 num = s / n; add = s % n; System.out.println(add); for (int i = 0; i &lt; add; i++) { answer[i] = num + 1; } for (int i = add; i &lt; n; i++) { answer[i] = num; } Arrays.sort(answer); } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241001/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/#풀이-코드"
  },"376": {
    "doc": "프로그래머스 Lv.3 - 최고의 집합",
    "title": "프로그래머스 Lv.3 - 최고의 집합",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241001/",
    
    "relUrl": "/docs/codingtest/1day1coding/241001/"
  },"377": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 금과 은 운반하기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/86053\" . ",
    "url": "/docs/codingtest/1day1coding/241008/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#문제"
  },"378": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 이분탐색으로 시간을 두고, 적절한 mid를 찾으면 된다. | 시간을 조금 썼던 부분은, 최댓값 지정이였다. | 금과 은, 그리고 이동거리를 따졌을때, 나오는 최대 시간으로 하면 모든 케이스들을 통과할 수 있다. 간단한 수도 코드 정리 . Type/Paste Your Code . | . | . ",
    "url": "/docs/codingtest/1day1coding/241008/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#문제-풀이"
  },"379": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "풀이 코드",
    "content": "class Solution { public long solution(int a, int b, int[] g, int[] s, int[] w, int[] t) { long answer = -1; long left = 0; long right = (long) (1e9 * 2 * 1e5 * 2); while (left &lt;= right) { long mid = (left + right) / 2; // 해당 시간 내에 운반할 수 있는 금과 은의 총합 long totalGold = 0; long totalSilver = 0; long totalAll = 0; for (int i = 0; i &lt; g.length; i++) { // mid 시간 내에서 왕복 long tripCount = mid / (2 * t[i]); // 편도 체크 if (mid % (2 * t[i]) &gt;= t[i]) { tripCount++; } // 트럭 운반 최대량 long maxTransport = tripCount * w[i]; // 금, 은 운반 가능량 long transportGold = Math.min(g[i], maxTransport); long transportSilver = Math.min(s[i], maxTransport); // 금, 은 합쳐서 계산 totalGold += transportGold; totalSilver += transportSilver; totalAll += Math.min(g[i] + s[i], maxTransport); } // 금, 은 만족하는지 검사 if (totalGold &gt;= a &amp;&amp; totalSilver &gt;= b &amp;&amp; totalAll &gt;= (a + b)) { answer = mid; right = mid - 1; } else { left = mid + 1; } } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241008/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/#풀이-코드"
  },"380": {
    "doc": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "title": "프로그래머스 Lv.3 - 금과 은 운반하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241008/",
    
    "relUrl": "/docs/codingtest/1day1coding/241008/"
  },"381": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "문제",
    "content": "title: \"코딩테스트 연습 - 퍼즐 조각 채우기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/84021\" . ",
    "url": "/docs/codingtest/1day1coding/241022/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#문제"
  },"382": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "문제 풀이",
    "content": "문제 접근 . | 보드와 퍼즐의 모양을 저장하는 배열을 만든다. (dfs) | 보드와 퍼즐을 대조(+회전)하여 맞으면 퍼즐의 수를 + 간단한 수도 코드 정리 . Type/Paste Your Code . | . ",
    "url": "/docs/codingtest/1day1coding/241022/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#문제-풀이"
  },"383": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public int solution(int[][] game_board, int[][] table) { int answer = 0; List&lt;int[][]&gt; boardList = new ArrayList&lt;&gt;(); List&lt;int[][]&gt; tableList = new ArrayList&lt;&gt;(); // game_board에서 빈 공간(0)을 조각으로 추출하여 boardList에 저장 saveList(game_board, boardList, 0); // table에서 채워진 공간(1)을 조각으로 추출하여 tableList에 저장 saveList(table, tableList, 1); // 각 테이블 조각을 게임 보드의 빈 공간과 비교하여 맞는지 확인 boolean[] used = new boolean[tableList.size()]; for (int[][] boardPiece : boardList) { for (int i = 0; i &lt; tableList.size(); i++) { if (!used[i] &amp;&amp; doesPieceMatch(boardPiece, tableList.get(i))) { answer += countCells(tableList.get(i)); // 맞으면 셀 개수 더함 used[i] = true; break; } } } return answer; } // 빈 공간 또는 채워진 공간을 찾아서 조각 리스트에 저장 public static void saveList(int[][] board, List&lt;int[][]&gt; result, int targetNum) { int n = board.length; boolean[][] visited = new boolean[n][n]; // 방문 여부 체크를 위한 배열 // 상, 하, 좌, 우 탐색을 위한 방향 배열 int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; // 보드 전체를 순회하며 DFS로 조각을 찾음 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // 아직 방문하지 않은 targetNum인 경우 DFS 시작 if (board[i][j] == targetNum &amp;&amp; !visited[i][j]) { List&lt;int[]&gt; piece = new ArrayList&lt;&gt;(); // 현재 조각을 저장할 리스트 dfs(board, visited, i, j, piece, targetNum, dx, dy); // 조각을 배열로 변환하여 result에 추가 result.add(convertPieceToArray(piece)); } } } } // DFS 탐색 함수 private static void dfs(int[][] board, boolean[][] visited, int x, int y, List&lt;int[]&gt; piece, int targetNum, int[] dx, int[] dy) { visited[x][y] = true; piece.add(new int[]{x, y}); int n = board.length; // 상, 하, 좌, 우 방향으로 탐색 for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; // 범위 내에 있고, 방문하지 않았으며, targetNum과 동일한 경우 if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; board[nx][ny] == targetNum &amp;&amp; !visited[nx][ny]) { dfs(board, visited, nx, ny, piece, targetNum, dx, dy); } } } // 조각을 리스트에서 2차원 배열로 변환 private static int[][] convertPieceToArray(List&lt;int[]&gt; piece) { // 조각의 크기를 구함 int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE; int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE; for (int[] coord : piece) { minX = Math.min(minX, coord[0]); minY = Math.min(minY, coord[1]); maxX = Math.max(maxX, coord[0]); maxY = Math.max(maxY, coord[1]); } // 조각을 담을 배열 생성 int[][] array = new int[maxX - minX + 1][maxY - minY + 1]; // 조각의 좌표를 배열에 채움 for (int[] coord : piece) { array[coord[0] - minX][coord[1] - minY] = 1; } return array; } // 조각을 회전시키는 함수 public static int[][] rotate(int[][] piece) { int n = piece.length; int m = piece[0].length; int[][] rotated = new int[m][n]; // 회전된 조각을 저장할 배열 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { rotated[j][n - 1 - i] = piece[i][j]; // 시계 방향으로 90도 회전 } } return rotated; } // 두 조각이 같은지 비교하는 함수 public static boolean areSamePiece(int[][] piece1, int[][] piece2) { if (piece1.length != piece2.length || piece1[0].length != piece2[0].length) { return false; // 크기가 다르면 일치할 수 없음 } for (int i = 0; i &lt; piece1.length; i++) { for (int j = 0; j &lt; piece1[0].length; j++) { if (piece1[i][j] != piece2[i][j]) { return false; // 값이 다르면 일치하지 않음 } } } return true; } // 테이블에서 가져온 조각이 게임 보드의 빈 공간과 일치하는지 확인 public static boolean doesPieceMatch(int[][] boardPiece, int[][] tablePiece) { // 0도, 90도, 180도, 270도 회전해서 비교 for (int i = 0; i &lt; 4; i++) { if (areSamePiece(boardPiece, tablePiece)) { return true; // 조각이 일치하면 true 반환 } tablePiece = rotate(tablePiece); // 90도 회전 } return false; } // 조각의 칸 개수를 세는 함수 public static int countCells(int[][] piece) { int count = 0; for (int[] row : piece) { for (int cell : row) { if (cell == 1) { count++; } } } return count; } } . ",
    "url": "/docs/codingtest/1day1coding/241022/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/#풀이-코드"
  },"384": {
    "doc": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "title": "프로그래머스 Lv.3 - 퍼즐 조각 채우기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241022/",
    
    "relUrl": "/docs/codingtest/1day1coding/241022/"
  },"385": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 괄호 회전하기\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/76502?language=java\" . ",
    "url": "/docs/codingtest/1day1coding/241202/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/#문제"
  },"386": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 코드는 문자열 s의 모든 회전된 문자열에 대해, 해당 문자열이 올바른 괄호 문자열인지 확인하는 방식으로 문제를 해결합니다. | . | 주어진 문자열을 한 글자씩 회전시켜 총 n개의 문자열을 생성합니다. | 각 회전된 문자열이 올바른 괄호 문자열인지 확인합니다. | 올바른 괄호 문자열인지 확인하는 함수(isCorrected)는 스택을 사용하여 여는 괄호와 닫는 괄호가 올바르게 매칭되는지 판단합니다. | . | 올바른 괄호 문자열의 개수를 계산하여 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(s): answer = 0 sb = StringBuilder(s) . for i from 0 to length(s) - 1: if isCorrected(sb.toString()): answer += 1 . // 문자열 회전 append first character of sb to the end delete first character of sb . return answer . | . function isCorrected(s): stack = empty stack . for each character in s: if stack is empty: push character to stack else if top of stack matches character: pop stack else: push character to stack return true if stack is empty, otherwise false . function isMatched(a, b): return true if (a, b) is one of (“[”, “]”), (“{“, “}”), (“(“, “)”) . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(String s) { int answer = 0; StringBuilder sb = new StringBuilder(s); for (int i = 0; i &lt; s.length(); i++) { // n-1번 검사 if (isCorrected(sb.toString())) { answer++; } // 회전 sb.append(sb.substring(0, 1)); sb.delete(0, 1); } return answer; } public static boolean isCorrected(String s) { boolean check = false; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String t : s.split(\"\")) { if (stack.isEmpty()) { stack.push(t); } else if (isMatched(stack.peek(), t)) { stack.pop(); } else { stack.push(t); } } if (stack.isEmpty()) { check = true; } else { check = false; } return check; } public static boolean isMatched(String a, String b) { boolean check = false; if (a.equals(\"[\") &amp;&amp; b.equals(\"]\")) { check = true; } else if (a.equals(\"(\") &amp;&amp; b.equals(\")\")) { check = true; } else if (a.equals(\"{\") &amp;&amp; b.equals(\"}\")) { check = true; } else { check = false; } return check; } } . ",
    "url": "/docs/codingtest/1day1coding/241202/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/#문제-풀이"
  },"387": {
    "doc": "프로그래머스 Lv.2 - 괄호 회전하기",
    "title": "프로그래머스 Lv.2 - 괄호 회전하기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241202/",
    
    "relUrl": "/docs/codingtest/1day1coding/241202/"
  },"388": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 다단계 칫솔 판매\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/77486\" . ",
    "url": "/docs/codingtest/1day1coding/241204/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/#문제"
  },"389": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "문제 풀이",
    "content": "문제 접근 . | 데이터 준비: | . | enroll: 멤버 이름을 기준으로 인덱스를 매핑합니다. | referral: 각 멤버의 추천인을 ref_index 배열로 변환합니다. 추천인이 없으면 -1로 설정합니다. | seller: 판매자의 인덱스를 sel_index 배열로 변환합니다. | 수익 분배 계산: | . | 각 판매자가 발생시킨 판매 금액(amount)에 대해, 총 수익을 계산하고 이를 추천 구조를 따라 분배합니다. | 수익의 10%를 추천인에게 전달하며, 남은 금액은 현재 판매자의 수익으로 기록됩니다. | 이 과정을 추천 체계의 끝까지 반복하거나, 분배할 금액이 1 미만일 때 종료합니다. | 결과 반환: | . | 최종적으로 각 판매자의 수익을 answer 배열에 저장하여 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(enroll, referral, seller, amount): answer = array of zeros with size of enroll ref_index = map referral to index of enroll (or -1 if no referral) sel_index = map seller to index of enroll . | . for i from 0 to length of seller - 1: index = sel_index[i] // current seller’s index money = amount[i] * 100 // total revenue from sales . while index is not -1: reward = floor(money * 0.1) // 10% of revenue if ref_index[index] is -1: // no referral add (money - reward) to answer[index] else if reward &lt; 1: // if reward is too small add money to answer[index] break else: add (money - reward) to answer[index] index = ref_index[index] // move to next referral money = reward // pass reward upwards . return answer . | . --- ## 풀이 코드 ```java [Type/Paste Your Code](&lt;import java.util.*; class Solution { public int[] solution(String[] enroll, String[] referral, String[] seller, int[] amount) { int[] answer = new int[enroll.length]; int[] ref_index = new int[referral.length]; int[] sel_index = new int[seller.length]; ArrayList%3CString%3E en_str = new ArrayList&lt;&gt;(Arrays.asList(enroll)); // init for (int i = 0; i &lt; enroll.length; i++) { answer[i] = 0; ref_index[i] = en_str.indexOf(referral[i]); // ref에 해당되는 인덱스 저장, \"-\"는 -1 } for (int i = 0; i &lt; seller.length; i++) { sel_index[i] = en_str.indexOf(seller[i]); } // calculation for (int i = 0; i &lt; seller.length; i++) { int index = sel_index[i]; // seller의 인덱스 int money = amount[i] * 100; // seller의 판매 수입 while (index != -1) { int reward = (int)(money * 0.1); if (ref_index[index] == -1) { answer[index] += money - reward; } else if (reward &lt; 1) { answer[index] += money; } else { answer[index] += money - reward; } index = ref_index[index]; money = reward; } } return answer; } }&gt;) . ",
    "url": "/docs/codingtest/1day1coding/241204/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/#문제-풀이"
  },"390": {
    "doc": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "title": "프로그래머스 Lv.3 - 다단계 칫솔 판매",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241204/",
    
    "relUrl": "/docs/codingtest/1day1coding/241204/"
  },"391": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "문제",
    "content": ". | 링크 title: \"프로그래머스\" image: \"https://school.programmers.co.kr/assets/img-meta-programmers-411e94bf29153dc31004168e6cd500279b1a531a23689303755e51971dee4526.png\" description: \"SW개발자를 위한 평가, 교육, 채용까지 Total Solution을 제공하는 개발자 성장을 위한 베이스캠프\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/131130\" . ",
    "url": "/docs/codingtest/1day1coding/241209/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/#문제"
  },"392": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "문제 풀이",
    "content": "문제 접근 . 이 코드는 주어진 카드 배열에서 상자에 들어 있는 카드들이 순서대로 연결된 순환 구조를 따라가며, 두 개의 가장 큰 상자 크기를 찾아 그 값을 곱한 결과를 반환하는 문제를 해결합니다. 접근 방법의 핵심은 다음과 같습니다: . | . | 카드 배열의 수정: . | 카드 배열의 값은 1-based 인덱스(1부터 시작)로 되어 있으므로, 이를 0-based 인덱스(0부터 시작)로 변환하여 처리합니다. | . | 순환 구조 탐색: . | 각 카드 번호를 따라가며, 순환하는 상자들을 방문합니다. 이미 방문한 상자는 다시 방문하지 않도록 visited 배열을 사용합니다. | 각 순환의 길이를 계산하여 boxes 리스트에 저장합니다. | . | 가장 큰 상자 크기 계산: . | boxes 리스트에서 상자의 크기를 내림차순으로 정렬한 후, 가장 큰 두 상자의 크기를 곱합니다. | . | 결과 반환: . | 가장 큰 두 상자의 크기를 곱한 값을 반환합니다. 간단한 수도 코드 정리 . ```pseudocode function solution(cards): answer = 0 visited = array of false with size of cards boxes = empty list . | . for i from 0 to length(cards) - 1: cards[i] = cards[i] - 1 // convert to 0-based index . for i from 0 to length(cards) - 1: if visited[i] is false: count = 0 index = i while visited[index] is false: visited[index] = true index = cards[index] // move to the next card in the cycle count += 1 add count to boxes . sort boxes in descending order . answer = boxes[0] * boxes[1] // multiply the two largest box sizes . return answer . | . --- ## 풀이 코드 ```java import java.util.*; class Solution { public int solution(int[] cards) { int answer = 0; boolean[] visited = new boolean[cards.length]; ArrayList&lt;Integer&gt; boxes = new ArrayList&lt;&gt;(); // 박스에 1번 상자만 존재하면 에러가 나기 때문에, 0을 하나 삽입 boxes.add(0); for (int i = 0; i&lt; cards.length; i++) { cards[i] = cards[i] - 1; } for (int i = 0; i &lt; cards.length; i++) { int count = 0; int index = i; while (!visited[index]) { visited[index] = true; index = cards[index]; count++; } boxes.add(count); } Collections.sort(boxes, Collections.reverseOrder()); answer = boxes.get(0) * boxes.get(1); System.out.println(boxes); return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/241209/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/#문제-풀이"
  },"393": {
    "doc": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "title": "프로그래머스 Lv.2 - 혼자 놀기의 달인",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/241209/",
    
    "relUrl": "/docs/codingtest/1day1coding/241209/"
  },"394": {
    "doc": "프로그래머스 Lv.3 - [1차] 추석 트래픽",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - [1차] 추석 트래픽\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/17676?language=java\" . ",
    "url": "/docs/codingtest/1day1coding/250202/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/250202/#문제"
  },"395": {
    "doc": "프로그래머스 Lv.3 - [1차] 추석 트래픽",
    "title": "문제 풀이",
    "content": "문제 접근 . | Date 타입의 String 변수에서 시간을 Int형으로 밀리초 단위로 저장한다. | 저장한 시간들의 끝지점에서 1초 구간으로 설정 . | 설정한 구간에 얼마나 겹치는지 체크 | . | 초당 최대 처리량을 max변수에 저장한다. 간단한 수도 코드 정리 . ```pseudocode solution(lines): times[], procs[] 초기화 . // 로그 데이터를 밀리초 단위로 변환하여 저장 for 각 로그 in lines: 종료 시간(times)과 처리 시간(procs) 계산 . max = 0 . // 각 로그의 종료 시간을 기준으로 1초 구간 확인 for i in times: windowStart = times[i] windowEnd = times[i] + 999 count = 0 . // 다른 로그들과 겹치는 개수 확인 for j in times: logStart = times[j] - procs[j] + 1 logEnd = times[j] if logEnd &gt;= windowStart AND logStart &lt;= windowEnd: count++ max = max(count, max) . return max . | . --- ## 풀이 코드 ```java class Solution { public int solution(String[] lines) { int answer = 0; int[] times = new int[lines.length]; int[] procs = new int [lines.length]; int max = 0; for (int i = 0; i &lt; lines.length; i++) { int time = 0; int proc = 0; // time time += Integer.parseInt(lines[i].substring(11, 13)) * 60 * 60 * 1000; time += Integer.parseInt(lines[i].substring(14, 16)) * 60 * 1000; time += Integer.parseInt(lines[i].substring(17, 19)) * 1000; time += Integer.parseInt(lines[i].substring(20, 23)); // proc String str = lines[i].substring(24).replace(\"s\", \"\"); float f = Float.parseFloat(str); proc = (int)(f * 1000); times[i] = time; procs[i] = proc; } // count max proc per 1 second for (int i = 0; i &lt; lines.length; i++) { int count = 0; // candidate window: [start, end] (즉, [times[i], times[i]+999]) int windowStart = times[i]; int windowEnd = times[i] + 999; for (int j = 0; j &lt; lines.length; j++) { int logStart = times[j] - procs[j] + 1; // 로그 j의 시작시간 int logEnd = times[j]; // 로그 j의 종료시간 // 두 구간이 겹치는지 판단 (로그의 종료시간이 windowStart 이상이고, 로그의 시작시간이 windowEnd 이하이면 겹침) if (logEnd &gt;= windowStart &amp;&amp; logStart &lt;= windowEnd) { count++; } } if (max &lt; count) { max = count; } } answer = max; return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/250202/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/250202/#문제-풀이"
  },"396": {
    "doc": "프로그래머스 Lv.3 - [1차] 추석 트래픽",
    "title": "프로그래머스 Lv.3 - [1차] 추석 트래픽",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250202/",
    
    "relUrl": "/docs/codingtest/1day1coding/250202/"
  },"397": {
    "doc": "프로그래머스 Lv.2 - N-Queen",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - N-Queen\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다.\" url: \"https://arc.net/l/quote/krooqkxt\" . | . ",
    "url": "/docs/codingtest/1day1coding/250203/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/250203/#문제"
  },"398": {
    "doc": "프로그래머스 Lv.2 - N-Queen",
    "title": "문제 풀이",
    "content": "문제 접근 . | 백트래킹을 사용하여, 퀸을 놓을 수 있는 자리에 놓아간다. 간단한 수도 코드 정리 . ```pseudocode 함수 solution(n): 열과 대각선을 체크할 배열 초기화 백트래킹 함수 호출 (첫 번째 행부터 시작) 가능한 배치 개수 반환 . | . 함수 backtrack(현재 행, n): 만약 모든 행에 퀸을 배치했다면: 배치 개수 증가 반환 . 각 열을 순회하며: 만약 현재 열 또는 대각선이 사용 중이라면: 건너뛰기 퀸을 현재 위치에 배치 다음 행으로 이동 (재귀 호출) 퀸을 제거 (백트래킹) . --- ## 풀이 코드 ```java class Solution { private int count = 0; // 가능한 배치 개수 private boolean[] col; // 열 체크 private boolean[] diag1; // \\ 방향 대각선 체크 private boolean[] diag2; // / 방향 대각선 체크 public int solution(int n) { col = new boolean[n]; diag1 = new boolean[2 * n - 1]; diag2 = new boolean[2 * n - 1]; backtrack(0, n); // 첫 번째 행부터 배치 시작 return count; } private void backtrack(int row, int n) { if (row == n) { // 모든 행을 채웠다면 경우의 수 증가 count++; return; } for (int c = 0; c &lt; n; c++) { // 각 열을 순회하며 퀸 배치 가능 여부 확인 if (col[c] || diag1[row + c] || diag2[row - c + (n - 1)]) { continue; // 현재 열 또는 대각선이 이미 사용 중이면 건너뛰기 } // 퀸 배치 col[c] = diag1[row + c] = diag2[row - c + (n - 1)] = true; // 다음 행으로 이동 backtrack(row + 1, n); // 퀸 제거 (백트래킹) col[c] = diag1[row + c] = diag2[row - c + (n - 1)] = false; } } } . ",
    "url": "/docs/codingtest/1day1coding/250203/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/250203/#문제-풀이"
  },"399": {
    "doc": "프로그래머스 Lv.2 - N-Queen",
    "title": "프로그래머스 Lv.2 - N-Queen",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250203/",
    
    "relUrl": "/docs/codingtest/1day1coding/250203/"
  },"400": {
    "doc": "TIL (25-02-03)",
    "title": "TIL - AWS DVA",
    "content": " ",
    "url": "/docs/tils/250203/#til---aws-dva",
    
    "relUrl": "/docs/tils/250203/#til---aws-dva"
  },"401": {
    "doc": "TIL (25-02-03)",
    "title": "2025.02.03 (MON)",
    "content": ". ",
    "url": "/docs/tils/250203/#20250203-mon",
    
    "relUrl": "/docs/tils/250203/#20250203-mon"
  },"402": {
    "doc": "TIL (25-02-03)",
    "title": "AWS",
    "content": " ",
    "url": "/docs/tils/250203/#aws",
    
    "relUrl": "/docs/tils/250203/#aws"
  },"403": {
    "doc": "TIL (25-02-03)",
    "title": "1️⃣ AWS API Gateway + Lambda",
    "content": ". | AWS Gateway는 api를 생성, 관리 등을 할 수 있는 서비스 (for AWS Service) | AWS Lambda는 AWS의 서버리스 컴퓨팅 서비스 . | 이 둘을 결합하면, HTTP 요청을 Gateway에서 수신하고, 이를 트리거로 Lambda 함수를 실행시켜 응답을 Gateway를 통해 반환하는 등, . | 아키텍처 구축 가능 | . | . ",
    "url": "/docs/tils/250203/#1%EF%B8%8F%E2%83%A3-aws-api-gateway--lambda",
    
    "relUrl": "/docs/tils/250203/#1️⃣-aws-api-gateway--lambda"
  },"404": {
    "doc": "TIL (25-02-03)",
    "title": "2️⃣ AWS Certificate Manager에서의 인증서 사용",
    "content": "us-east-2에 SSL/TLS 인증서를 통해 도메인을 구축한다고 하면, . | 동일한 리전이 아닌, SSL/TLS 인증서를 us-east-1 지역의 ACM으로 가져와서, 도메인에 대한 DNS CNAME 레코드를 만든다. | . ",
    "url": "/docs/tils/250203/#2%EF%B8%8F%E2%83%A3-aws-certificate-manager%EC%97%90%EC%84%9C%EC%9D%98-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/tils/250203/#2️⃣-aws-certificate-manager에서의-인증서-사용"
  },"405": {
    "doc": "TIL (25-02-03)",
    "title": "3️⃣ AWS Serverless Application Model (AWS SAM)",
    "content": ". | YAML에서 서버리스 리소스를 정의하는데 권장되는 서비스 | . ",
    "url": "/docs/tils/250203/#3%EF%B8%8F%E2%83%A3-aws-serverless-application-model-aws-sam",
    
    "relUrl": "/docs/tils/250203/#3️⃣-aws-serverless-application-model-aws-sam"
  },"406": {
    "doc": "TIL (25-02-03)",
    "title": "4️⃣ AWS Systems Manager Parameter Store",
    "content": ". | AWS CloudFormation 스택에서 실행되는 자동화 스크립트에서 라이선스 키에 액세스 해야할 때, 무료로 사용할 수 있다. | AWS Secrets Manager은 비용이 발생 | . | . ",
    "url": "/docs/tils/250203/#4%EF%B8%8F%E2%83%A3-aws-systems-manager-parameter-store",
    
    "relUrl": "/docs/tils/250203/#4️⃣-aws-systems-manager-parameter-store"
  },"407": {
    "doc": "TIL (25-02-03)",
    "title": "5️⃣ 임시 파일",
    "content": "임시 파일을 만들어 AWS Lambda 함수를 설계한다면 임시파일은 /tmp 디렉토리에 저장되는 것이 가장 좋다. | 임시 파일이 이후에, 필요없다는 가정하에 | . ",
    "url": "/docs/tils/250203/#5%EF%B8%8F%E2%83%A3-%EC%9E%84%EC%8B%9C-%ED%8C%8C%EC%9D%BC",
    
    "relUrl": "/docs/tils/250203/#5️⃣-임시-파일"
  },"408": {
    "doc": "TIL (25-02-03)",
    "title": "데이터",
    "content": " ",
    "url": "/docs/tils/250203/#%EB%8D%B0%EC%9D%B4%ED%84%B0",
    
    "relUrl": "/docs/tils/250203/#데이터"
  },"409": {
    "doc": "TIL (25-02-03)",
    "title": "메타데이터",
    "content": "메타데이터란 데이터에 대한 데이터 . 데이터를 정의하고 기술하는 데이터 . ",
    "url": "/docs/tils/250203/#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0",
    
    "relUrl": "/docs/tils/250203/#메타데이터"
  },"410": {
    "doc": "TIL (25-02-03)",
    "title": "TIL (25-02-03)",
    "content": " ",
    "url": "/docs/tils/250203/",
    
    "relUrl": "/docs/tils/250203/"
  },"411": {
    "doc": "프로그래머스 Lv.3 - 베스트앨범",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 베스트앨범\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/42579\" . | . ",
    "url": "/docs/codingtest/1day1coding/250205/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/250205/#문제"
  },"412": {
    "doc": "프로그래머스 Lv.3 - 베스트앨범",
    "title": "문제 풀이",
    "content": "문제 접근 . | 해시맵 사용 | 아래와 같음 간단한 수도 코드 정리 . ```pseudocode . | 각 장르별 총 재생 횟수 계산: | . | genreCount[장르] = 총 재생 횟수 | . | . | 각 장르별 상위 2개의 곡 찾기: . | map[장르] = [가장 많이 재생된 곡들 (최대 2곡)] | . | 장르별로 총 재생 횟수 내림차순 정렬: . | genreRank = 장르 리스트를 genreCount 기준으로 내림차순 정렬 | . | 결과 리스트에 상위 곡들의 인덱스 추가: . | for (장르 in genreRank) { . | for (곡 in map[장르]) { . | 결과 리스트에 곡의 인덱스를 추가 | 해당 곡의 인덱스는 이미 선택된 곡으로 처리 } } | . | . | . | 결과 리스트를 배열로 변환하여 반환: . | return 결과 리스트를 배열로 변환 | . | . --- ## 풀이 코드 ```java import java.util.*; import java.util.stream.Collectors; // 추가 class Solution { public int[] solution(String[] genres, int[] plays) { int[] answer = {}; HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); HashMap&lt;String, Integer&gt; genreCount = new HashMap&lt;&gt;(); List&lt;Integer&gt; playList = Arrays.stream(plays) .boxed() // int를 Integer로 변환 .collect(Collectors.toList()); // 리스트로 변환 // set map for (int i = 0; i &lt; genres.length; i++) { // genresCount if (genreCount.containsKey(genres[i])) { genreCount.put(genres[i], genreCount.get(genres[i]) + plays[i]); } else { genreCount.put(genres[i], plays[i]); } // map if (map.containsKey(genres[i])) { if (map.get(genres[i]).size() &lt; 2) { map.get(genres[i]).add(plays[i]); Collections.sort(map.get(genres[i]), Collections.reverseOrder()); } else { if (plays[i] &gt; map.get(genres[i]).get(0)) { map.get(genres[i]).add(0, plays[i]); map.get(genres[i]).remove(2); } else if (plays[i] &gt; map.get(genres[i]).get(1)) { map.get(genres[i]).add(1, plays[i]); map.get(genres[i]).remove(2); } } } else { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(plays[i]); map.put(genres[i], list); } } // sort genreCount List&lt;String&gt; genreRank = new ArrayList&lt;&gt;(genreCount.keySet()); genreRank.sort(new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return genreCount.get(o2).compareTo(genreCount.get(o1)); } }); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (String gen : genreRank) { for (Integer play : map.get(gen)) { result.add(playList.indexOf(play)); playList.set(playList.indexOf(play), -1); } } answer = result.stream().mapToInt(Integer::intValue).toArray(); return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/250205/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/250205/#문제-풀이"
  },"413": {
    "doc": "프로그래머스 Lv.3 - 베스트앨범",
    "title": "프로그래머스 Lv.3 - 베스트앨범",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250205/",
    
    "relUrl": "/docs/codingtest/1day1coding/250205/"
  },"414": {
    "doc": "TIL (25-02-17)",
    "title": "TIL - AWS DVA",
    "content": " ",
    "url": "/docs/tils/250217/#til---aws-dva",
    
    "relUrl": "/docs/tils/250217/#til---aws-dva"
  },"415": {
    "doc": "TIL (25-02-17)",
    "title": "2025.02.17 (MON)",
    "content": ". ",
    "url": "/docs/tils/250217/#20250217-mon",
    
    "relUrl": "/docs/tils/250217/#20250217-mon"
  },"416": {
    "doc": "TIL (25-02-17)",
    "title": "AWS",
    "content": " ",
    "url": "/docs/tils/250217/#aws",
    
    "relUrl": "/docs/tils/250217/#aws"
  },"417": {
    "doc": "TIL (25-02-17)",
    "title": "1️⃣ AWS Lambda의 event, context 객체",
    "content": ". | AWS Lambda를 사용하면 event와 context라는 Lambda가 호출될 때 제공하는 기본 파라미터이다. ```javascript function handler(event, context) { | . } ``` . | event 객체 : 다른 AWS 서비스의 데이터 | context 객체 : Lambda의 메타 데이터 (ex). Lambda 함수의 이름, 함수 버전 등) | . 따라서, context 객체에서 AWS 요청 ID 필드에서 요청 식별자를 가져온다. +) 로그를 표준 출력에 쓰면 CloudWatch Logs에 자동으로 캡쳐된다. ",
    "url": "/docs/tils/250217/#1%EF%B8%8F%E2%83%A3-aws-lambda%EC%9D%98-event-context-%EA%B0%9D%EC%B2%B4",
    
    "relUrl": "/docs/tils/250217/#1️⃣-aws-lambda의-event-context-객체"
  },"418": {
    "doc": "TIL (25-02-17)",
    "title": "2️⃣ DynamoDB Stream VS Kinesis Stream",
    "content": "일단 DynamoDB는 AWS에서 제공하는 완전 관리형 NoSQL 데이터베이스이다. =&gt; 키-값 기반의 데이터 모델 . DynamoDB Stream . | DynamoDB 테이블에서 발생하는 모든 변경 사항을 캡처하고, 변경사항을 실시간으로 스트리밍 하는 서비스 (비동기적 처리) | Lambda 함수를 사용하여 DynamoDB Stream을 처리하고, 해당 데이터를 다른 AWS 서비스에 전달 가능 | 24시간 동안 보존 | . Kinesis Stream . | 대규모 스트리밍 데이터 수집, 처리 및 분석에 사용되는 완전 관리형 스트리밍 데이터 서비스 | 24시간 동안 저장, 필요 시 더 오래 저장 가능 | 스트림 데이터 분석 -&gt; Kinesis Analytics | 스트림 데이터 수집 및 저장 -&gt; Kinesis Firehose | IoT, 모바일 어플리케이션, 로그 데이터 처리, 실시간 메트릭 처리 | . ",
    "url": "/docs/tils/250217/#2%EF%B8%8F%E2%83%A3-dynamodb-stream-vs-kinesis-stream",
    
    "relUrl": "/docs/tils/250217/#2️⃣-dynamodb-stream-vs-kinesis-stream"
  },"419": {
    "doc": "TIL (25-02-17)",
    "title": "3️⃣ Auto Scaling",
    "content": ". | CPU, 메모리, 디스크, 네트워크 트래픽과 같은 시스템 자원들의 메트릭(Metric) 값을 모니터링하여 서버 사이즈를 자동으로 조절 | 클라우드의 유연성을 돋보이게 하는 기술 | . ",
    "url": "/docs/tils/250217/#3%EF%B8%8F%E2%83%A3-auto-scaling",
    
    "relUrl": "/docs/tils/250217/#3️⃣-auto-scaling"
  },"420": {
    "doc": "TIL (25-02-17)",
    "title": "4️⃣ AWS CodeDeploy",
    "content": ". | AWS에서 제공하는 배포서비스 | . ",
    "url": "/docs/tils/250217/#4%EF%B8%8F%E2%83%A3-aws-codedeploy",
    
    "relUrl": "/docs/tils/250217/#4️⃣-aws-codedeploy"
  },"421": {
    "doc": "TIL (25-02-17)",
    "title": "5️⃣ AWS Secrets Manager",
    "content": ". | 자체 인프라 운영에 대한 애플리케이션, 서비스 및 IT 리소스에 대한 액세스를 보호할 수 있따. | 데이터베이스 자격 증명, 온프레미스 리소스 자격 증명, SaaS 애플리케이션 암호 및 SSH 키 등을 관리 | 비밀에 대한 자동 로테이션을 활성화할 수 있다. | . ",
    "url": "/docs/tils/250217/#5%EF%B8%8F%E2%83%A3-aws-secrets-manager",
    
    "relUrl": "/docs/tils/250217/#5️⃣-aws-secrets-manager"
  },"422": {
    "doc": "TIL (25-02-17)",
    "title": "6️⃣ API Gateway REST API를 이용해서 백엔드 서비스를 호출하지 않고 백엔드 응답을?",
    "content": ". | 응답 코드 매핑 템플릿을 사용하여 모의 통합 응답을 선택 | . ",
    "url": "/docs/tils/250217/#6%EF%B8%8F%E2%83%A3-api-gateway-rest-api%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%9D%91%EB%8B%B5%EC%9D%84",
    
    "relUrl": "/docs/tils/250217/#6️⃣-api-gateway-rest-api를-이용해서-백엔드-서비스를-호출하지-않고-백엔드-응답을"
  },"423": {
    "doc": "TIL (25-02-17)",
    "title": "7️⃣ Amazon CloudWatch",
    "content": ". | AWS 리소스와, AWS에서 실시간으로 실행 중인 애플리케이션을 모니터링 하는 시스템 | . ",
    "url": "/docs/tils/250217/#7%EF%B8%8F%E2%83%A3-amazon-cloudwatch",
    
    "relUrl": "/docs/tils/250217/#7️⃣-amazon-cloudwatch"
  },"424": {
    "doc": "TIL (25-02-17)",
    "title": "TIL (25-02-17)",
    "content": " ",
    "url": "/docs/tils/250217/",
    
    "relUrl": "/docs/tils/250217/"
  },"425": {
    "doc": "TIL (25-02-22)",
    "title": "TIL - AWS DVA",
    "content": " ",
    "url": "/docs/tils/250222/#til---aws-dva",
    
    "relUrl": "/docs/tils/250222/#til---aws-dva"
  },"426": {
    "doc": "TIL (25-02-22)",
    "title": "2025.02.22 (SAT)",
    "content": ". ",
    "url": "/docs/tils/250222/#20250222-sat",
    
    "relUrl": "/docs/tils/250222/#20250222-sat"
  },"427": {
    "doc": "TIL (25-02-22)",
    "title": "AWS",
    "content": " ",
    "url": "/docs/tils/250222/#aws",
    
    "relUrl": "/docs/tils/250222/#aws"
  },"428": {
    "doc": "TIL (25-02-22)",
    "title": "1️⃣ 전송 스트림",
    "content": ". | 데이터를 수집하고 지정된 대상으로 전송하는 데이터 파이프라인 . | 중간 역할 (데이터 -&gt; 전송 스트림 -&gt; 목적지) | . | . ",
    "url": "/docs/tils/250222/#1%EF%B8%8F%E2%83%A3-%EC%A0%84%EC%86%A1-%EC%8A%A4%ED%8A%B8%EB%A6%BC",
    
    "relUrl": "/docs/tils/250222/#1️⃣-전송-스트림"
  },"429": {
    "doc": "TIL (25-02-22)",
    "title": "TIL (25-02-22)",
    "content": " ",
    "url": "/docs/tils/250222/",
    
    "relUrl": "/docs/tils/250222/"
  },"430": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "문제",
    "content": ". | 링크 title: \"코딩테스트 연습 - 야근 지수\" image: \"https://image.freepik.com/free-vector/landing-page-template-for-a-website_23-2147782747.jpg\" description: \"회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.\" url: \"https://school.programmers.co.kr/learn/courses/30/lessons/12927\" . | . ",
    "url": "/docs/codingtest/1day1coding/250224/#%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/#문제"
  },"431": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "문제 풀이",
    "content": "문제 접근 . 처음 문제를 접했을 때, 가장 큰 작업량을 우선적으로 줄여야 피로도를 최소화할 수 있다고 생각했습니다. 따라서, 작업량을 내림차순 정렬한 후 가장 큰 값부터 감소시키는 방법을 고민했습니다. | 초기 접근 방법: . | 작업량을 내림차순 정렬 | 가장 큰 값을 선택하여 n시간 동안 반복해서 1씩 감소 | 감소 후 다시 정렬 반복 | . | 문제점 발견: . | 매 반복마다 Arrays.sort() 사용 → 시간 복잡도 O(n * m log m) | 효율성 테스트에서 실패 (특히 n과 작업량 개수가 클 때 시간 초과 발생) | . | 개선 아이디어: 가장 큰 값을 빠르게 찾아서 수정하려면 힙 자료구조 사용이 적합합니다. 자바의 우선순위 큐(PriorityQueue)를 최대 힙 형태로 사용하면, 가장 큰 값 추출 &amp; 삽입을 O(log m)으로 처리할 수 있어 효율성 문제 해결에 도움이 됩니다. | . 간단한 수도 코드 정리 . 1. works 배열을 최대 힙에 추가 2. n 시간 동안 반복: - 가장 큰 값 추출 - 값이 0이면 반복 중단 (작업 끝) - 값 감소 후 힙에 다시 추가 3. 남은 작업량 제곱 합을 계산하여 반환 . ",
    "url": "/docs/codingtest/1day1coding/250224/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/#문제-풀이"
  },"432": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "풀이 코드",
    "content": "import java.util.*; class Solution { public long solution(int n, int[] works) { // 최대 힙 생성 PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // 작업량 큐에 추가 for (int work : works) { pq.offer(work); } // N 시간 동안 가장 큰 작업량 처리 for (int i = 0; i &lt; n; i++) { int max = pq.poll(); // 가장 큰 값 추출 if (max == 0) break; // 남은 작업이 없으면 중단 pq.offer(max - 1); // 작업량 감소 후 재삽입 } // 야근 피로도 계산 long answer = 0; for (int work : pq) { answer += (long) work * work; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/250224/#%ED%92%80%EC%9D%B4-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/#풀이-코드"
  },"433": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "오류 해결",
    "content": "❌ 발생한 문제: . | 문제 상황: 초기 코드에서는 매 반복마다 Arrays.sort()를 호출했습니다. Arrays.sort(sortWorks, Collections.reverseOrder()); . | 에러 원인: . | Arrays.sort()의 시간 복잡도: O(m log m) | 이를 n번 반복하면 O(n * m log m)으로 비효율적 | 결국, 효율성 테스트 실패 (시간 초과) 문제 발생 | . | . ✅ 해결 과정: . | 최대 힙 사용 (PriorityQueue) → O(log m)로 개선 | 정렬 반복 제거 후, 가장 큰 값 추출 및 삽입만 반복 | . ✅ 결과: 효율성 통과 + 빠른 실행 시간 확보! . ",
    "url": "/docs/codingtest/1day1coding/250224/#%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/#오류-해결"
  },"434": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "느낀점 &amp; 회고",
    "content": ". | 처음엔 단순히 정렬로 접근했지만, 효율성 문제를 고려하지 못했던 점을 깨달았습니다. | 문제에서 “가장 큰 값을 반복적으로 선택”하는 상황이라면 힙 자료구조를 떠올려야 한다는 교훈을 얻었습니다. | 실제로 우선순위 큐를 활용하니, 시간 초과 문제가 깔끔하게 해결되었습니다! 😎 | . ✅ 앞으로도 비슷한 문제에서 정렬 반복 대신 우선순위 큐 사용을 적극 고려하기! . ",
    "url": "/docs/codingtest/1day1coding/250224/#%EB%8A%90%EB%82%80%EC%A0%90--%ED%9A%8C%EA%B3%A0",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/#느낀점--회고"
  },"435": {
    "doc": "프로그래머스 Lv.3 - 야근 지수",
    "title": "프로그래머스 Lv.3 - 야근 지수",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250224/",
    
    "relUrl": "/docs/codingtest/1day1coding/250224/"
  },"436": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "📌 프로그래머스 - 뒤에 있는 큰 수 찾기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250304/#-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4---%EB%92%A4%EC%97%90-%EC%9E%88%EB%8A%94-%ED%81%B0-%EC%88%98-%EC%B0%BE%EA%B8%B0",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-프로그래머스---뒤에-있는-큰-수-찾기"
  },"437": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "🔍 문제 설명",
    "content": "정수로 이루어진 배열 numbers가 주어집니다. 각 원소에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 찾습니다. 뒷 큰수가 존재하지 않는 경우 -1을 반환합니다. ✅ 제한 사항 . | 4 ≤ numbers의 길이 ≤ 1,000,000 | 1 ≤ numbers[i] ≤ 1,000,000 | . 📌 입출력 예시 . | numbers | result | . | [2, 3, 3, 5] | [3, 5, 5, -1] | . | [9, 1, 5, 3, 6, 2] | [-1, 5, 6, 6, -1, -1] | . ",
    "url": "/docs/codingtest/1day1coding/250304/#-%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-문제-설명"
  },"438": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "🔑 문제 접근",
    "content": "❌ 처음 접근: 이중 반복문 (O(N²)) . 가장 먼저 떠오르는 방법은 각 숫자에 대해 뒤의 숫자들을 순차적으로 탐색하는 방식이었습니다. 하지만 이 방식은 최악의 경우 O(N²)으로 시간 초과가 발생했습니다. 예제 코드 (비효율적인 접근) . public int[] solution(int[] numbers) { int[] answer = new int[numbers.length]; for (int i = 0; i &lt; numbers.length - 1; i++) { int max = -1; for (int j = i + 1; j &lt; numbers.length; j++) { if (numbers[j] &gt; numbers[i]) { max = numbers[j]; break; } } answer[i] = max; } answer[numbers.length - 1] = -1; return answer; } . ✅ 작은 입력에서는 정상적으로 동작하지만, numbers가 100만 개 이상이면 시간 초과 발생! . ",
    "url": "/docs/codingtest/1day1coding/250304/#-%EB%AC%B8%EC%A0%9C-%EC%A0%91%EA%B7%BC",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-문제-접근"
  },"439": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "💡 스택을 활용한 O(N) 풀이",
    "content": "🔹 핵심 아이디어 . | 뒤에서부터 탐색하면서 스택을 활용하여 해결 | 현재 숫자보다 작은 값들은 스택에서 제거 (어차피 필요 없음) | 스택의 top이 현재 숫자의 뒷 큰수 | 없으면 -1 | . 🛠 코드 구현 . import java.util.Stack; class Solution { public int[] solution(int[] numbers) { int[] answer = new int[numbers.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 마지막 원소는 항상 -1 stack.push(numbers[numbers.length - 1]); answer[numbers.length - 1] = -1; for (int i = numbers.length - 2; i &gt;= 0; i--) { int max = -1; // 스택의 top이 현재 숫자보다 작거나 같으면 pop while (!stack.isEmpty()) { if (stack.peek() &gt; numbers[i]) { max = stack.peek(); break; } else { stack.pop(); } } stack.push(numbers[i]); // 현재 원소를 스택에 추가 answer[i] = max; } return answer; } } . ",
    "url": "/docs/codingtest/1day1coding/250304/#-%EC%8A%A4%ED%83%9D%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-on-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-스택을-활용한-on-풀이"
  },"440": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "⏱ 시간 복잡도 분석",
    "content": ". | 각 원소는 최대 한 번만 push &amp; pop 되므로 O(N) | 최적화 성공 🎉 (이전 O(N²) → O(N)) | . ",
    "url": "/docs/codingtest/1day1coding/250304/#-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-시간-복잡도-분석"
  },"441": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "📌 정리",
    "content": "| 접근 방식 | 시간 복잡도 | 설명 | . | 이중 반복문 | O(N²) | 하나씩 비교 → 시간 초과 | . | 스택 활용 | O(N) | 뒷 큰수만 효율적으로 관리 | . 💡 핵심 포인트 . | 스택을 사용하면 불필요한 탐색을 줄일 수 있다! | 뒤에서부터 탐색하며 뒷 큰수를 찾는 패턴을 기억하자! | . ",
    "url": "/docs/codingtest/1day1coding/250304/#-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/#-정리"
  },"442": {
    "doc": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "title": "프로그래머스 Lv.2 - 뒤에 있는 큰 수 찾기",
    "content": " ",
    "url": "/docs/codingtest/1day1coding/250304/",
    
    "relUrl": "/docs/codingtest/1day1coding/250304/"
  },"443": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "서버-클라이언트 연동 문제 해결 및 기능 개선",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250620/#%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%97%B0%EB%8F%99-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EB%B0%8F-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/gameadvisor/250620/#서버-클라이언트-연동-문제-해결-및-기능-개선"
  },"444": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "개요",
    "content": "오늘은 서버와 클라이언트를 연동하면서 생긴 문제들을 해결하고, 더 나은 사용자 경험을 제공하는 데 집중했습니다. 여러 기술적인 문제들을 해결하면서 애플리케이션의 완성도를 높일 수 있었습니다. ",
    "url": "/docs/projects/gameadvisor/250620/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/gameadvisor/250620/#개요"
  },"445": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "주요 해결 문제",
    "content": "서버-클라이언트 연동 문제 해결 . | 서버 연결 오류 (java.net.ConnectException) . | 원인: 잘못된 경로에서 백엔드 서버를 실행하는 바람에 서버가 정상적으로 구동되지 않았습니다. | 해결: 올바른 backend 디렉토리로 이동해 서버를 재시작하여 간단히 해결했습니다. | . | 인증 문제 (401 Unauthorized) . | 원인: 클라이언트에서 API를 호출할 때마다 401 Unauthorized 오류가 발생했는데, 원인은 Spring Security의 기본 설정 때문이었습니다. | 해결: build.gradle 파일에서 Spring Security 관련 의존성을 제거하여 문제를 해결했습니다. | . | 데이터베이스 초기화 문제 . | 원인: API를 요청해도 데이터 없이 빈 목록만 돌아오는 현상이 있었습니다. 확인해보니 data.sql 스크립트가 실행되지 않은 것이 문제였습니다. | 해결: application.properties 파일에 spring.jpa.defer-datasource-initialization=true와 spring.sql.init.mode=always 두 줄을 추가하여, 서버가 켜질 때 데이터가 자동으로 들어가도록 수정했습니다. | . | . 클라이언트 기능 개선 및 오류 수정 . | UI 메시지 개선 . | 클라이언트에서 게임 탐색 상태에 따라 “탐색 중…”, “현재 플레이 중: [게임 이름]”, “실행 중인 게임을 찾을 수 없습니다.”와 같이 명확한 한글 메시지를 표시하도록 UI 로직을 개선했습니다. | 메시지가 깜빡이는 현상을 해결해 사용자 경험을 향상시켰습니다. | . | 빌드 오류 해결 . | 원인: Game 클래스를 찾지 못하는 import 오류가 계속 발생했는데, 이는 Gradle의 빌드 캐시 문제였습니다. | 해결: clean build 명령어로 프로젝트를 새로 빌드하여 캐시 문제를 해결했습니다. | . | . ",
    "url": "/docs/projects/gameadvisor/250620/#%EC%A3%BC%EC%9A%94-%ED%95%B4%EA%B2%B0-%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/projects/gameadvisor/250620/#주요-해결-문제"
  },"446": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "Git 버전 관리",
    "content": ". | 오늘 작업한 내용들은 “feat: 서버-클라이언트 연동 및 게임 프로세스 스캔 기능 구현”이라는 커밋으로 묶어서 원격 저장소에 업로드했습니다. | . ",
    "url": "/docs/projects/gameadvisor/250620/#git-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/projects/gameadvisor/250620/#git-버전-관리"
  },"447": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "결론",
    "content": "오늘은 백엔드에서 발생했던 연결, 인증, DB 초기화 문제를 해결하고, 클라이언트의 UI와 빌드 오류까지 수정하며 전반적인 안정성을 높인 하루였습니다. 이제 서버와 클라이언트가 문제없이 통신하고, 사용자는 실행 중인 게임 정보도 제대로 확인할 수 있게 되었습니다. ",
    "url": "/docs/projects/gameadvisor/250620/#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/projects/gameadvisor/250620/#결론"
  },"448": {
    "doc": "서버-클라이언트 연동 문제 해결",
    "title": "서버-클라이언트 연동 문제 해결",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250620/",
    
    "relUrl": "/docs/projects/gameadvisor/250620/"
  },"449": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250629/",
    
    "relUrl": "/docs/projects/gameadvisor/250629/"
  },"450": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "시작하며",
    "content": "최근 GameAdvisor 프로젝트에서 클라이언트 UI를 한 단계 업그레이드하는 작업을 진행하였습니다. 단순한 정보 제공을 넘어, 게임 화면 위에 자연스럽게 녹아드는 오버레이 클라이언트와 실시간 날짜/시간 표시 기능을 구현하는 것을 목표로 삼았습니다. 실제로 구현하면서 겪었던 시행착오와 고민, 그리고 얻은 결과를 정리하여 공유드립니다. ",
    "url": "/docs/projects/gameadvisor/250629/#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0",
    
    "relUrl": "/docs/projects/gameadvisor/250629/#시작하며"
  },"451": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "오버레이 클라이언트 UI 개선",
    "content": "기존에는 JavaFX로 만든 단순한 창이었지만, 이번에는 게임 플레이에 방해되지 않으면서도 정보를 직관적으로 전달해드릴 수 있도록 여러 UI 요소를 개선하였습니다. | 항상 최상단(오버레이) 표시: 클라이언트 창이 게임 화면 위에 겹쳐서 항상 보이도록 설정하였습니다. 덕분에 게임 중에도 필요한 정보를 즉시 확인하실 수 있습니다. | 좌측 상단 고정: 오버레이가 화면의 좌측 상단에 고정되어, 시야를 가리지 않으면서도 눈에 잘 띄게 배치하였습니다. | 반투명 효과 적용: 배경 투명도를 70%로 설정하여, 게임 화면과 자연스럽게 어우러지도록 디자인하였습니다. | 크기 조정: 창 크기를 400x200으로 줄여, 화면을 최소한만 차지하도록 하였습니다. | . ",
    "url": "/docs/projects/gameadvisor/250629/#%EC%98%A4%EB%B2%84%EB%A0%88%EC%9D%B4-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-ui-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/gameadvisor/250629/#오버레이-클라이언트-ui-개선"
  },"452": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "서버 연동 및 실시간 날짜/시간 표시",
    "content": "UI만 예쁘게 바꾼 것이 아니라, 서버와의 연동을 통해 실시간 정보를 제공하는 기능도 추가하였습니다. | 날짜/시간 API 구현: Spring Boot 백엔드에 /api/games/date 엔드포인트를 만들어, 서버의 현재 날짜와 시간을 반환하도록 하였습니다. | 클라이언트에서 실시간 표시: 클라이언트는 1초마다 서버에 요청을 보내, 최신 날짜와 시간을 받아와 오버레이 우측 상단에 표시합니다. 서버와의 연결 상태도 직관적으로 확인하실 수 있습니다. | . ",
    "url": "/docs/projects/gameadvisor/250629/#%EC%84%9C%EB%B2%84-%EC%97%B0%EB%8F%99-%EB%B0%8F-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%82%A0%EC%A7%9C%EC%8B%9C%EA%B0%84-%ED%91%9C%EC%8B%9C",
    
    "relUrl": "/docs/projects/gameadvisor/250629/#서버-연동-및-실시간-날짜시간-표시"
  },"453": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "개발 과정에서의 고민과 시행착오",
    "content": ". | macOS 환경에서 JavaFX 오버레이가 제대로 동작하지 않는 경우가 많아, StageStyle, setAlwaysOnTop 등 다양한 옵션을 실험하였습니다. | 날짜/시간 동기화를 위해 REST API 통신을 주기적으로 처리하는 구조를 설계하였습니다. | UI 요소 배치(BorderPane, Label 정렬 등)와 시인성(폰트, 색상, 투명도)에도 신경을 많이 썼습니다. | . ",
    "url": "/docs/projects/gameadvisor/250629/#%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C%EC%9D%98-%EA%B3%A0%EB%AF%BC%EA%B3%BC-%EC%8B%9C%ED%96%89%EC%B0%A9%EC%98%A4",
    
    "relUrl": "/docs/projects/gameadvisor/250629/#개발-과정에서의-고민과-시행착오"
  },"454": {
    "doc": "오버레이 클라이언트 및 실시간 날짜 표시 기능 구현기",
    "title": "결과 및 느낀 점",
    "content": "이번 개선을 통해 GameAdvisor 클라이언트는 단순 정보 제공을 넘어, 실시간으로 변화하는 정보를 직관적으로 보여드릴 수 있는 오버레이 도구로 발전하였습니다. 게임을 하시면서도 방해받지 않고 필요한 정보를 한눈에 확인하실 수 있다는 점에서 사용자 경험이 크게 향상되었습니다. 이 글은 실제 개발 경험을 바탕으로 작성되었습니다. 코드와 더 구체적인 시행착오, 배운 점 등은 추후 별도 포스팅에서 자세히 다룰 예정이오니 많은 관심 부탁드립니다. ",
    "url": "/docs/projects/gameadvisor/250629/#%EA%B2%B0%EA%B3%BC-%EB%B0%8F-%EB%8A%90%EB%82%80-%EC%A0%90",
    
    "relUrl": "/docs/projects/gameadvisor/250629/#결과-및-느낀-점"
  },"455": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250630/",
    
    "relUrl": "/docs/projects/gameadvisor/250630/"
  },"456": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "들어가며",
    "content": "GameAdvisor 프로젝트를 개발하면서, “내 컴퓨터에서는 잘 되는데?”라는 흔한 함정에 빠졌던 경험을 공유드리고자 합니다. 이번에는 윈도우 환경에서 게임 프로세스 감지 기능이 제대로 동작하지 않는 문제를 직접 겪으면서, 운영체제별 차이를 실감하게 되었습니다. ",
    "url": "/docs/projects/gameadvisor/250630/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#들어가며"
  },"457": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "문제 상황: 윈도우에서 감지가 안 된다?",
    "content": "처음에는 macOS와 리눅스에서 아무 문제 없이 동작하던 게임 프로세스 감지 기능이, 윈도우에서는 전혀 작동하지 않았습니다. 단순한 코드 오류나 경로 문제라고 생각했지만, 로그를 아무리 살펴봐도 원인을 찾을 수 없었습니다. ",
    "url": "/docs/projects/gameadvisor/250630/#%EB%AC%B8%EC%A0%9C-%EC%83%81%ED%99%A9-%EC%9C%88%EB%8F%84%EC%9A%B0%EC%97%90%EC%84%9C-%EA%B0%90%EC%A7%80%EA%B0%80-%EC%95%88-%EB%90%9C%EB%8B%A4",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#문제-상황-윈도우에서-감지가-안-된다"
  },"458": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "원인 분석: 명령어의 차이",
    "content": "문제의 핵심은 바로 운영체제별로 지원하는 명령어의 차이였습니다. 기존에는 유닉스 계열에서 널리 쓰이는 ‘ps’ 명령어를 사용해 실행 중인 프로세스 목록을 가져왔는데, 윈도우에서는 이 명령어 자체가 존재하지 않았던 것입니다. 실제로 윈도우 명령 프롬프트에서 ‘ps’를 입력하면 ‘명령을 찾을 수 없습니다’라는 메시지만 출력됩니다. ",
    "url": "/docs/projects/gameadvisor/250630/#%EC%9B%90%EC%9D%B8-%EB%B6%84%EC%84%9D-%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#원인-분석-명령어의-차이"
  },"459": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "시행착오와 해결 과정",
    "content": ". | 코드 재점검: 우선 기존 코드를 꼼꼼히 살펴보며, 혹시 경로 문제나 인코딩 이슈가 있는지 확인했습니다. 하지만 macOS/리눅스에서는 정상 동작하는 코드라면 윈도우에서도 동작해야 한다는 막연한 기대가 있었던 것 같습니다. | 구글링과 공식 문서 탐색: ‘윈도우 프로세스 목록 명령어’, ‘ps 대체 명령어’ 등 다양한 키워드로 검색을 시작했습니다. 그 결과 윈도우에서는 ‘tasklist’라는 명령어를 사용해야 한다는 사실을 알게 되었습니다. | 운영체제 분기 처리: 자바 코드에서 운영체제를 감지한 뒤, 윈도우에서는 ‘tasklist’, macOS/리눅스에서는 ‘ps’를 사용하도록 분기 처리하는 로직을 새로 작성했습니다. | 테스트와 검증: 실제로 윈도우, 맥, 리눅스 환경에서 각각 테스트를 진행하여, 모든 환경에서 게임 프로세스 감지 기능이 정상적으로 동작하는지 꼼꼼히 확인했습니다. | . ",
    "url": "/docs/projects/gameadvisor/250630/#%EC%8B%9C%ED%96%89%EC%B0%A9%EC%98%A4%EC%99%80-%ED%95%B4%EA%B2%B0-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#시행착오와-해결-과정"
  },"460": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "실제 적용 코드 예시",
    "content": "아래는 운영체제별로 명령어를 분기 처리하는 자바 코드의 핵심 부분입니다. String os = System.getProperty(\"os.name\").toLowerCase(); Process process; if (os.contains(\"win\")) { process = Runtime.getRuntime().exec(\"tasklist\"); } else { process = Runtime.getRuntime().exec(\"ps -e\"); } // 이후 스트림을 읽어 프로세스 목록을 파싱 . 이렇게 분기 처리를 해주니, 윈도우 환경에서도 문제없이 프로세스 목록을 받아올 수 있었습니다. ",
    "url": "/docs/projects/gameadvisor/250630/#%EC%8B%A4%EC%A0%9C-%EC%A0%81%EC%9A%A9-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#실제-적용-코드-예시"
  },"461": {
    "doc": "운영체제별 게임 프로세스 감지 문제와 실전 해결기",
    "title": "자바에서 운영체제 분리 구현이란,,,",
    "content": "이번 경험을 통해, 실제 사용 환경을 꼼꼼히 고려하는 것이 얼마나 중요한지 다시 한 번 깨달았습니다. 개발자는 자신의 개발 환경에만 의존하지 말고, 다양한 운영체제와 상황을 염두에 두고 코드를 작성해야 한다는 점을 실감했습니다. 또한, 문제를 만났을 때 포기하지 않고 원인을 집요하게 파고드는 태도의 중요성도 다시 한 번 느꼈습니다. 이 글은 실제 개발 경험을 바탕으로 작성되었습니다. 추가적인 시행착오, 예외 처리, 그리고 더 복잡한 환경에서의 대응 방법 등은 추후 별도 포스팅에서 자세히 다룰 예정입니다. ",
    "url": "/docs/projects/gameadvisor/250630/#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%B6%84%EB%A6%AC-%EA%B5%AC%ED%98%84%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/projects/gameadvisor/250630/#자바에서-운영체제-분리-구현이란"
  },"462": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "Gemini API를 이용한 게임 분석 테스트",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250702/",
    
    "relUrl": "/docs/projects/gameadvisor/250702/"
  },"463": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "📋 오늘의 주요 성과",
    "content": "🤖 AI 화면 분석 시스템 완성 . 오늘 가장 핵심적인 기능인 Gemini Vision API 기반 실시간 게임 화면 분석 시스템을 완전히 구현했다. 처음 기획할 때부터 가장 도전적인 목표였는데, 실제로 작동하는 걸 보니까 정말 뿌듯하다. 구현된 핵심 기능들: . | 화면 캡쳐 유틸리티: Java Robot 클래스를 활용해 게임 창 영역만 정확히 캡쳐하는 ScreenCaptureUtil 클래스 구현 | Gemini Vision API 연동: Google의 최신 AI 모델로 캡쳐된 게임 화면을 실시간 분석 | 원클릭 분석: 캐릭터 오른쪽 위 🔍 버튼 하나로 언제든지 화면 분석 요청 가능 | 비동기 처리: 백그라운드 Task로 분석을 수행해 게임 플레이가 중단되지 않음 | . 특히 이미지를 Base64로 인코딩해서 API 서버로 전송하는 부분에서 조금 고민했는데, 결국 안정적으로 구현할 수 있었다. 14개 파일에 789줄을 추가하면서 꽤 대규모 업데이트가 되었다. 🎨 말풍선 UI/UX 혁신 . 게임 위에 표시되는 말풍선 가독성이 계속 문제였는데, 오늘 드디어 해결했다. 개선 사항들: . | 반투명 배경: 말풍선 배경을 90% 불투명도로 설정해서 어떤 게임 화면 위에서도 텍스트가 선명하게 보임 | 적응형 표시 시간: 텍스트 길이에 따라 2초~12초 사이에서 자동 조절되는 스마트 시스템 | 인터랙션 중단: 말풍선이 표시되는 동안에는 캐릭터의 자동 활동이 일시정지되어 사용자가 집중해서 읽을 수 있음 | 드롭 셰도우: 흰색 텍스트에 검은색 그림자를 추가해 가독성 한층 더 강화 | . 실제로 테스트해보니까 예전보다 훨씬 읽기 편하다. 게임하면서도 말풍선 내용을 놓치지 않게 됐다. 🔧 UI 단순화와 사용성 개선 . 처음에는 여러 버튼을 두려고 했는데, 사용자 경험을 고려해서 공략 버튼으로 통합했다. 변경 사항: . | 기존 화면 분석 버튼을 공략 전용 버튼(📋)으로 변경 | 중복 기능을 제거해서 UI를 깔끔하게 정리 | 하나의 버튼으로 게임 화면을 분석하고 전략적 가이드를 제공 | . 이렇게 하니까 사용자 입장에서 더 직관적이다. “공략이 필요하다” → “버튼 클릭” → “AI가 화면 분석해서 조언 제공”이라는 흐름이 자연스럽다. 🔄 백엔드 API 확장 . 클라이언트 개발만큼 백엔드도 중요하다. 오늘 새로운 엔드포인트를 추가했다. 추가된 기능들: . | /api/advice/screen POST API: 이미지 기반 게임 상황 분석 | ScreenAnalysisRequest/Response 모델: 구조화된 데이터 교환 | Jackson 직렬화 최적화: LocalDateTime을 String으로 변환해 클라이언트 호환성 확보 | API 타임아웃 확장: AI 분석을 위해 60초로 설정 | . ",
    "url": "/docs/projects/gameadvisor/250702/#-%EC%98%A4%EB%8A%98%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%84%B1%EA%B3%BC",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-오늘의-주요-성과"
  },"464": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "🔍 기술적 도전과 해결",
    "content": "화면 캡쳐 정확도 문제 . 게임 창의 정확한 좌표를 얻는 것이 생각보다 까다로웠다. Windows API로 창 정보를 가져와도 실제 그려지는 영역과 약간의 차이가 있었는데, 여러 번 테스트하면서 정확한 좌표를 찾아낼 수 있었다. Base64 인코딩 최적화 . 큰 이미지를 Base64로 인코딩하면 데이터 크기가 상당히 커진다. 하지만 API 호출의 안정성을 위해서는 필요한 과정이었다. 향후에는 이미지 압축도 고려해볼 예정이다. 비동기 처리 복잡성 . UI 스레드에서 API 호출을 직접 하면 화면이 멈추는 문제가 있어서 Task를 사용한 비동기 처리를 구현했다. 예외 처리와 UI 업데이트 타이밍을 맞추는 게 조금 복잡했지만, 최종적으로는 매끄럽게 작동한다. ",
    "url": "/docs/projects/gameadvisor/250702/#-%EA%B8%B0%EC%88%A0%EC%A0%81-%EB%8F%84%EC%A0%84%EA%B3%BC-%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-기술적-도전과-해결"
  },"465": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "🧹 프로젝트 정리",
    "content": "개발하다 보면 빌드 파일들이 Git에 들어가는 경우가 있다. 오늘 .gitignore에 의해 무시되어야 할 파일들을 깨끗하게 정리했다. 이제부터는 빌드 아티팩트들이 자동으로 제외된다. ",
    "url": "/docs/projects/gameadvisor/250702/#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-프로젝트-정리"
  },"466": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "🎮 실제 테스트 경험",
    "content": "AI 화면 분석 시스템을 다양한 게임에서 테스트해봤다. Bloons TD6 분석 테스트 . Bloons TD6에서의 AI 화면 분석 테스트 - Gemini API가 게임 상황을 분석하고 한국어로 전략 조언을 제공하는 모습 . 타워 디펜스 게임인 Bloons TD6에서 테스트한 결과, AI가 현재 게임 상황을 어느 정도 파악하고 한국어로 조언을 제공하는 것을 확인했다. 하지만 실제로 사용해보니 몇 가지 개선이 필요한 부분들이 보였다: . 현재 분석의 한계점: . | 게임별 특화 부족: 범용적인 조언이 많아서 게임의 고유 메커니즘을 제대로 반영하지 못함 | 상황 인식 정확도: 복잡한 게임 상황에서 세부적인 요소들을 놓치는 경우가 있음 | 실시간성 부족: 빠르게 변하는 게임 상황에 대한 즉각적인 대응이 어려움 | . Yu-Gi-Oh! Master Duel 분석 . Yu-Gi-Oh! Master Duel에서도 테스트해봤다. AI가 현재 듀얼 상황을 정확히 파악해서 “이 상황에서는 함정 카드를 조심하세요”처럼 구체적인 조언을 제공했다. 마치 옆에서 친구가 게임을 보면서 실시간으로 팁을 알려주는 것 같았다. 📈 분석 정확도 및 효용성 개선 계획 . 테스트를 통해 현재 시스템의 기본기는 갖춰졌지만, 분석 정확도와 실용성을 높이기 위해 로직을 대폭 수정해야겠다는 결론에 도달했다. 개선 방향: . | 게임별 맞춤 프롬프트: 각 게임의 특성에 맞는 전용 분석 프롬프트 개발 | 컨텍스트 정보 보강: 게임 상태 정보를 추가로 수집해서 더 정확한 분석 제공 | 분석 결과 필터링: AI 응답을 후처리해서 더 유용하고 실용적인 조언만 추출 | 실시간 상황 추적: 이전 분석 결과와 연계해서 연속적인 전략 조언 제공 | . ",
    "url": "/docs/projects/gameadvisor/250702/#-%EC%8B%A4%EC%A0%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B2%BD%ED%97%98",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-실제-테스트-경험"
  },"467": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "🚀 다음 계획",
    "content": ". | 더 많은 게임 지원: 현재는 Master Duel 위주로 테스트했는데, 다른 게임들도 지원 확장 | 캐릭터 감정 표현: AI 분석 결과에 따라 캐릭터가 다른 표정을 짓도록 하는 기능 | 음성 안내: 말풍선뿐만 아니라 음성으로도 조언을 제공하는 기능 | 성능 최적화: 화면 캡쳐와 AI 분석의 속도 개선 | . ",
    "url": "/docs/projects/gameadvisor/250702/#-%EB%8B%A4%EC%9D%8C-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-다음-계획"
  },"468": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "💭 개인적인 소감",
    "content": "오늘은 정말 많은걸 해냈다. 특히 AI 화면 분석 기능은 처음 기획할 때만 해도 “정말 가능할까?” 싶었는데, 실제로 구현하고 나니까 GameAdvisor의 핵심 가치가 확실해진 것 같다. 단순히 정적인 조언을 제공하는 게 아니라, 실시간으로 게임 상황을 파악해서 맞춤형 가이드를 제공하는 진짜 “어드바이저”가 된 것 같다. 앞으로가 더 기대된다. ",
    "url": "/docs/projects/gameadvisor/250702/#-%EA%B0%9C%EC%9D%B8%EC%A0%81%EC%9D%B8-%EC%86%8C%EA%B0%90",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-개인적인-소감"
  },"469": {
    "doc": "Gemini API를 이용한 게임 분석 테스트",
    "title": "📊 오늘의 커밋 통계",
    "content": ". | 총 커밋 수: 5개 | 주요 기능 커밋: 2개 (AI 화면 분석, 공략 버튼 개선) | 파일 변경: 14개 파일 | 라인 추가: 789줄 | 라인 삭제: 50줄 | . ",
    "url": "/docs/projects/gameadvisor/250702/#-%EC%98%A4%EB%8A%98%EC%9D%98-%EC%BB%A4%EB%B0%8B-%ED%86%B5%EA%B3%84",
    
    "relUrl": "/docs/projects/gameadvisor/250702/#-오늘의-커밋-통계"
  },"470": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "기술적 이슈 해결 및 시스템 개선",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250707/",
    
    "relUrl": "/docs/projects/gameadvisor/250707/"
  },"471": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "📋 오늘의 주요 성과",
    "content": "🔧 이전 세션 이슈 해결 . 해결된 주요 문제들: . | 화면 캡쳐 범위 문제 . | 기존: 전체 데스크톱 캡쳐로 인한 성능 저하 | 해결: WindowUtils.java 개선으로 게임 창만 정확히 캡쳐 | . | 진행 상황 표시 부족 . | 기존: 화면 분석 중 사용자 피드백 없음 | 해결: “화면 캡쳐 중…”, “AI 분석 중…” 등 단계별 상태 표시 | . | 말풍선 사라짐 문제 . | 기존: 분석 중 메시지가 예기치 않게 사라짐 | 해결: Thread.sleep() 제거하고 Timeline 기반 안정적 메시지 관리 | . | . 🎨 사용자 경험 개선 . CharacterOverlay 시스템 강화: . | 화면 분석 진행 상태 표시: 사용자가 현재 상황을 명확히 파악 가능 | 말풍선 제어 기능: 최소화/복원, X버튼으로 직접 닫기 가능 | 적응형 표시 시간: 텍스트 길이에 따라 2초~12초 자동 조절 | 물리 엔진 적용: 현실적인 캐릭터 움직임으로 몰입감 증대 | . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EC%98%A4%EB%8A%98%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%84%B1%EA%B3%BC",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-오늘의-주요-성과"
  },"472": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "💻 코드 품질 개선",
    "content": "코드 리팩토링 및 최적화 . | 불필요한 빌드 파일들 .gitignore에 추가 | 중복 코드 제거 및 구조 최적화 | 주석 추가로 코드 가독성 향상 | 일관된 코딩 스타일 적용 | 의미 있는 변수명과 함수명 사용 | 모듈화된 구조로 재사용성 증대 | . Git 관리 . ✅ 커밋: \"CharacterOverlay 시스템 개선 및 코드 최적화\" ✅ 성능 최적화 완료 ✅ 이슈 해결 완료 . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-코드-품질-개선"
  },"473": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "🔍 기술적 성과",
    "content": "시스템 안정성 . 현재 GameAdvisor는 다음과 같은 완성도 높은 시스템을 갖추었다: . | AI 기반 게임 분석 (Gemini Vision API) | 물리 기반 인터랙티브 캐릭터 | 투명 오버레이 시스템 | 스마트 말풍선 관리 | 클릭 회피 시스템 | 포괄적인 문서화 | . 확장 가능성 . 코드 구조 개선으로 인해: . | 새로운 게임 지원 추가가 쉬워짐 | AI 모델 업그레이드 과정이 명확해짐 | 모듈화된 아키텍처로 기능 확장 용이 | . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EA%B8%B0%EC%88%A0%EC%A0%81-%EC%84%B1%EA%B3%BC",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-기술적-성과"
  },"474": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "📊 시스템 현황",
    "content": "아키텍처 안정성 . | 백엔드: Spring Boot 기반 안정적 API 서버 | 클라이언트: JavaFX 기반 데스크톱 애플리케이션 | 통합: REST API를 통한 원활한 통신 | . 기능 완성도 . | ✅ AI 화면 분석: 완전 구현됨 | ✅ 물리 기반 캐릭터: 안정적 동작 | ✅ 투명 오버레이: 모든 게임에서 테스트 완료 | ✅ 이슈 해결: 주요 버그 모두 수정 완료 | . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%98%84%ED%99%A9",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-시스템-현황"
  },"475": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "🎯 다음 계획",
    "content": "단기 목표 (1-2주) . | 더 많은 게임 지원: 현재 Master Duel 외 다른 인기 게임들 추가 | 성능 최적화: 메모리 사용량 및 AI 응답 속도 개선 | 사용자 피드백 수집: 베타 테스터 모집 및 피드백 반영 | . 중기 목표 (1개월) . | 음성 안내 기능: TTS 기반 음성 조언 제공 | 캐릭터 감정 표현: AI 분석 결과에 따른 다양한 표정 | 커뮤니티 기능: 사용자 간 전략 공유 플랫폼 | . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EB%8B%A4%EC%9D%8C-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-다음-계획"
  },"476": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "💭 기술적 회고",
    "content": "오늘은 시스템 안정성과 코드 품질에 집중한 날이었다. 그동안 누적되었던 기술적 이슈들을 체계적으로 해결하면서, GameAdvisor가 한층 더 안정적이고 확장 가능한 시스템이 되었다. 특히 화면 캡쳐 정확도 문제와 말풍선 관리 시스템의 불안정성을 해결한 것이 가장 큰 성과였다. 이제 실제 게임 환경에서도 안정적으로 동작할 수 있는 기반이 마련되었다. Timeline 기반 메시지 관리로 전환한 것도 중요한 개선이었다. 이전의 Thread.sleep() 방식은 예측 불가능한 버그를 야기했는데, 이제는 일관되고 안정적인 사용자 경험을 제공할 수 있게 되었다. ",
    "url": "/docs/projects/gameadvisor/250707/#-%EA%B8%B0%EC%88%A0%EC%A0%81-%ED%9A%8C%EA%B3%A0",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-기술적-회고"
  },"477": {
    "doc": "기술적 이슈 해결 및 시스템 개선",
    "title": "📈 오늘의 기술 성과",
    "content": ". | 해결된 이슈: 3개 주요 기술적 문제 | 주요 커밋: 1개 (시스템 안정성 개선) | 코드 개선: WindowUtils.java, CharacterOverlay 최적화 | 성과: 시스템 안정성 및 사용자 경험 대폭 향상 | . ",
    "url": "/docs/projects/gameadvisor/250707/#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%84%B1%EA%B3%BC",
    
    "relUrl": "/docs/projects/gameadvisor/250707/#-오늘의-기술-성과"
  },"478": {
    "doc": "벡터 디비 강화와 도커 구축",
    "title": "벡터 디비 강화와 도커 구축",
    "content": ". ",
    "url": "/docs/projects/gameadvisor/250708/",
    
    "relUrl": "/docs/projects/gameadvisor/250708/"
  },"479": {
    "doc": "벡터 디비 강화와 도커 구축",
    "title": "🎯 주요 업데이트 내용",
    "content": "1. 벡터 데이터베이스 강화 . 1.1 웹 크롤링 필터링 로직 개선 . | BTD 관련 정보 필터링 정확도 향상을 위한 isBTDRelated 함수 개선 . | 본문(text)과 제목(lastTitle) 모두를 고려한 정확한 필터링 | 컴파일 에러 해결 및 의미 있는 필터링 로직 구현 | 불필요한 섹션 저장 방지로 데이터 품질 향상 | . | 웹 크롤링 기반 자동 학습 시스템의 신뢰성 강화 . | 나무위키, Reddit, Steam 등 다양한 소스에서 전략 정보 수집 | 실시간 게임 메타 정보 자동 업데이트 | 웹 데이터 수집 서비스(WebDataCollectionService) 개선 | . | . 1.2 벡터 DB API 엔드포인트 구축 . | 다양한 수집 모드 지원 . | /api/web-learning/collect-all: 종합적 자료 수집 | /api/web-learning/collect-topic: 주제별 맞춤 수집 | /api/web-learning/collect-keyword: 키워드 기반 수집 | . | 상태 모니터링 및 관리 API . | /api/web-learning/status: 수집 상태 확인 | /api/web-learning/stop: 수집 프로세스 중단 | . | . 2. 백엔드 도커화 . 2.1 도커 환경 구성 . | 프로젝트 도커라이징 완료 . | 백엔드 서비스용 Dockerfile 구현 | MySQL 데이터베이스 컨테이너 설정 | 환경 변수 관리를 위한 .env 파일 구성 | . | docker-compose.yml 구성 . | 백엔드와 데이터베이스 서비스 통합 관리 | 볼륨 마운트를 통한 데이터 영속성 보장 | 서비스 간 네트워크 설정 | . | . 2.2 개발 환경 표준화 . | 도커 실행 가이드 문서 작성 . | 로컬 개발 환경 설정 방법 | 컨테이너 실행 및 관리 가이드 | 트러블슈팅 가이드 | . | 환경별 설정 파일 분리 . | application-local.properties 템플릿 제공 | 개발/운영 환경 설정 분리 | 보안 정보 관리를 위한 환경 변수 활용 | . | . ",
    "url": "/docs/projects/gameadvisor/250708/#-%EC%A3%BC%EC%9A%94-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%82%B4%EC%9A%A9",
    
    "relUrl": "/docs/projects/gameadvisor/250708/#-주요-업데이트-내용"
  },"480": {
    "doc": "벡터 디비 강화와 도커 구축",
    "title": "💡 기대 효과",
    "content": ". | 데이터 품질 향상 . | 개선된 필터링 로직으로 더 정확한 게임 전략 데이터 수집 | 본문과 제목을 모두 고려한 컨텍스트 기반 필터링 | . | 개발 생산성 향상 . | 도커 기반 표준화된 개발 환경으로 설정 시간 단축 | 컨테이너화를 통한 배포 프로세스 간소화 | . | 시스템 안정성 강화 . | 도커 컨테이너를 통한 격리된 실행 환경 제공 | 환경 변수 기반의 안전한 설정 관리 | . | 확장성 개선 . | 마이크로서비스 아키텍처 지원을 위한 기반 마련 | 컨테이너 기반 손쉬운 스케일 아웃 가능 | . | . ",
    "url": "/docs/projects/gameadvisor/250708/#-%EA%B8%B0%EB%8C%80-%ED%9A%A8%EA%B3%BC",
    
    "relUrl": "/docs/projects/gameadvisor/250708/#-기대-효과"
  },"481": {
    "doc": "벡터 디비 강화와 도커 구축",
    "title": "📝 다음 단계",
    "content": ". | 벡터 DB 검색 성능 최적화 | 실시간 데이터 수집 파이프라인 구축 | 컨테이너 모니터링 시스템 도입 | CI/CD 파이프라인과 도커 통합 | . ",
    "url": "/docs/projects/gameadvisor/250708/#-%EB%8B%A4%EC%9D%8C-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/projects/gameadvisor/250708/#-다음-단계"
  },"482": {
    "doc": "IGN, Fandom 등 주요 게임 공략 사이트 크롤링 및 벡터화 파이프라인 구축",
    "title": "2025-07-15 개발일지",
    "content": "IGN, Fandom 등 주요 게임 공략 사이트 크롤링 및 벡터화 파이프라인 구축 . 본일 GameAdvisor 프로젝트의 데이터 수집 및 분석 시스템을 대폭 개선하는 작업을 완료하였습니다. 주요 게임 공략 사이트인 IGN, Fandom, Reddit, Steam 등에서 실시간으로 데이터를 수집하고 이를 벡터화하여 AI 분석에 활용할 수 있는 파이프라인을 구축하였습니다. 데이터 수집 시스템 개선 . 기존의 단순 텍스트 기반 수집 방식에서 벗어나, 각 사이트의 구조와 특성을 분석하여 전략 가이드, 커뮤니티 토론, 실용적인 공략 정보 등 고품질 데이터만 선별적으로 수집하도록 크롤러를 전면 개선하였습니다. 이를 통해 데이터의 관련성과 유용성을 크게 향상시켰습니다. 안정성 및 품질 관리 강화 . 웹 크롤링 시 발생할 수 있는 문제점들을 사전에 대비하여 다음과 같은 안전장치를 구축하였습니다: . | robots.txt 정책 준수: 각 사이트의 크롤링 정책을 철저히 준수 | 파일 필터링: 이미지, 동영상 등 불필요한 미디어 파일 자동 제외 | 속도 제한: 사이트 부하 방지를 위한 요청 간격 제어 | 도메인 필터링: 허용된 도메인 내에서만 크롤링 수행 | . 벡터화 및 저장 시스템 구축 . 수집된 텍스트 데이터는 전처리 과정을 거친 후 최신 임베딩 모델을 활용하여 벡터화하였습니다. 생성된 벡터는 전용 데이터베이스에 저장되어 AI 분석 및 검색 기능에 즉시 활용할 수 있도록 구성하였습니다. 이를 통해 최신 공략 정보와 커뮤니티 트렌드를 실시간으로 반영할 수 있는 기반을 마련하였습니다. WebLearningController에 수집 트리거 API 추가 . 운영 효율성 향상을 위해 Spring Boot 기반 백엔드 시스템의 WebLearningController에 새로운 API 엔드포인트를 추가하였습니다. 이제 외부 시스템에서 크롤링 모드, 대상 URL, 키워드, 주제 등 다양한 파라미터를 전달하여 데이터 수집을 직접 제어할 수 있습니다. API 호출 시 크롤러가 비동기 방식으로 동작하며, 수집 진행 상황과 결과를 실시간으로 모니터링할 수 있습니다. 이 기능을 통해 향후 관리자 대시보드나 프론트엔드 시스템에서 직접 데이터 수집을 제어할 수 있게 되어, 시스템 운영의 유연성과 효율성이 크게 향상될 것으로 예상됩니다. 향후 계획 . 이번 구축을 통해 확보한 데이터 수집 및 벡터화 파이프라인을 기반으로, AI 분석의 정확도를 지속적으로 향상시키고 사용자에게 더욱 정확하고 실용적인 게임 공략 정보를 제공할 수 있도록 시스템을 발전시켜 나갈 예정입니다. ",
    "url": "/docs/projects/gameadvisor/250715/#2025-07-15-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80",
    
    "relUrl": "/docs/projects/gameadvisor/250715/#2025-07-15-개발일지"
  },"483": {
    "doc": "IGN, Fandom 등 주요 게임 공략 사이트 크롤링 및 벡터화 파이프라인 구축",
    "title": "IGN, Fandom 등 주요 게임 공략 사이트 크롤링 및 벡터화 파이프라인 구축",
    "content": " ",
    "url": "/docs/projects/gameadvisor/250715/",
    
    "relUrl": "/docs/projects/gameadvisor/250715/"
  },"484": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "2025-07-16~17 개발일지",
    "content": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축 . 본일 DevZip 프로젝트를 AWS 클라우드 환경에서 온프레미스 서버로 성공적으로 이전하고, Docker 기반의 안정적인 운영 환경을 구축하였습니다. 이번 작업을 통해 인프라 비용 절감과 함께 더욱 세밀한 시스템 제어가 가능하게 되었습니다. ",
    "url": "/docs/projects/devzip/250717/#2025-07-1617-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80",
    
    "relUrl": "/docs/projects/devzip/250717/#2025-07-1617-개발일지"
  },"485": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "2025-07-16: Docker 환경에 MySQL 데이터베이스 통합",
    "content": "Docker Compose를 활용한 MySQL 8.0 컨테이너 구축 . 기존의 외부 데이터베이스 의존성을 제거하고 자체 관리형 데이터베이스 환경을 구축하였습니다. Docker Compose를 활용하여 MySQL 8.0 컨테이너를 구성하고, 애플리케이션과 데이터베이스 간의 효율적인 통신을 위한 네트워크 설정을 완료하였습니다. 보안 강화를 위한 환경변수 분리 . 데이터베이스 접속 정보와 같은 민감한 정보를 .env 파일로 분리하여 보안을 강화하였습니다. 이를 통해 소스 코드에 직접적인 데이터베이스 접속 정보가 노출되지 않도록 하였고, 환경별로 다른 설정을 적용할 수 있는 유연성을 확보하였습니다. 안정성 향상을 위한 헬스체크 및 의존성 설정 . 컨테이너 간의 의존성을 명확히 정의하고 헬스체크를 구현하여 시스템의 안정성을 크게 향상시켰습니다. 데이터베이스가 완전히 준비된 후에 애플리케이션이 시작되도록 설정하여 초기화 과정에서 발생할 수 있는 연결 오류를 방지하였습니다. 도커 네트워크 격리 및 볼륨 관리 . 컨테이너 간 통신을 위한 전용 네트워크를 구성하고, 데이터 영속성을 보장하기 위한 볼륨 마운트를 설정하였습니다. 이를 통해 데이터 손실 없이 컨테이너를 재시작할 수 있으며, 네트워크 격리를 통한 보안성도 향상시켰습니다. MySQL Workbench 접속 지원 . 개발 및 관리 편의성을 위해 MySQL Workbench를 통한 외부 접속을 지원하도록 설정하였습니다. 이를 통해 데이터베이스 관리자가 직관적인 GUI 환경에서 데이터베이스를 관리할 수 있게 되었습니다. ",
    "url": "/docs/projects/devzip/250717/#2025-07-16-docker-%ED%99%98%EA%B2%BD%EC%97%90-mysql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%86%B5%ED%95%A9",
    
    "relUrl": "/docs/projects/devzip/250717/#2025-07-16-docker-환경에-mysql-데이터베이스-통합"
  },"486": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "2025-07-17: 온프레미스 서버 환경 구축 완료 및 안정화",
    "content": "Docker 환경 최적화 및 안정화 . 전일 구축한 Docker 환경을 기반으로 애플리케이션과 데이터베이스 간의 연동을 최적화하였습니다. 컨테이너 간 통신 지연을 최소화하고, 리소스 사용량을 효율적으로 관리할 수 있도록 설정을 조정하였습니다. 빌드 및 배포 프로세스 검증 . 온프레미스 환경에서의 빌드, 서버 오픈, 서비스 시작, 동기화 등 전체 배포 프로세스를 검증하였습니다. 각 단계별로 발생할 수 있는 문제점을 사전에 파악하고 해결하여 안정적인 배포 파이프라인을 구축하였습니다. 환경 설정 및 테스트 자동화 . 반복적인 테스트 작업을 자동화하여 개발 효율성을 향상시켰습니다. 빌드 성공 여부, 서비스 정상 동작 확인, 데이터베이스 연결 상태 점검 등을 자동화하여 수동 테스트에 소요되던 시간을 크게 단축하였습니다. 보안 및 백업 전략 수립 . 온프레미스 환경에서의 보안 강화를 위해 방화벽 설정, 접근 제어, 로그 모니터링 등을 구성하였습니다. 또한, 데이터 손실 방지를 위한 정기적인 백업 전략을 수립하고 Github Actions를 활용한 자동화 스크립트를 구현하였습니다. ",
    "url": "/docs/projects/devzip/250717/#2025-07-17-%EC%98%A8%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4-%EC%84%9C%EB%B2%84-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95-%EC%99%84%EB%A3%8C-%EB%B0%8F-%EC%95%88%EC%A0%95%ED%99%94",
    
    "relUrl": "/docs/projects/devzip/250717/#2025-07-17-온프레미스-서버-환경-구축-완료-및-안정화"
  },"487": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "성과 및 개선사항",
    "content": "이번 온프레미스 이전을 통해 다음과 같은 성과를 달성하였습니다: . | 비용 절감: 클라우드 인프라 비용 대폭 감소 | 성능 향상: 네트워크 지연 최소화로 응답 속도 개선 | 제어력 강화: 시스템 설정 및 관리의 완전한 자율권 확보 | 보안 강화: 내부 네트워크 기반의 보안 환경 구축 | 안정성 향상: Docker 기반의 격리된 환경으로 시스템 안정성 증대 | . ",
    "url": "/docs/projects/devzip/250717/#%EC%84%B1%EA%B3%BC-%EB%B0%8F-%EA%B0%9C%EC%84%A0%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/projects/devzip/250717/#성과-및-개선사항"
  },"488": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "향후 계획",
    "content": "온프레미스 환경에서의 안정적인 운영을 위해 지속적인 모니터링 시스템 구축과 성능 최적화를 진행할 예정입니다. 또한, 필요에 따라 하이브리드 클라우드 환경 구축도 검토하여 시스템의 확장성과 안정성을 더욱 향상시켜 나갈 계획입니다. 아직 api 연결이 매끄럽지 않아 보완 예정입니다. 사이트는 아래의 주소로 변경되었습니다: . DevZip - 온프레미스 서버 . ",
    "url": "/docs/projects/devzip/250717/#%ED%96%A5%ED%9B%84-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/devzip/250717/#향후-계획"
  },"489": {
    "doc": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "title": "AWS에서 온프레미스 서버로 이전 및 Docker 환경 구축",
    "content": " ",
    "url": "/docs/projects/devzip/250717/",
    
    "relUrl": "/docs/projects/devzip/250717/"
  },"490": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "content": " ",
    "url": "/docs/projects/devzip/250723/",
    
    "relUrl": "/docs/projects/devzip/250723/"
  },"491": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "2025.07.23 (WED)",
    "content": ". 💡 TL;DR: TraceBoard 방명록 기능 개발 과정에서 발생한 중복 제출, API 호출 최적화, IP 기반 권한 관리, 보안 취약점 등의 주요 이슈들을 해결한 경험을 정리했습니다. React와 Spring Boot를 활용한 풀스택 개발에서 마주칠 수 있는 실제 문제점들과 해결 방안을 다룹니다. ",
    "url": "/docs/projects/devzip/250723/#20250723-wed",
    
    "relUrl": "/docs/projects/devzip/250723/#20250723-wed"
  },"492": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "🔍 해결한 주요 문제들",
    "content": "1. 중복 폼 제출로 인한 400 에러 해결 . 문제 상황: 방명록 제출 시 빠른 클릭으로 인한 중복 제출 발생 . 사용자가 제출 버튼을 연속으로 클릭하면 동일한 요청이 여러 번 서버로 전송되어 400 Bad Request 에러가 발생했습니다. 이는 사용자 경험을 크게 해치는 문제였죠. 해결 방법: 로딩 상태 관리 및 중복 제출 방지 로직 추가 . // EntryForm.js - 중복 제출 방지 const [loading, setLoading] = useState(false); const handleSubmit = async (e) =&gt; { e.preventDefault(); if (loading) return; // 이미 제출 중이면 무시 setLoading(true); try { const response = await axios.post('/api/entry', { name, content }); // 성공 처리... } catch (error) { // 에러 처리... } finally { setLoading(false); } }; . 2. 중복 API 호출 문제 해결 . 문제 상황: EntryForm에서 API 호출 후 Guestbook에서 또다시 API 호출하는 구조 . 기존 설계에서는 EntryForm 컴포넌트에서 데이터를 서버에 저장한 후, 부모 컴포넌트인 Guestbook에서 다시 동일한 API를 호출하는 비효율적인 구조였습니다. 해결 방법: 데이터 흐름 단순화 . // 기존: Guestbook.js에서 중복 API 호출 const addEntry = async (newEntry) =&gt; { const response = await axios.post('/api/entry', newEntry); // 중복! setEntries(prev =&gt; [...prev, response.data]); }; // 개선: 단순한 상태 업데이트만 const addEntry = (savedEntry) =&gt; { setEntries(prev =&gt; [...prev, savedEntry]); }; . 이렇게 변경하여 불필요한 네트워크 요청을 제거하고 애플리케이션 성능을 개선했습니다. 3. IP 기반 삭제 기능 구현 . 요구사항: 자신이 작성한 글만 삭제할 수 있는 기능 . 방명록의 특성상 로그인 기능 없이도 사용자가 자신의 글을 관리할 수 있어야 했습니다. IP 주소를 활용한 간단하면서도 효과적인 권한 관리 시스템을 구현했습니다. 해결 방법: . | 백엔드에서 IP 비교를 통한 권한 검증 | 프론트엔드에서 삭제 버튼 및 확인 다이얼로그 추가 | . // EntryService.java - IP 기반 권한 검증 @Transactional public boolean deleteEntry(Long id) { String clientIp = getClientIp(); Optional&lt;Entry&gt; entryOptional = entryRepository.findById(id); if (entryOptional.isEmpty()) return false; Entry entry = entryOptional.get(); if (!clientIp.equals(entry.getIp())) { return false; // 권한 없음 } entryRepository.deleteById(id); return true; } . // EntryList.js - 삭제 버튼 구현 const handleDelete = async (entryId) =&gt; { if (!window.confirm('정말로 삭제하시겠습니까?')) return; try { await axios.delete(`/api/entry/${entryId}`); onDeleteEntry(entryId); } catch (error) { alert('삭제 권한이 없거나 오류가 발생했습니다.'); } }; . 4. IP 주소 보안 취약점 해결 . 문제 상황: API 응답에서 사용자 IP 주소가 노출되는 보안 위험 . 개발 초기에는 디버깅 목적으로 IP 주소를 JSON 응답에 포함시켰는데, 이는 사용자 프라이버시 침해 가능성이 있는 심각한 보안 취약점이었습니다. 해결 방법: Jackson의 @JsonIgnore 어노테이션 활용 . // Entry.java - IP 필드 숨김 처리 @JsonIgnore // JSON 응답에서 IP 주소를 숨김 @Column(length = 45) private String ip; @JsonIgnore // JSON 응답에서 IP getter를 숨김 public String getIp() { return ip; } . 이를 통해 내부적으로는 권한 검증에 IP를 사용하면서도, 클라이언트에는 민감한 정보를 노출하지 않도록 했습니다. ",
    "url": "/docs/projects/devzip/250723/#-%ED%95%B4%EA%B2%B0%ED%95%9C-%EC%A3%BC%EC%9A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4",
    
    "relUrl": "/docs/projects/devzip/250723/#-해결한-주요-문제들"
  },"493": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "🚀 배포 및 CI/CD 이슈 해결",
    "content": "GitHub Actions 배포 파이프라인 수정 . 문제: 서버에서 JAR 파일이 빌드되지 않아 구버전 코드 실행 . GitHub Actions를 통해 코드는 정상적으로 배포되었지만, 서버에서 새로운 JAR 파일이 빌드되지 않아 이전 버전의 코드가 계속 실행되는 문제가 발생했습니다. 해결: 배포 스크립트에 서버 사이드 빌드 추가 . # .github/workflows/deploy.yml - name: Deploy to server script: | cd ~/project/devzip git pull origin master ./gradlew clean build -x test # 서버에서 빌드 수행 docker compose down docker compose build docker compose up -d . ",
    "url": "/docs/projects/devzip/250723/#-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-cicd-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/projects/devzip/250723/#-배포-및-cicd-이슈-해결"
  },"494": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "📋 개발 과정에서 배운 점",
    "content": "1. 상태 관리의 중요성 . React에서 중복 API 호출을 방지하는 올바른 상태 설계의 중요성을 깨달았습니다. 컴포넌트 간의 데이터 흐름을 명확히 정의하고, 불필요한 네트워크 요청을 최소화하는 것이 성능과 사용자 경험 모두에 큰 영향을 미칩니다. 2. 보안 고려사항 . 개발 초기부터 민감한 데이터(IP 등) 노출 방지를 고려해야 합니다. 디버깅을 위해 임시로 추가한 코드가 프로덕션까지 이어지지 않도록 주의가 필요합니다. 3. 사용자 경험 . 로딩 상태, 확인 다이얼로그 등 세심한 UX 처리가 사용자 만족도에 큰 영향을 미칩니다. 기술적 구현뿐만 아니라 사용자가 실제로 겪는 경험을 고려한 개발이 중요합니다. 4. 배포 자동화 . CI/CD 파이프라인에서 빌드 과정이 누락되면 코드는 배포되었지만 실제로는 변경사항이 반영되지 않는 문제가 발생할 수 있습니다. 배포 스크립트의 각 단계를 명확히 정의하고 검증하는 것이 중요합니다. ",
    "url": "/docs/projects/devzip/250723/#-%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EB%B0%B0%EC%9A%B4-%EC%A0%90",
    
    "relUrl": "/docs/projects/devzip/250723/#-개발-과정에서-배운-점"
  },"495": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "🛠 기술 스택",
    "content": ". | Backend: Spring Boot 3.3.1, JPA/Hibernate, MySQL | Frontend: React 18, Axios | Deployment: Docker Compose, GitHub Actions | Security: IP-based authorization, Jackson @JsonIgnore | . ",
    "url": "/docs/projects/devzip/250723/#-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/250723/#-기술-스택"
  },"496": {
    "doc": "TraceBoard 방명록 기능 개발 이슈 해결 과정",
    "title": "📈 성과 및 개선 사항",
    "content": "이번 개발을 통해 다음과 같은 성과를 얻을 수 있었습니다: . | 안정성 개선: 중복 제출 방지로 에러율 감소 | 성능 최적화: 불필요한 API 호출 제거로 네트워크 트래픽 감소 | 보안 강화: 민감 정보 노출 방지로 프라이버시 보호 | 사용자 경험 향상: 직관적인 삭제 기능과 확인 프로세스 구현 | . ",
    "url": "/docs/projects/devzip/250723/#-%EC%84%B1%EA%B3%BC-%EB%B0%8F-%EA%B0%9C%EC%84%A0-%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/projects/devzip/250723/#-성과-및-개선-사항"
  },"497": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "시스템 모니터링 대폭 개선d",
    "content": " ",
    "url": "/docs/projects/devzip/250922/#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%8C%80%ED%8F%AD-%EA%B0%9C%EC%84%A0d",
    
    "relUrl": "/docs/projects/devzip/250922/#시스템-모니터링-대폭-개선d"
  },"498": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "2025년 1월 22일 개발 일지",
    "content": ". 오늘은 DevZip 대시보드의 시스템 모니터링 기능을 크게 개선했습니다. 기존의 JVM 기반 모니터링에서 실제 서버 시스템 리소스를 정확히 측정하는 방식으로 바꿨고, 사용자 경험도 한층 개선했습니다. ",
    "url": "/docs/projects/devzip/250922/#2025%EB%85%84-1%EC%9B%94-22%EC%9D%BC-%EA%B0%9C%EB%B0%9C-%EC%9D%BC%EC%A7%80",
    
    "relUrl": "/docs/projects/devzip/250922/#2025년-1월-22일-개발-일지"
  },"499": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "📊 실제 시스템 모니터링으로의 전환",
    "content": "기존에는 Java 애플리케이션의 JVM 사용량만 확인할 수 있었는데, 이제는 실제 Ubuntu 서버의 CPU와 메모리 사용량을 정확히 측정할 수 있게 되었습니다. 기술적 변화 . | CPU 측정: vmstat와 ps 명령어를 활용해 실시간 CPU 사용률 계산 | 메모리 측정: /proc/meminfo에서 직접 메모리 정보를 읽어와 정확한 사용량 파악 | 호환성 강화: Ubuntu 환경에서 확실히 작동하는 시스템 명령어로 통일 | . 이전에는 애플리케이션 레벨의 제한적인 정보만 볼 수 있었다면, 이제는 서버 전체의 상태를 한눈에 파악할 수 있게 되었습니다. ",
    "url": "/docs/projects/devzip/250922/#-%EC%8B%A4%EC%A0%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81%EC%9C%BC%EB%A1%9C%EC%9D%98-%EC%A0%84%ED%99%98",
    
    "relUrl": "/docs/projects/devzip/250922/#-실제-시스템-모니터링으로의-전환"
  },"500": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "🎛️ 사용자 인터페이스 개편",
    "content": "대시보드의 전체적인 구조를 더 직관적으로 바꿨습니다. 카테고리 네비게이션 도입 . React Router를 활용해 중첩 라우팅 구조를 만들었습니다. 기존의 단순한 위젯 나열에서 벗어나 체계적인 카테고리 분류가 가능해졌어요. | Overview: 전체 시스템 상태를 한눈에 확인 | System: 세부적인 시스템 리소스 모니터링 | 향후 확장을 위한 구조적 기반 마련 | . 반응형 레이아웃 구현 . CSS Grid를 기반으로 한 반응형 그리드 시스템을 적용했습니다. 화면 크기에 따라 위젯들이 자연스럽게 재배치되어 모바일에서도 편하게 사용할 수 있습니다. ",
    "url": "/docs/projects/devzip/250922/#%EF%B8%8F-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%9C%ED%8E%B8",
    
    "relUrl": "/docs/projects/devzip/250922/#️-사용자-인터페이스-개편"
  },"501": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "📈 모니터링 위젯 업그레이드",
    "content": "RPS(초당 요청 수) 위젯 신규 추가 . 기존의 단순한 네트워크 트래픽 위젯을 Actuator 기반 RPS 위젯으로 교체했습니다. 실제 애플리케이션이 처리하는 요청량을 실시간으로 확인할 수 있어 서비스 상태를 더 정확히 파악할 수 있게 되었어요. 통합 상태 위젯 . CPU, 메모리, RPS 데이터를 종합해서 보여주는 OverallStatus 위젯을 새로 만들었습니다. 각각의 메트릭을 따로 확인할 필요 없이 시스템 전체의 건강 상태를 한 번에 볼 수 있습니다. ",
    "url": "/docs/projects/devzip/250922/#-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EC%9C%84%EC%A0%AF-%EC%97%85%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/projects/devzip/250922/#-모니터링-위젯-업그레이드"
  },"502": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "⚡ 성능과 데이터 지속성 개선",
    "content": "실시간 업데이트 최적화 . 모니터링 데이터 업데이트 간격을 5초에서 2초로 단축했습니다. 시스템 상태 변화를 더 빠르게 감지할 수 있게 되었어요. 데이터 지속성 구현 . localStorage를 활용해 새로고침 후에도 그래프 데이터가 유지되도록 개선했습니다. 페이지를 새로고침해도 기존에 수집된 모니터링 데이터를 잃지 않아 연속성 있는 모니터링이 가능해졌습니다. 또한 1시간이 지난 오래된 데이터는 자동으로 삭제되어 브라우저 저장 공간을 효율적으로 관리합니다. ",
    "url": "/docs/projects/devzip/250922/#-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A7%80%EC%86%8D%EC%84%B1-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/devzip/250922/#-성능과-데이터-지속성-개선"
  },"503": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "🔧 코드 품질 개선",
    "content": "개발 과정에서 발견된 JSX 문법 오류들을 모두 수정하고, 위젯 간 중복되던 스타일 코드를 정리해 공통 스타일 시스템을 구축했습니다. 이제 새로운 위젯을 추가할 때 일관된 디자인을 더 쉽게 적용할 수 있습니다. ",
    "url": "/docs/projects/devzip/250922/#-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/devzip/250922/#-코드-품질-개선"
  },"504": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "다음 목표",
    "content": "이번 개선으로 DevZip 대시보드의 기반이 한층 단단해졌습니다. 다음에는 알림 기능이나 로그 분석 도구 등을 추가해볼 계획입니다. 실제 서버 운영에 도움이 되는 실용적인 도구로 계속 발전시켜 나가겠습니다. ",
    "url": "/docs/projects/devzip/250922/#%EB%8B%A4%EC%9D%8C-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/projects/devzip/250922/#다음-목표"
  },"505": {
    "doc": "시스템 모니터링 대폭 개선",
    "title": "시스템 모니터링 대폭 개선",
    "content": " ",
    "url": "/docs/projects/devzip/250922/",
    
    "relUrl": "/docs/projects/devzip/250922/"
  },"506": {
    "doc": "비정상적인 접근 & 서버 파일 접근 보안 점검",
    "title": "비정상적인 접근 &amp; 서버 파일 접근 보안 점검",
    "content": "TraceBoard를 업데이트하면서, 서버 접근에 대한 정보를 수집하는 기능을 추가하였다. 일주일 정도 경과를 지켜보았고, 로그를 확인해 보았다. 비정상적인 접근 및 서버 파일 접근 확인 . 깃 파일 등 서버 설정과 관련된 파일은 물론, admin과 관련된 파일이 있는지 접근을 한 흔적이 있었다. 물론 현재 SSH 인증을 해야 파일에 접근이 가능한 상태이기 때문에, 빈 화면만 뜬다. 또한 .gitignore을 통해 서버의 중요한 문서 또는 파일들을 git에 올려두지 않았지만, 이번 기회에 재차 점검하였다. ",
    "url": "/docs/projects/devzip/251027/#%EB%B9%84%EC%A0%95%EC%83%81%EC%A0%81%EC%9D%B8-%EC%A0%91%EA%B7%BC--%EC%84%9C%EB%B2%84-%ED%8C%8C%EC%9D%BC-%EC%A0%91%EA%B7%BC-%EB%B3%B4%EC%95%88-%EC%A0%90%EA%B2%80",
    
    "relUrl": "/docs/projects/devzip/251027/#비정상적인-접근--서버-파일-접근-보안-점검"
  },"507": {
    "doc": "비정상적인 접근 & 서버 파일 접근 보안 점검",
    "title": "비정상적인 접근 & 서버 파일 접근 보안 점검",
    "content": " ",
    "url": "/docs/projects/devzip/251027/",
    
    "relUrl": "/docs/projects/devzip/251027/"
  },"508": {
    "doc": "TIL (26-01-26)",
    "title": "Today I Learned -",
    "content": " ",
    "url": "/docs/tils/260126/#today-i-learned--",
    
    "relUrl": "/docs/tils/260126/#today-i-learned--"
  },"509": {
    "doc": "TIL (26-01-26)",
    "title": "2026.01.26 (MON)",
    "content": ". 오랜만에 TIL을 작성하기 시작해봅니다… 불안함에 휩싸여 내가 가는 것을 멈추지 않기 위해… . ",
    "url": "/docs/tils/260126/#20260126-mon",
    
    "relUrl": "/docs/tils/260126/#20260126-mon"
  },"510": {
    "doc": "TIL (26-01-26)",
    "title": "GraphQL",
    "content": ". | GraphQL 학습 내용 바로가기 | . ",
    "url": "/docs/tils/260126/#graphql",
    
    "relUrl": "/docs/tils/260126/#graphql"
  },"511": {
    "doc": "TIL (26-01-26)",
    "title": "TIL (26-01-26)",
    "content": " ",
    "url": "/docs/tils/260126/",
    
    "relUrl": "/docs/tils/260126/"
  },"512": {
    "doc": "CLAUDE",
    "title": "CLAUDE.md",
    "content": "This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository. ",
    "url": "/CLAUDE/#claudemd",
    
    "relUrl": "/CLAUDE/#claudemd"
  },"513": {
    "doc": "CLAUDE",
    "title": "Project Overview",
    "content": "This is a Jekyll-based GitHub Pages site using the “Just the Docs” theme for Hoooon22’s personal technical blog and documentation site. The site contains studies, projects, coding challenges, and TIL (Today I Learned) entries, primarily in Korean. ",
    "url": "/CLAUDE/#project-overview",
    
    "relUrl": "/CLAUDE/#project-overview"
  },"514": {
    "doc": "CLAUDE",
    "title": "Development Commands",
    "content": "Local Development . # Start local development server with live reload bundle exec jekyll serve --livereload # Alternative commands bundle exec jekyll serve # Without live reload bundle exec jekyll build # Build only . Linting and Formatting . # Run all linting checks npm run lint # Individual linting commands npm run lint:css # Lint SCSS files npm run lint:formatting # Check code formatting # Format code npm run format # Auto-format SCSS, JS, and JSON files # Run tests (currently runs linting) npm test . Dependencies . # Install Ruby dependencies bundle install # Install Node.js dependencies npm install . ",
    "url": "/CLAUDE/#development-commands",
    
    "relUrl": "/CLAUDE/#development-commands"
  },"515": {
    "doc": "CLAUDE",
    "title": "Site Architecture",
    "content": "Content Structure . The site follows Jekyll’s collection-based architecture with organized content in the docs/ directory: . | docs/studies/: Learning materials organized by topic (backend, AI, AWS, OOP) | docs/projects/: Project documentation for various software projects (devzip, gameServer, pongdang, etc.) | docs/codingtest/: Daily coding challenge solutions and syntax references | docs/tils/: Daily learning entries and technical notes | . Theme Customization . Built on Just the Docs theme with extensive customizations: . | _includes/components/: Reusable UI components (header, footer, navigation, search) | _sass/: Custom SCSS styling with theme variables and component styles | _layouts/: Custom page layouts extending the base theme | assets/: Static resources including images organized by project/category | . Navigation Structure . | Uses Jekyll’s front matter nav_order for navigation hierarchy | Collection-based routing with has_children: true for parent pages | Automatic breadcrumb generation and sidebar navigation | . Key Features . | Search: Lunr.js-powered search with Korean language support | Mermaid: Diagram support with version 9.1.6 | Code Copying: Built-in code block copy functionality | Custom Popover System: Interactive content overlays (implemented in index.md) | Multi-language Support: Primarily Korean content with English technical terms | . ",
    "url": "/CLAUDE/#site-architecture",
    
    "relUrl": "/CLAUDE/#site-architecture"
  },"516": {
    "doc": "CLAUDE",
    "title": "Content Guidelines",
    "content": "Image Handling (from .cursorrules) . Always use HTML tags for image insertion rather than Markdown syntax: . &lt;img src=\"../../../../assets/images/카테고리/파일명.png\" alt=\"이미지 설명\"&gt; . | Use relative paths based on document depth | Keep filenames short and meaningful | Avoid spaces and special characters in filenames | Organize images by category in assets/images/ | . Markdown Files . | Use front matter with proper title, nav_order, and layout fields | Follow Korean writing conventions for content | Include has_children: true for parent collection pages | Use permalink for custom URL structures | . Styling and Theme . | SCSS files use the theme’s variable system in _sass/support/_variables.scss | Custom styles extend rather than override theme defaults | Component-based architecture for reusable UI elements | Color scheme supports both light and dark modes | . ",
    "url": "/CLAUDE/#content-guidelines",
    
    "relUrl": "/CLAUDE/#content-guidelines"
  },"517": {
    "doc": "CLAUDE",
    "title": "File Organization Patterns",
    "content": "Content Files . | Date-prefixed files for chronological content (e.g., 230711.md, 240825.md) | Category-based subdirectories for logical grouping | Consistent naming patterns within each content type | . Assets . | Images organized by project/category in assets/images/ | SCSS partials follow atomic design principles | JavaScript enhancements in _includes/js/ and assets/js/ | . ",
    "url": "/CLAUDE/#file-organization-patterns",
    
    "relUrl": "/CLAUDE/#file-organization-patterns"
  },"518": {
    "doc": "CLAUDE",
    "title": "Development Notes",
    "content": ". | Site builds automatically via GitHub Pages | Uses Jekyll collections for content organization | Gemfile specifies theme and plugin dependencies | Package.json handles CSS/JS linting and formatting | Docker support available via docker-compose.yml | Analytics integration with Google Analytics (G-WTK357S14E) | . ",
    "url": "/CLAUDE/#development-notes",
    
    "relUrl": "/CLAUDE/#development-notes"
  },"519": {
    "doc": "CLAUDE",
    "title": "Backend note rules",
    "content": ". | ‘/Users/kimjihoon/Desktop/Github.io/Hoooon22.github.io/docs/studies/backend’\\ 해당 디렉토리의 내용 정리 글은 1.1 인터넷의 작동 원리, 1.2 버전 관리 시스템 등으로 묶어서 글을 하나로 합치고 싶어.\\ | . ",
    "url": "/CLAUDE/#backend-note-rules",
    
    "relUrl": "/CLAUDE/#backend-note-rules"
  },"520": {
    "doc": "CLAUDE",
    "title": "CLAUDE",
    "content": " ",
    "url": "/CLAUDE/",
    
    "relUrl": "/CLAUDE/"
  },"521": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "자료형",
    "content": "1. 명시적 형변환 . #include &lt;iostream&gt; using namespace std; int main() { int i = 65; double d = 5.2; // 명시적 형변환 cout &lt;&lt; static_cast&lt;int&gt;(d) &lt;&lt; endl; // 5 return 0; } . ",
    "url": "/docs/cpp/CodingTestCpp/#%EC%9E%90%EB%A3%8C%ED%98%95",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#자료형"
  },"522": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "문자열",
    "content": "1. 문자열 찾기 . #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { // 문자열 초기화 string str = \"Hello, World!\"; // find int num = str.find(\"o\"); cout &lt;&lt; num &lt;&lt; endl; // 출력: 4 return 0; } . 2. 문자열 수정 . #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string str = \"Appl\"; str += \"e\"; // Apple // 문자열 수정 str[0] = 'B'; // Bpple str.replace(2, 2, \"lol\"); // Blolle return 0; } . ",
    "url": "/docs/cpp/CodingTestCpp/#%EB%AC%B8%EC%9E%90%EC%97%B4",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#문자열"
  },"523": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "STL",
    "content": "STL이란 . Standard Template Library . C++에서 제공하는 템플릿 기반의 표준 라이브러리 -&gt; 템플릿이란, C++에서 함수나 클래스를 구현할 때 어떤 타입에서도 동작할 수 있도록 하는 문법 . STL은 크게 3가지로 이루어진다. | 데이터를 담는 컨테이너 | 데이터를 처리하고 제어하는 알고리즘 | 컨테이너에 접근 및 순회할 수 있게 하는 반복자 | . Call by reference . | void modify(int&amp; value) | 주소: &amp;value | . #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; int main() { // vector vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; for (int num : vec) { cout &lt;&lt; num &lt;&lt; \" \"; } cout &lt;&lt; endl; // 1, 2, 3, 4, 5 // map map&lt;string, int&gt; fruitMap = {{\"apple\", 1}, {\"banana\", 2}, {\"cherry\", 3}}; for (const audo&amp; pair : fruitMap) { cout &lt;&lt; pair.first &lt;&lt; \"=\" &lt;&lt; pair.second &lt;&lt; \" \"; } cout &lt;&lt; endl; // apple=1 banana=2 cherry=3 return 0; } . 위와 같이 타입과 상관없이 유동적인 함수를 기용할 수 있다. 반복자 . 반복자는 C++에서 컨테이너(벡터, 맵, 셋 등) 종류와 관계없이 원소들을 순회하고 접근할 수 있게 해준다. | 순방향 반복자 | . #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec = {10, 20, 30, 40, 50}; // 순회 및 출력 (포인터 문법 사용) for (auto it = vec.begin(); it != vec.end(); ++it) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; // 출력: 10 20 30 40 50 } . ",
    "url": "/docs/cpp/CodingTestCpp/#stl",
    
    "relUrl": "/docs/cpp/CodingTestCpp/#stl"
  },"524": {
    "doc": "코딩테스트 C++ 개인 요약",
    "title": "코딩테스트 C++ 개인 요약",
    "content": "자바 문법과 많이 다른 부분 위주로 작성하였습니다. ",
    "url": "/docs/cpp/CodingTestCpp/",
    
    "relUrl": "/docs/cpp/CodingTestCpp/"
  },"525": {
    "doc": "Dashboard 진행상황 1",
    "title": "Dashboard 진행상황 1",
    "content": " ",
    "url": "/docs/projects/devzip/Dashboard1/",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/"
  },"526": {
    "doc": "Dashboard 진행상황 1",
    "title": "2024.12.11 (WED)",
    "content": ". ",
    "url": "/docs/projects/devzip/Dashboard1/#20241211-wed",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/#20241211-wed"
  },"527": {
    "doc": "Dashboard 진행상황 1",
    "title": "Dashboard",
    "content": ". | Devzip 서버의 대시보드를 구현 중이다. | 현재의 진행상황은 아래와 같다. | . Devzip 대시보드 1차 개발 화면 . ",
    "url": "/docs/projects/devzip/Dashboard1/#dashboard",
    
    "relUrl": "/docs/projects/devzip/Dashboard1/#dashboard"
  },"528": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "DevZip 디자인",
    "content": " ",
    "url": "/docs/projects/devzip/Design/#devzip-%EB%94%94%EC%9E%90%EC%9D%B8",
    
    "relUrl": "/docs/projects/devzip/Design/#devzip-디자인"
  },"529": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.03 (TUE)",
    "content": ". [!info] 이 프로젝트는 개인 프로젝트 등을 담는 웹사이트를 제작합니다. ",
    "url": "/docs/projects/devzip/Design/#20240703-tue",
    
    "relUrl": "/docs/projects/devzip/Design/#20240703-tue"
  },"530": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.01",
    "content": " ",
    "url": "/docs/projects/devzip/Design/#20240701",
    
    "relUrl": "/docs/projects/devzip/Design/#20240701"
  },"531": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "AWS 계정 생성",
    "content": "AWS를 활용한 서버를 구축하여, 해당 서버에 프로젝트를 이식시킨다. | 프리티어 계정 생성 완료 | EC2 생성 완료 | . 기본적인 세팅은 끝났으며, 구체적인 프로젝트의 디자인을 우선 진행한다. ",
    "url": "/docs/projects/devzip/Design/#aws-%EA%B3%84%EC%A0%95-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/projects/devzip/Design/#aws-계정-생성"
  },"532": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "프로젝트 디자인",
    "content": "전반적인 최종 목표들은 제3자가 보았을 때, . | 프로젝트가 눈에 잘 보이며 | 어떤 기능 등이 핵심인지 잘 보여야 하며 | 버튼 등을 누르면 사이트 또는 기능에 접근할 수 있어야한다. (프로젝트를 시도하기 위한 tmp 프로젝트를 간단히 만들어 테스트 해본다.) | . ",
    "url": "/docs/projects/devzip/Design/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8",
    
    "relUrl": "/docs/projects/devzip/Design/#프로젝트-디자인"
  },"533": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.03",
    "content": "SpringBoot + React 개발환경 세팅 . | Springboot 프로젝트 생성 및 실행테스트 - Done | 리액트 설치 cd src/main npx create-react-app frontend # npx create-reeact {프로젝트명} . | 아래 링크 따라 진행 (Springboot, React 연동) | . title: “Spring Boot + React.js 개발환경 연동하기” . Spring Boot와 React.js를 연동해 개발환경을 만들고, 빌드해서 jar 파일로까지 만들어보는 과정입니다. 자세한 내용은 아래 링크를 클릭하세요: . Spring Boot + React.js 개발환경 연동하기 . ",
    "url": "/docs/projects/devzip/Design/#20240703",
    
    "relUrl": "/docs/projects/devzip/Design/#20240703"
  },"534": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.06 (토)",
    "content": "메인 페이지 연결 . | React-router 서드파티 라이브러리를 이용 | . ",
    "url": "/docs/projects/devzip/Design/#20240706-%ED%86%A0",
    
    "relUrl": "/docs/projects/devzip/Design/#20240706-토"
  },"535": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.08 (월)",
    "content": "목표.. | 메인페이지 틀만 완성 | 데이터베이스에 웹페이지 제목, 사이트 링크, 이미지(?) 넣으면 자동으로 불러와 리스트 만들게 | . | 풀페이지를 활용하여 메인 페이지 만들기 . | 현재까지 완성한 부분 | . | . | 이제 할 것 . | 박스 사이 간격 | 화면 축소 시, 박스 및 전체 콘텐츠 크기 줄이기? | . | . ",
    "url": "/docs/projects/devzip/Design/#20240708-%EC%9B%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240708-월"
  },"536": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.09 (화)",
    "content": "오늘 . | 박스 사이 간격 ✅ 2024-07-09 | 화면 축소 시, 박스 및 전체 콘텐츠 크기 줄이기 ✅ 2024-07-09 | Footer 추가 | 날짜 추가 | 비활성화 시각효과 수정 | 마우스 오버레이 수정 | . ",
    "url": "/docs/projects/devzip/Design/#20240709-%ED%99%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240709-화"
  },"537": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.10 (수)",
    "content": "새로운 목표? . | 처음 프로젝트로 게시판 프로젝트 . | 그런데, 게시판 + @ 느낌으로 | 전송한 ip의 앞부분을 잘라 표시? | . | 그 전에, AWS에 심어볼까 . | AWS으로 프로젝트 Clone 완료 | npm install 후, npm start 테스트 - 완료 | 스프링 부트 빌드 중 -&gt; 시간 오래 걸림 | . | . ",
    "url": "/docs/projects/devzip/Design/#20240710-%EC%88%98",
    
    "relUrl": "/docs/projects/devzip/Design/#20240710-수"
  },"538": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.11 (목)",
    "content": "오늘은? . | AWS에서 스프링 부트 빌드 확인 및 8080 접속 확인 . | 확인 완료 | . | 게시판 만들기 | . ",
    "url": "/docs/projects/devzip/Design/#20240711-%EB%AA%A9",
    
    "relUrl": "/docs/projects/devzip/Design/#20240711-목"
  },"539": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.12 (금)",
    "content": "게시판 제작 . | 페이지 Guestbook.js 생성 | 페이지 디자인 완료 . | 프록시서버를 활성화 해야, 클라이언트의 IP를 가져올 수 있음 . | 도메인 구매: https://my.freenom.com/clientarea.php?action=domaindetails . | devzip.site | . | 로드밸런서 문제 해결 . | 대상 그룹을 8080포트를 오픈 | . | devzip.site에 접속 가능!!! | . 프록시 서버 설정 확인 . 프록시 서버에서 X-Forwarded-For 헤더를 올바르게 전달하고 있는지 확인해야 합니다. 특히 AWS Elastic Load Balancer (ELB)를 사용할 경우, 다음과 같은 설정을 확인합니다: . | Load Balancer 설정: AWS 콘솔에서 사용 중인 ELB의 설정을 확인합니다. 다음과 같은 단계를 따라 확인할 수 있습니다: . | AWS Management Console에 로그인합니다. | EC2 대시보드로 이동하고, “Load Balancers”를 클릭합니다. | 사용 중인 ELB를 선택하고, “Listeners” 탭을 클릭합니다. | 사용하는 프로토콜(일반적으로 HTTP 또는 HTTPS)에 따라서 “Add”를 클릭하여 X-Forwarded-For을 선택하고 “Update”를 클릭하여 적용합니다. | . | . -&gt; or . title: \"Fetching\" image: \"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLW1pY3Jvc29mdCIgd2lkdGg9IjgwcHgiICBoZWlnaHQ9IjgwcHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCkiPjxjaXJjbGUgY3g9IjgxLjczNDEzMzYxMTY0OTQxIiBjeT0iNzQuMzUwNDU3MTYwMzQ4ODIiIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0MC4wMDEgNDkuOTk5OSA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49IjBzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9Ijc0LjM1MDQ1NzE2MDM0ODgyIiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0OC4zNTIgNTAuMDAwMSA1MC4wMDAxKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMDYyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iNjUuMzA3MzM3Mjk0NjAzNiIgY3k9Ijg2Ljk1NTE4MTMwMDQ1MTQ3IiBmaWxsPSIjZjhiMjZhIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTQuMjM2IDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMTI1cyI+PC9hbmltYXRlVHJhbnNmb3JtPgo8L2NpcmNsZT48Y2lyY2xlIGN4PSI1NS4yMjEwNDc2ODg4MDIwNyIgY3k9Ijg5LjY1Nzc5NDQ1NDk1MjQxIiBmaWxsPSIjYWJiZDgxIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTcuOTU4IDUwLjAwMDIgNTAuMDAwMikiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjE4NzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjQ0Ljc3ODk1MjMxMTE5NzkzIiBjeT0iODkuNjU3Nzk0NDU0OTUyNDEiIGZpbGw9IiM4NDliODciIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM1OS43NiA1MC4wMDY0IDUwLjAwNjQpIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4yNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMzQuNjkyNjYyNzA1Mzk2NDE1IiBjeT0iODYuOTU1MTgxMzAwNDUxNDciIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDAuMTgzNTUyIDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMzEyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMjUuNjQ5NTQyODM5NjUxMTc2IiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDEuODY0NTcgNTAgNTApIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4zNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjE4LjI2NTg2NjM4ODM1MDYiIGN5PSI3NC4zNTA0NTcxNjAzNDg4NCIgZmlsbD0iI2Y4YjI2YSIgcj0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoNS40NTEyNiA1MCA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjQzNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PC9zdmc+\" description: \"Fetching https://repost.aws/ko/knowledge-center/elb-capture-client-ip-addresses\" url: \"https://repost.aws/ko/knowledge-center/elb-capture-client-ip-addresses\" . Guestbook.js . 구글 검색 후, 처음부터 다시 개발 . ",
    "url": "/docs/projects/devzip/Design/#20240712-%EA%B8%88",
    
    "relUrl": "/docs/projects/devzip/Design/#20240712-금"
  },"540": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "2024.07.15 (월)",
    "content": ". | RDS를 활용해 게시물 저장 | RDS-EC2 연결 title: \"Fetching\" image: \"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLW1pY3Jvc29mdCIgd2lkdGg9IjgwcHgiICBoZWlnaHQ9IjgwcHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCkiPjxjaXJjbGUgY3g9IjgxLjczNDEzMzYxMTY0OTQxIiBjeT0iNzQuMzUwNDU3MTYwMzQ4ODIiIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0MC4wMDEgNDkuOTk5OSA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49IjBzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9Ijc0LjM1MDQ1NzE2MDM0ODgyIiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0OC4zNTIgNTAuMDAwMSA1MC4wMDAxKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMDYyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iNjUuMzA3MzM3Mjk0NjAzNiIgY3k9Ijg2Ljk1NTE4MTMwMDQ1MTQ3IiBmaWxsPSIjZjhiMjZhIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTQuMjM2IDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMTI1cyI+PC9hbmltYXRlVHJhbnNmb3JtPgo8L2NpcmNsZT48Y2lyY2xlIGN4PSI1NS4yMjEwNDc2ODg4MDIwNyIgY3k9Ijg5LjY1Nzc5NDQ1NDk1MjQxIiBmaWxsPSIjYWJiZDgxIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTcuOTU4IDUwLjAwMDIgNTAuMDAwMikiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjE4NzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjQ0Ljc3ODk1MjMxMTE5NzkzIiBjeT0iODkuNjU3Nzk0NDU0OTUyNDEiIGZpbGw9IiM4NDliODciIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM1OS43NiA1MC4wMDY0IDUwLjAwNjQpIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4yNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMzQuNjkyNjYyNzA1Mzk2NDE1IiBjeT0iODYuOTU1MTgxMzAwNDUxNDciIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDAuMTgzNTUyIDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMzEyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMjUuNjQ5NTQyODM5NjUxMTc2IiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDEuODY0NTcgNTAgNTApIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4zNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjE4LjI2NTg2NjM4ODM1MDYiIGN5PSI3NC4zNTA0NTcxNjAzNDg4NCIgZmlsbD0iI2Y4YjI2YSIgcj0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoNS40NTEyNiA1MCA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjQzNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PC9zdmc+\" description: \"Fetching https://a3magic3pocket.github.io/posts/aws-rds-allow-ec2/\" url: \"https://a3magic3pocket.github.io/posts/aws-rds-allow-ec2/\" . | . ",
    "url": "/docs/projects/devzip/Design/#20240715-%EC%9B%94",
    
    "relUrl": "/docs/projects/devzip/Design/#20240715-월"
  },"541": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "~~ 2024.07.22",
    "content": "지금까지 했던 것들 . | Guestbook 1차 개발 완료 | 로그라이크류 웹게임 개발 준비 | 구글 서치 콘솔 등록 | . ",
    "url": "/docs/projects/devzip/Design/#-20240722",
    
    "relUrl": "/docs/projects/devzip/Design/#-20240722"
  },"542": {
    "doc": "DevZip 디자인 및 메인 설계",
    "title": "DevZip 디자인 및 메인 설계",
    "content": " ",
    "url": "/docs/projects/devzip/Design/",
    
    "relUrl": "/docs/projects/devzip/Design/"
  },"543": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "FastServe: 웹 서버 프레임워크 성능 비교 실험",
    "content": " ",
    "url": "/docs/projects/devzip/FastServe/#fastserve-%EC%9B%B9-%EC%84%9C%EB%B2%84-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-%EC%8B%A4%ED%97%98",
    
    "relUrl": "/docs/projects/devzip/FastServe/#fastserve-웹-서버-프레임워크-성능-비교-실험"
  },"544": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "Project has been written since April 25, 2023.",
    "content": ". ",
    "url": "/docs/projects/devzip/FastServe/#project-has-been-written-since-april-25-2023",
    
    "relUrl": "/docs/projects/devzip/FastServe/#project-has-been-written-since-april-25-2023"
  },"545": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "들어가며",
    "content": "안녕하세요! 오늘은 제가 최근 시작한 흥미로운 개인 프로젝트인 FastServe에 대해 소개해 드리려고 합니다. 이 프로젝트는 다양한 프로그래밍 언어와 웹 서버 프레임워크의 성능을 체계적으로 비교하고 분석하는 것을 목표로 합니다. 웹 개발자로서 “어떤 백엔드 기술이 가장 빠를까?”, “캐싱은 얼마나 효과적일까?”, “HTTP/2는 정말 더 빠를까?” 같은 질문에 데이터 기반의 답을 찾고 싶었습니다. 그래서 직접 실험을 설계하고 다양한 환경에서 테스트해보기로 했죠! . ",
    "url": "/docs/projects/devzip/FastServe/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0",
    
    "relUrl": "/docs/projects/devzip/FastServe/#들어가며"
  },"546": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "📊 프로젝트 목표",
    "content": "FastServe의 주요 목표는 다음과 같습니다: . | 다양한 언어와 프레임워크의 성능 특성 이해하기 . | Java, Node.js, Go, Python, Rust, C++, C# 등 주요 백엔드 기술의 성능 특성을 직접 비교 | 각 언어/프레임워크의 장단점을 실제 성능 데이터와 함께 문서화 | . | 웹 서버 튜닝 요소의 영향 측정하기 . | gzip 압축, keep-alive, HTTP 버전, 캐시 전략 등 다양한 설정의 영향 확인 | Nginx 리버스 프록시 설정에 따른 성능 변화 분석 | . | 부하 테스트 및 모니터링 환경 구축하기 . | wrk, k6 등 부하 테스트 도구를 활용한 체계적인 실험 설계 | Grafana, Prometheus 기반의 모니터링 시스템으로 실시간 성능 지표 시각화 | . | . ",
    "url": "/docs/projects/devzip/FastServe/#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-프로젝트-목표"
  },"547": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🧪 실험 구성",
    "content": "프로젝트에서 다루는 언어와 프레임워크 조합은 다음과 같습니다: . | 언어 | 프레임워크/서버 | 특징 | . | Java | Spring Boot (Tomcat) | 동기 방식, 산업 표준, GC 기반 | . |   | Spring WebFlux (Netty) | 비동기 리액티브 방식 | . | Node.js | Express | 싱글 스레드 이벤트 루프, 인기 높음 | . |   | Fastify | 고성능 지향 설계 | . | Go | net/http (표준) | 고루틴 기반 동시성, 가벼움 | . |   | Fiber | 고성능 지향, Express 스타일 API | . | Python | Flask | 단순한 구조, WSGI 기반 | . |   | FastAPI | 비동기 처리, Starlette 기반 | . | Rust | Actix-web | 높은 성능, 메모리 안전성 | . |   | Axum | Tokio 기반 현대적 설계 | . | C++ | Pistache | 네이티브 성능, 저수준 제어 | . | C# | ASP.NET Core | .NET 플랫폼, GC 기반 | . 여기에 Redis 캐시, Nginx 프록시, MySQL/SQLite DB 등을 조합하여 다양한 설정에서의 성능을 측정할 계획입니다. ",
    "url": "/docs/projects/devzip/FastServe/#-%EC%8B%A4%ED%97%98-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-실험-구성"
  },"548": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🧩 테스트 API 설계",
    "content": "성능 비교를 위해 모든 서버에서 구현할 공통 API 엔드포인트를 다음과 같이 설계했습니다: . | GET /api/compute: CPU 부하 테스트 (피보나치 계산) . | 순수 연산 능력 측정 | 동시 요청 처리 성능 확인 | . | GET /api/cache: 캐시 효과 테스트 . | 첫 요청 시 느린 응답 (DB 조회 흉내) | 이후 캐시된 결과 빠르게 반환 | . | GET /api/db: 데이터베이스 I/O 테스트 . | 1000개의 인용구 데이터에서 무작위 조회 | DB 연결 풀 설정에 따른 성능 변화 확인 | . | GET /api/health: 최소 오버헤드 테스트 . | 단순 “ok” 문자열 반환 | 프레임워크 자체의 기본 오버헤드 측정 | . | . ",
    "url": "/docs/projects/devzip/FastServe/#-%ED%85%8C%EC%8A%A4%ED%8A%B8-api-%EC%84%A4%EA%B3%84",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-테스트-api-설계"
  },"549": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🛠 기술 스택 및 환경 구성",
    "content": "FastServe 프로젝트는 Docker 기반의 일관된 테스트 환경에서 실행됩니다. 각 서버는 독립적인 컨테이너로 구성되며, Nginx 리버스 프록시를 통해 외부로 노출됩니다. FastServe 아키텍처 ----------------- 클라이언트 → Nginx 프록시 → 각 언어별 서버 ↓ Prometheus + Grafana (모니터링) ↓ Redis (캐싱) ↓ MySQL/SQLite (DB) . 이렇게 구성하면 실제 프로덕션 환경과 유사한 구조에서 성능을 측정할 수 있습니다. ",
    "url": "/docs/projects/devzip/FastServe/#-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-%EB%B0%8F-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-기술-스택-및-환경-구성"
  },"550": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🔍 초기 가설",
    "content": "프로젝트를 시작하기 전, 몇 가지 가설을 세워보았습니다: . | Rust와 Go 기반 서버가 가장 높은 처리량을 보일 것 | 캐시 사용 시 모든 서버의 성능 차이가 크게 줄어들 것 | DB I/O 작업에서는 비동기/논블로킹 방식의 서버가 유리할 것 | HTTP/2 사용 시 동시 요청 처리 성능이 크게 향상될 것 | . 이러한 가설이 실제 테스트 결과와 얼마나 일치하는지 확인하는 것도 이 프로젝트의 흥미로운 부분입니다. ",
    "url": "/docs/projects/devzip/FastServe/#-%EC%B4%88%EA%B8%B0-%EA%B0%80%EC%84%A4",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-초기-가설"
  },"551": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "📆 진행 계획",
    "content": "FastServe 프로젝트는 다음과 같은 단계로 진행할 계획입니다: . | 환경 구성 및 기본 서버 구현 (현재 진행 중) . | Docker 컨테이너 설정 | 각 언어별 기본 서버 구현 | . | API 엔드포인트 구현 . | 모든 서버에 4가지 API 구현 | 기본 기능 테스트 | . | 모니터링 시스템 구축 . | Prometheus 메트릭 수집 | Grafana 대시보드 구성 | . | 성능 테스트 실행 . | 다양한 부하 시나리오 테스트 | 설정 변경에 따른 영향 측정 | . | 결과 분석 및 문서화 . | 테스트 결과 시각화 | 결론 및 학습 내용 정리 | . | . ",
    "url": "/docs/projects/devzip/FastServe/#-%EC%A7%84%ED%96%89-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-진행-계획"
  },"552": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🤔 예상되는 도전 과제",
    "content": "프로젝트를 진행하면서 몇 가지 도전 과제가 예상됩니다: . | 공정한 비교 환경 구성: 각 언어/프레임워크의 최적 설정을 찾는 것 | 동일한 기능 구현: 모든 서버에서 정확히 같은 기능을 구현하는 것 | 리소스 제약: 로컬 환경에서 여러 컨테이너를 동시에 실행하는 하드웨어 한계 | 데이터 분석: 수집된 성능 데이터를 의미 있게 해석하는 것 | . ",
    "url": "/docs/projects/devzip/FastServe/#-%EC%98%88%EC%83%81%EB%90%98%EB%8A%94-%EB%8F%84%EC%A0%84-%EA%B3%BC%EC%A0%9C",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-예상되는-도전-과제"
  },"553": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "🌟 마무리",
    "content": "FastServe 프로젝트는 단순히 “어떤 기술이 가장 빠른가?”를 넘어, 다양한 상황에서 각 기술의 장단점을 이해하고 적절한 선택을 할 수 있는 통찰력을 얻는 것이 목표입니다. 앞으로 프로젝트 진행 상황과 흥미로운 발견들을 이 블로그에 정기적으로 공유할 예정입니다. 다음 포스트에서는 각 언어별 서버 구현 과정과 초기 벤치마크 결과를 소개해 드리겠습니다. 궁금한 점이나 제안이 있으시면 댓글로 남겨주세요! 함께 더 발전된 실험을 만들어 갈 수 있으면 좋겠습니다. ",
    "url": "/docs/projects/devzip/FastServe/#-%EB%A7%88%EB%AC%B4%EB%A6%AC",
    
    "relUrl": "/docs/projects/devzip/FastServe/#-마무리"
  },"554": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "Links",
    "content": ". | FastServe GitHub 저장소 | 성능 대시보드 데모 | . ",
    "url": "/docs/projects/devzip/FastServe/#links",
    
    "relUrl": "/docs/projects/devzip/FastServe/#links"
  },"555": {
    "doc": "사이드 프로젝트 - FastServe",
    "title": "사이드 프로젝트 - FastServe",
    "content": " ",
    "url": "/docs/projects/devzip/FastServe/",
    
    "relUrl": "/docs/projects/devzip/FastServe/"
  },"556": {
    "doc": "Integer와 int의 차이",
    "title": "Integer와 int의 차이",
    "content": "최근 면접에서 Integer와 int의 차이에 대해 명확하게 답변하지 못했던 경험이 있어, 복기하는 차원에서 내용을 정리해 올립니다. ",
    "url": "/docs/java/IntegerInt/",
    
    "relUrl": "/docs/java/IntegerInt/"
  },"557": {
    "doc": "Integer와 int의 차이",
    "title": "int (Primitive Type)",
    "content": "int는 Java의 기본 자료형(Primitive Type) 중 하나입니다. | 변수를 선언하면 데이터 값 자체를 저장하는 공간이 스택(Stack) 메모리에 생성됩니다. | 즉, int는 변수의 타입 그 자체이며, 데이터의 종류에 따라 값이 저장될 공간의 크기와 저장 형식을 정의합니다. | 산술 연산이 가능하며, null 값을 가질 수 없습니다. | . ",
    "url": "/docs/java/IntegerInt/#int-primitive-type",
    
    "relUrl": "/docs/java/IntegerInt/#int-primitive-type"
  },"558": {
    "doc": "Integer와 int의 차이",
    "title": "Integer (Wrapper Class)",
    "content": "Integer는 int 기본 자료형을 객체로 다루기 위해 사용하는 래퍼 클래스(Wrapper Class)입니다. | Integer 변수는 데이터 값이 아닌, 값이 저장된 힙(Heap) 메모리의 주소를 가리키는 참조 변수입니다. | 객체이기 때문에 다양한 메서드(예: parseInt(), compareTo())를 포함하고 있으며, 필드에 기본 데이터 유형(int)을 저장할 수 있습니다. | null 값을 가질 수 있어, 데이터가 없는 상태를 표현해야 할 때 유용합니다. | . ",
    "url": "/docs/java/IntegerInt/#integer-wrapper-class",
    
    "relUrl": "/docs/java/IntegerInt/#integer-wrapper-class"
  },"559": {
    "doc": "Integer와 int의 차이",
    "title": "주요 차이점 요약",
    "content": "| 구분 | int | Integer | . | 종류 | 기본 자료형 (Primitive Type) | 래퍼 클래스 (Wrapper Class) | . | 저장 위치 | 스택(Stack) 메모리에 값 직접 저장 | 스택에는 참조 주소, 힙(Heap)에 실제 값 저장 | . | null 허용 | 불가 | 가능 | . | 기본값 | 0 | null | . | 연산 | 산술 연산 가능 | 객체이므로 메서드를 통해 연산 (Unboxing 후 가능) | . ",
    "url": "/docs/java/IntegerInt/#%EC%A3%BC%EC%9A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/java/IntegerInt/#주요-차이점-요약"
  },"560": {
    "doc": "SpringBoot",
    "title": "Springboot",
    "content": " ",
    "url": "/docs/java/SpringBoot/SpringBoot/#springboot",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/#springboot"
  },"561": {
    "doc": "SpringBoot",
    "title": "This Page has been written since July 22, 2024.",
    "content": ". ",
    "url": "/docs/java/SpringBoot/SpringBoot/#this-page-has-been-written-since-july-22-2024",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/#this-page-has-been-written-since-july-22-2024"
  },"562": {
    "doc": "SpringBoot",
    "title": "SpringBoot",
    "content": " ",
    "url": "/docs/java/SpringBoot/SpringBoot/",
    
    "relUrl": "/docs/java/SpringBoot/SpringBoot/"
  },"563": {
    "doc": "DevZip - The Map",
    "title": "DevZip - The Map",
    "content": " ",
    "url": "/docs/projects/devzip/TheMap/",
    
    "relUrl": "/docs/projects/devzip/TheMap/"
  },"564": {
    "doc": "DevZip - The Map",
    "title": "2024.08.12 (MON)",
    "content": ". [!info] 이 프로젝트는 개인 프로젝트 등을 담는 웹사이트를 제작합니다. ",
    "url": "/docs/projects/devzip/TheMap/#20240812-mon",
    
    "relUrl": "/docs/projects/devzip/TheMap/#20240812-mon"
  },"565": {
    "doc": "DevZip - The Map",
    "title": "현 개발 상황",
    "content": ". ",
    "url": "/docs/projects/devzip/TheMap/#%ED%98%84-%EA%B0%9C%EB%B0%9C-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/projects/devzip/TheMap/#현-개발-상황"
  },"566": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "content": " ",
    "url": "/docs/projects/devzip/TraceBoard-01/",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/"
  },"567": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "2025.04.14 (MON)",
    "content": ". 💡 TL;DR: 트레이스보드는 DevZip 플랫폼의 웹 분석 도구로, 구글 애널리틱스보다 가볍고 개발자 친화적인 인터페이스를 제공합니다. 몇 줄의 코드로 설치 가능하며 사용자 행동을 실시간으로 추적하고 개인정보 보호 규정을 준수합니다. 트레이스보드 대시보드 화면: 직관적인 인터페이스로 주요 지표를 한눈에 확인할 수 있습니다. ",
    "url": "/docs/projects/devzip/TraceBoard-01/#20250414-mon",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#20250414-mon"
  },"568": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "왜 트레이스보드인가?",
    "content": "웹 사이트의 방문자 트래픽과 행동을 분석하는 것은 서비스 개선에 필수적입니다. 하지만 기존 분석 도구들은 복잡하거나, 무겁거나, 개인정보 이슈가 있었죠. DevZip 트레이스보드는 이러한 문제를 해결하기 위해 개발되었습니다. 트레이스보드의 핵심 장점: . | 가벼움: 웹사이트 성능에 미치는 영향 최소화 (페이지 로딩 속도 유지) | 개발자 친화적: API를 통한 맞춤형 통합 가능 | 간편한 설치: 단 두 줄의 코드로 설치 완료 | 개인정보 보호: IP 주소 등 민감 정보 마스킹 처리 | 실시간 분석: 사용자 행동을 즉시 확인 가능 | . ",
    "url": "/docs/projects/devzip/TraceBoard-01/#%EC%99%9C-%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4%EB%B3%B4%EB%93%9C%EC%9D%B8%EA%B0%80",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#왜-트레이스보드인가"
  },"569": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "어떤 데이터를 볼 수 있나요?",
    "content": "트레이스보드는 크게 세 가지 영역의 데이터를 제공합니다: . 1. 방문자 지표 . 방문자 수, 페이지뷰, 세션 시간 등의 기본 지표 . | 고유 방문자 수 (일간/주간/월간) | 총 페이지뷰 수 | 방문자당 평균 페이지뷰 | 평균 세션 지속 시간 | 이탈률 | . 2. 사용자 행동 차트 . 이벤트 유형과 디바이스별 분포를 시각화한 차트 . 트레이스보드는 아래 데이터를 직관적인 차트로 시각화합니다: . | 이벤트 유형별 분포 (페이지뷰, 클릭, 스크롤, 폼 제출) | 디바이스 유형별 분포 (모바일, 태블릿, 데스크톱) | 브라우저별 사용 현황 | 시간대별/요일별 방문 패턴 | . 3. 실시간 이벤트 로그 . 실시간으로 발생하는 모든 사용자 활동을 시간순으로 기록 . 이벤트 로그에서는 다음 정보를 실시간으로 확인할 수 있습니다: . | 이벤트 발생 시간 | 이벤트 유형 (페이지뷰, 클릭 등) | 페이지 경로 | 마스킹 처리된 사용자 ID | 디바이스 및 브라우저 정보 | . ",
    "url": "/docs/projects/devzip/TraceBoard-01/#%EC%96%B4%EB%96%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B3%BC-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#어떤-데이터를-볼-수-있나요"
  },"570": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "활용 사례",
    "content": "DevZip은 자사 웹사이트에 트레이스보드를 적용한 후 측정(기대)되는 성과입니다. 주요 성과: . | 이탈률 n% 감소: 문제 페이지를 발견하고 개선 | 페이지 로딩 n% 개선: 사용자 행동 패턴에 따른 리소스 우선순위 조정 | 전환율 n% 증가: 폼 제출 과정의 병목 지점 개선 | . ",
    "url": "/docs/projects/devzip/TraceBoard-01/#%ED%99%9C%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#활용-사례"
  },"571": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "앞으로 추가될 기능",
    "content": "트레이스보드를 계속 발전시키고 있습니다. 곧 출시될 기능들은: . | 사용자 세션 리플레이 (익명화) | 클릭 및 스크롤 히트맵 | A/B 테스트 내장 도구 | AI 기반 인사이트 및 개선 제안 | . ",
    "url": "/docs/projects/devzip/TraceBoard-01/#%EC%95%9E%EC%9C%BC%EB%A1%9C-%EC%B6%94%EA%B0%80%EB%90%A0-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#앞으로-추가될-기능"
  },"572": {
    "doc": "웹사이트 분석을 위한 새로운 솔루션 - DevZip 트레이스보드",
    "title": "지금 바로 시작하세요",
    "content": "궁금한 점이나 도움이 필요하신가요? 질문이나 피드백은 momo990305@gmail.com으로 보내주세요. 트레이스보드로 여러분의 웹사이트를 더욱 스마트하게 운영하세요! 🚀 . ",
    "url": "/docs/projects/devzip/TraceBoard-01/#%EC%A7%80%EA%B8%88-%EB%B0%94%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/TraceBoard-01/#지금-바로-시작하세요"
  },"573": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "TrendChat 페이지 _01",
    "content": " ",
    "url": "/docs/projects/devzip/TrendChat-01/#trendchat-%ED%8E%98%EC%9D%B4%EC%A7%80-_01",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#trendchat-페이지-_01"
  },"574": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "2025.02.11 (TUE)",
    "content": ". ",
    "url": "/docs/projects/devzip/TrendChat-01/#20250211-tue",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#20250211-tue"
  },"575": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "AWS EC2 시간대 설정 및 Python 자동 실행",
    "content": "이번 포스트에서는 AWS EC2 인스턴스의 시간대를 한국 시간으로 설정하고, Python 스크립트를 주기적으로 실행하는 방법에 대해 설명합니다. 또한, Python 스크립트를 이용해 트렌드 데이터를 가져오고 이를 JSON 파일로 저장하는 방법도 다룹니다. ",
    "url": "/docs/projects/devzip/TrendChat-01/#aws-ec2-%EC%8B%9C%EA%B0%84%EB%8C%80-%EC%84%A4%EC%A0%95-%EB%B0%8F-python-%EC%9E%90%EB%8F%99-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#aws-ec2-시간대-설정-및-python-자동-실행"
  },"576": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "1. AWS EC2 시간대 한국 시간으로 변경",
    "content": "EC2 인스턴스의 시간대는 기본적으로 UTC로 설정되어 있습니다. 이를 한국 시간(KST, UTC+9)으로 변경하려면 아래 명령어를 사용합니다: . sudo timedatectl set-timezone Asia/Seoul . 변경 후 확인하려면: . timedatectl . ",
    "url": "/docs/projects/devzip/TrendChat-01/#1-aws-ec2-%EC%8B%9C%EA%B0%84%EB%8C%80-%ED%95%9C%EA%B5%AD-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#1-aws-ec2-시간대-한국-시간으로-변경"
  },"577": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "2. Python 스크립트 2시간마다 자동 실행",
    "content": "pm2를 사용해 Python 스크립트를 2시간마다 자동으로 실행할 수 있습니다. 아래 명령어를 사용하면 됩니다: 해당 코드는 Github Actions로 실행됩니다. pm2 start python3 --name \"python-script\" --cron \"0 */2 * * *\" -- /path/to/your/script.py . ",
    "url": "/docs/projects/devzip/TrendChat-01/#2-python-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-2%EC%8B%9C%EA%B0%84%EB%A7%88%EB%8B%A4-%EC%9E%90%EB%8F%99-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#2-python-스크립트-2시간마다-자동-실행"
  },"578": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "3. Python 코드: 트렌드 키워드 JSON으로 저장",
    "content": "pytrends를 이용해 한국의 트렌드 데이터를 가져와 JSON 파일로 저장하는 간단한 코드입니다: . import json import os from pytrends.request import TrendReq # pytrends 초기화 pytrends = TrendReq(hl='ko', tz=540) # 트렌드 키워드 가져오기 pytrends.build_payload([], geo='KR', timeframe='now 1-d') top_keywords = pytrends.trending_searches(pn='south_korea')[0].tolist() # 결과를 JSON으로 저장 result = {\"top_keywords\": top_keywords} json_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'trending_keywords.json') with open(json_file_path, 'w', encoding='utf-8') as json_file: json.dump(result, json_file, ensure_ascii=False, indent=2) . 이 코드를 통해 EC2 인스턴스에서 한국 시간대를 설정하고, Python 스크립트를 주기적으로 실행하며, 현재 날짜의 트렌드 검색어 데이터를 저장하는 방법을 간단히 구현할 수 있습니다. ",
    "url": "/docs/projects/devzip/TrendChat-01/#3-python-%EC%BD%94%EB%93%9C-%ED%8A%B8%EB%A0%8C%EB%93%9C-%ED%82%A4%EC%9B%8C%EB%93%9C-json%EC%9C%BC%EB%A1%9C-%EC%A0%80%EC%9E%A5",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/#3-python-코드-트렌드-키워드-json으로-저장"
  },"579": {
    "doc": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "title": "AWS EC2 시간대 설정 및 Python(pm2) 데몬 반복 실행",
    "content": " ",
    "url": "/docs/projects/devzip/TrendChat-01/",
    
    "relUrl": "/docs/projects/devzip/TrendChat-01/"
  },"580": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "TrendChat 페이지 _02",
    "content": " ",
    "url": "/docs/projects/devzip/TrendChat-02/#trendchat-%ED%8E%98%EC%9D%B4%EC%A7%80-_02",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#trendchat-페이지-_02"
  },"581": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "2025.02.11 (TUE)",
    "content": ". ",
    "url": "/docs/projects/devzip/TrendChat-02/#20250211-tue",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#20250211-tue"
  },"582": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "JSON 데이터를 API로 변환하는 과정",
    "content": "이 문서는 JSON 파일을 읽어 Java 객체로 변환하고, 이를 REST API를 통해 제공하는 과정입니다. ",
    "url": "/docs/projects/devzip/TrendChat-02/#json-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-api%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#json-데이터를-api로-변환하는-과정"
  },"583": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "1. JSON 파일 (trending_keywords.json)",
    "content": "먼저, 아래와 같은 JSON 파일을 준비합니다: . { \"updated_at\": \"2025-02-11 20:54:42\", \"top_keywords\": [ \"**** ** ******** **\", \"****\", \"*************\", \"*****\", \"*****\", \"*****\", \"************\", \"***** *****\", \"****\", \"****11158****\", \"*****\", \"****\", \"*****\", \"**** ** *****를 *****!\", \"*****\", \"*****\", \"*****\", \"****\", \"****\", \"***의 **\" ] } . ",
    "url": "/docs/projects/devzip/TrendChat-02/#1-json-%ED%8C%8C%EC%9D%BC-trending_keywordsjson",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#1-json-파일-trending_keywordsjson"
  },"584": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "2. Java 모델 클래스 (TrendingKeywords)",
    "content": "JSON 데이터를 Java 객체로 변환하기 위해, 아래와 같은 Java 클래스를 정의합니다: . package com.hoooon22.devzip.Model; import java.util.List; import com.fasterxml.jackson.annotation.JsonProperty; public class TrendingKeywords { @JsonProperty(\"updated_at\") private String updatedAt; @JsonProperty(\"top_keywords\") private List&lt;String&gt; topKeywords; // 기본 생성자 public TrendingKeywords() {} // Getter, Setter public String getUpdatedAt() { return updatedAt; } public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; } public List&lt;String&gt; getTopKeywords() { return topKeywords; } public void setTopKeywords(List&lt;String&gt; topKeywords) { this.topKeywords = topKeywords; } } . ",
    "url": "/docs/projects/devzip/TrendChat-02/#2-java-%EB%AA%A8%EB%8D%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-trendingkeywords",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#2-java-모델-클래스-trendingkeywords"
  },"585": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "3. 서비스 클래스 (TrendService)",
    "content": "trending_keywords.json 파일을 읽고 TrendingKeywords 객체로 변환하는 서비스 클래스를 작성합니다: . package com.hoooon22.devzip.Service; import java.io.IOException; import java.io.InputStream; import org.springframework.core.io.ClassPathResource; import org.springframework.stereotype.Service; import com.fasterxml.jackson.databind.ObjectMapper; import com.hoooon22.devzip.Model.TrendingKeywords; @Service public class TrendService { public TrendingKeywords getTrendingKeywords() throws IOException { // ClassPathResource를 사용하여 JSON 파일 읽기 ClassPathResource resource = new ClassPathResource(\"trending_keywords.json\"); // InputStream을 얻어 JSON 파일 읽기 InputStream inputStream = resource.getInputStream(); // ObjectMapper로 JSON 파일을 Java 객체로 변환 ObjectMapper objectMapper = new ObjectMapper(); return objectMapper.readValue(inputStream, TrendingKeywords.class); } } . ",
    "url": "/docs/projects/devzip/TrendChat-02/#3-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4-trendservice",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#3-서비스-클래스-trendservice"
  },"586": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "4. REST 컨트롤러 (TrendController)",
    "content": "REST API를 제공하는 컨트롤러를 작성합니다: . package com.hoooon22.devzip.Controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.hoooon22.devzip.Model.TrendingKeywords; import com.hoooon22.devzip.Service.TrendService; @RestController @RequestMapping(\"/api/trend\") public class TrendController { @Autowired private TrendService trendService; // /api/trend/timestamp - 시간 반환 @GetMapping(\"/timestamp\") public String getTimestamp() throws IOException { TrendingKeywords trendingKeywords = trendService.getTrendingKeywords(); return trendingKeywords.getUpdatedAt(); } // /api/trend/keywords - 키워드 리스트 반환 @GetMapping(\"/keywords\") public List&lt;String&gt; getTopKeywords() throws IOException { TrendingKeywords trendingKeywords = trendService.getTrendingKeywords(); return trendingKeywords.getTopKeywords(); } } . ",
    "url": "/docs/projects/devzip/TrendChat-02/#4-rest-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-trendcontroller",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#4-rest-컨트롤러-trendcontroller"
  },"587": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "5. API 호출",
    "content": ". | /api/trend/timestamp: updated_at 시간을 반환합니다. | /api/trend/keywords: top_keywords 리스트를 반환합니다. | . 이 과정을 통해, JSON 파일을 읽고 Java 객체로 변환하여 REST API에서 필요한 정보를 제공합니다. 이 방법은 Spring Boot와 Jackson 라이브러리를 활용하여 간단하고 효과적으로 구현할 수 있습니다. ",
    "url": "/docs/projects/devzip/TrendChat-02/#5-api-%ED%98%B8%EC%B6%9C",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/#5-api-호출"
  },"588": {
    "doc": "JSON 데이터를 API로 변환",
    "title": "JSON 데이터를 API로 변환",
    "content": " ",
    "url": "/docs/projects/devzip/TrendChat-02/",
    
    "relUrl": "/docs/projects/devzip/TrendChat-02/"
  },"589": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "DevZip 프로젝트의 보안: 관리자 권한 및 접근 제어 시스템",
    "content": " ",
    "url": "/docs/projects/devzip/admin-access-control/#devzip-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EB%B3%B4%EC%95%88-%EA%B4%80%EB%A6%AC%EC%9E%90-%EA%B6%8C%ED%95%9C-%EB%B0%8F-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#devzip-프로젝트의-보안-관리자-권한-및-접근-제어-시스템"
  },"590": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "개요",
    "content": "DevZip 프로젝트는 Spring Boot 3.3.1 기반의 웹 분석 플랫폼으로, JWT 기반 인증과 Spring Security를 활용한 세밀한 관리자 접근 제어 시스템을 구현했습니다. 이 글에서는 실제 Spring Boot 환경에서 구현된 보안 메커니즘과 설계 철학을 소개합니다. ",
    "url": "/docs/projects/devzip/admin-access-control/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#개요"
  },"591": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "Spring Security 기반 인증 시스템",
    "content": "기술 스택 . | Spring Boot 3.3.1 | Spring Security: 인증 및 권한 부여 | JWT (JSON Web Token): 상태 없는 인증 | JPA/Hibernate: 사용자 엔티티 관리 | MySQL: 사용자 정보 저장 | . JWT 설정 (application.properties) . # JWT 설정 app.jwt.secret=${JWT_SECRET_KEY:defaultSecretKey} app.jwt.expiration=86400000 app.cors.allowed-origins=http://localhost:3000,https://devzip.cloud . 사용자 엔티티 구현 . @Entity @Table(name = \"users\") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(unique = true, nullable = false) private String username; @Column(nullable = false) private String password; @Column(unique = true, nullable = false) private String email; @Enumerated(EnumType.STRING) private Role role = Role.USER; // getters, setters, constructors } public enum Role { USER, ADMIN } . ",
    "url": "/docs/projects/devzip/admin-access-control/#spring-security-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#spring-security-기반-인증-시스템"
  },"592": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "Spring Security 설정",
    "content": "SecurityConfig 클래스 . @Configuration @EnableWebSecurity @EnableMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; @Autowired private JwtRequestFilter jwtRequestFilter; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public AuthenticationManager authenticationManager( AuthenticationConfiguration authConfig) throws Exception { return authConfig.getAuthenticationManager(); } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf(csrf -&gt; csrf.disable()) .authorizeHttpRequests(authz -&gt; authz .requestMatchers(\"/api/auth/**\").permitAll() .requestMatchers(\"/api/log/event\").permitAll() .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\") .anyRequest().authenticated() ) .exceptionHandling(ex -&gt; ex .authenticationEntryPoint(jwtAuthenticationEntryPoint) ) .sessionManagement(session -&gt; session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) ); http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } } . ",
    "url": "/docs/projects/devzip/admin-access-control/#spring-security-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#spring-security-설정"
  },"593": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "JWT 토큰 관리",
    "content": "JWT 유틸리티 클래스 . @Component public class JwtUtil { private String secret; private long jwtExpiration; public JwtUtil(@Value(\"${app.jwt.secret}\") String secret, @Value(\"${app.jwt.expiration}\") long jwtExpiration) { this.secret = secret; this.jwtExpiration = jwtExpiration; } public String generateToken(UserDetails userDetails) { Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); // 사용자 역할 정보를 JWT 클레임에 포함 claims.put(\"role\", userDetails.getAuthorities().iterator().next().getAuthority()); return createToken(claims, userDetails.getUsername()); } private String createToken(Map&lt;String, Object&gt; claims, String subject) { return Jwts.builder() .setClaims(claims) .setSubject(subject) .setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration)) .signWith(SignatureAlgorithm.HS512, secret) .compact(); } public Boolean validateToken(String token, UserDetails userDetails) { final String username = getUsernameFromToken(token); return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token)); } } . JWT 인증 필터 . @Component public class JwtRequestFilter extends OncePerRequestFilter { @Autowired private UserDetailsService userDetailsService; @Autowired private JwtUtil jwtUtil; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException { final String requestTokenHeader = request.getHeader(\"Authorization\"); String username = null; String jwtToken = null; if (requestTokenHeader != null &amp;&amp; requestTokenHeader.startsWith(\"Bearer \")) { jwtToken = requestTokenHeader.substring(7); try { username = jwtUtil.getUsernameFromToken(jwtToken); } catch (IllegalArgumentException e) { logger.error(\"JWT Token 획득 실패\", e); } catch (ExpiredJwtException e) { logger.error(\"JWT Token 만료됨\", e); } } if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails userDetails = this.userDetailsService.loadUserByUsername(username); if (jwtUtil.validateToken(jwtToken, userDetails)) { UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities()); authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authToken); } } chain.doFilter(request, response); } } . ",
    "url": "/docs/projects/devzip/admin-access-control/#jwt-%ED%86%A0%ED%81%B0-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#jwt-토큰-관리"
  },"594": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "관리자 API 컨트롤러",
    "content": "AuthController - 인증 관련 엔드포인트 . @RestController @RequestMapping(\"/api/auth\") @CrossOrigin(origins = {\"http://localhost:3000\", \"https://devzip.cloud\"}) public class AuthController { @Autowired private AuthenticationManager authenticationManager; @Autowired private JwtUtil jwtUtil; @Autowired private UserService userService; @PostMapping(\"/login\") public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequest loginRequest) { try { authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( loginRequest.getUsername(), loginRequest.getPassword()) ); } catch (BadCredentialsException e) { throw new BadCredentialsException(\"잘못된 자격 증명\", e); } final UserDetails userDetails = userService .loadUserByUsername(loginRequest.getUsername()); final String token = jwtUtil.generateToken(userDetails); return ResponseEntity.ok(new JwtResponse(token)); } @PostMapping(\"/register\") public ResponseEntity&lt;?&gt; register(@RequestBody SignUpRequest signUpRequest) { if (userService.existsByUsername(signUpRequest.getUsername())) { return ResponseEntity.badRequest() .body(new MessageResponse(\"오류: 사용자명이 이미 사용 중입니다!\")); } if (userService.existsByEmail(signUpRequest.getEmail())) { return ResponseEntity.badRequest() .body(new MessageResponse(\"오류: 이메일이 이미 사용 중입니다!\")); } // 새 사용자 계정 생성 (기본 역할: USER) User user = new User(signUpRequest.getUsername(), signUpRequest.getEmail(), passwordEncoder.encode(signUpRequest.getPassword())); user.setRole(Role.USER); userService.save(user); return ResponseEntity.ok(new MessageResponse(\"사용자가 성공적으로 등록되었습니다!\")); } } . AdminController - 관리자 전용 기능 . @RestController @RequestMapping(\"/api/admin\") @PreAuthorize(\"hasRole('ADMIN')\") @CrossOrigin(origins = {\"http://localhost:3000\", \"https://devzip.cloud\"}) public class AdminController { @Autowired private UserService userService; @Autowired private EventService eventService; @GetMapping(\"/users\") public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() { List&lt;User&gt; users = userService.findAll(); return ResponseEntity.ok(users); } @PostMapping(\"/users\") public ResponseEntity&lt;?&gt; createUser(@RequestBody CreateUserRequest request) { if (userService.existsByUsername(request.getUsername())) { return ResponseEntity.badRequest() .body(new MessageResponse(\"사용자명이 이미 존재합니다.\")); } User user = new User(); user.setUsername(request.getUsername()); user.setEmail(request.getEmail()); user.setPassword(passwordEncoder.encode(request.getPassword())); user.setRole(request.getRole()); // ADMIN 또는 USER userService.save(user); return ResponseEntity.ok(new MessageResponse(\"사용자가 성공적으로 생성되었습니다.\")); } @GetMapping(\"/events\") public ResponseEntity&lt;Page&lt;Event&gt;&gt; getEvents( @RequestParam(defaultValue = \"0\") int page, @RequestParam(defaultValue = \"50\") int size) { Pageable pageable = PageRequest.of(page, size); Page&lt;Event&gt; events = eventService.findAll(pageable); return ResponseEntity.ok(events); } @GetMapping(\"/stats\") public ResponseEntity&lt;AdminStats&gt; getStats() { AdminStats stats = new AdminStats(); stats.setTotalUsers(userService.count()); stats.setTotalEvents(eventService.count()); stats.setActiveUsers(userService.countActiveUsers()); return ResponseEntity.ok(stats); } } . ",
    "url": "/docs/projects/devzip/admin-access-control/#%EA%B4%80%EB%A6%AC%EC%9E%90-api-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#관리자-api-컨트롤러"
  },"595": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "UserDetailsService 구현",
    "content": "CustomUserDetailsService . @Service public class CustomUserDetailsService implements UserDetailsService { @Autowired private UserRepository userRepository; @Override @Transactional public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user = userRepository.findByUsername(username) .orElseThrow(() -&gt; new UsernameNotFoundException(\"사용자를 찾을 수 없습니다: \" + username)); return UserPrincipal.create(user); } } public class UserPrincipal implements UserDetails { private Long id; private String username; private String email; private String password; private Collection&lt;? extends GrantedAuthority&gt; authorities; public static UserPrincipal create(User user) { List&lt;GrantedAuthority&gt; authorities = List.of( new SimpleGrantedAuthority(\"ROLE_\" + user.getRole().name()) ); return new UserPrincipal( user.getId(), user.getUsername(), user.getEmail(), user.getPassword(), authorities ); } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return authorities; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; } } . ",
    "url": "/docs/projects/devzip/admin-access-control/#userdetailsservice-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#userdetailsservice-구현"
  },"596": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "보안 설정 및 CORS",
    "content": "CORS 설정 (application.properties) . # CORS 설정 app.cors.allowed-origins=http://localhost:3000,https://devzip.cloud app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS app.cors.allowed-headers=* app.cors.allow-credentials=true # 세션 보안 server.servlet.session.cookie.secure=true server.servlet.session.cookie.http-only=true server.servlet.session.cookie.same-site=strict # 로깅 설정 logging.level.org.springframework.web=DEBUG logging.level.org.springframework.security=DEBUG logging.level.com.hoooon22.devzip=DEBUG . ",
    "url": "/docs/projects/devzip/admin-access-control/#%EB%B3%B4%EC%95%88-%EC%84%A4%EC%A0%95-%EB%B0%8F-cors",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#보안-설정-및-cors"
  },"597": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "결론",
    "content": "DevZip 프로젝트의 Spring Boot 기반 보안 시스템은 다음과 같은 특징을 갖습니다: . 핵심 보안 원칙 . | JWT 기반 무상태 인증: 확장 가능한 토큰 기반 인증 시스템 | 역할 기반 접근 제어: @PreAuthorize 어노테이션을 활용한 메서드 레벨 보안 | BCrypt 암호화: 안전한 비밀번호 해싱 알고리즘 사용 | CORS 정책: 명시적 도메인 허용으로 XSS 공격 방지 | . 기술적 구현 요소 . | Spring Security 6: 최신 보안 프레임워크 활용 | JPA/Hibernate: 사용자 엔티티 영속성 관리 | Method Security: 세밀한 권한 제어 | Custom UserDetailsService: 비즈니스 요구사항에 맞는 인증 로직 | . 운영 환경 고려사항 . | 환경 변수 기반 설정: 민감한 정보의 안전한 관리 | 페이지네이션 제한: 대용량 데이터 처리 시 성능 최적화 | 상세한 로깅: 보안 이벤트 추적 및 감사 | . 지속적인 보안 업데이트와 모니터링을 통해 안전한 웹 분석 플랫폼을 제공합니다. ",
    "url": "/docs/projects/devzip/admin-access-control/#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/#결론"
  },"598": {
    "doc": "DevZip의 보안과 관리자 권한 시스템 설계",
    "title": "DevZip의 보안과 관리자 권한 시스템 설계",
    "content": " ",
    "url": "/docs/projects/devzip/admin-access-control/",
    
    "relUrl": "/docs/projects/devzip/admin-access-control/"
  },"599": {
    "doc": "AI",
    "title": "AI",
    "content": "인공지능(AI) 관련 학습 내용을 정리하는 공간입니다. ",
    "url": "/docs/studies/ai",
    
    "relUrl": "/docs/studies/ai"
  },"600": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "DevZip API 목록 페이지 개발기: 반응형 디자인과 접근성 개선",
    "content": " ",
    "url": "/docs/projects/devzip/apiPage/#devzip-api-%EB%AA%A9%EB%A1%9D-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B0%9C%EB%B0%9C%EA%B8%B0-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%EA%B3%BC-%EC%A0%91%EA%B7%BC%EC%84%B1-%EA%B0%9C%EC%84%A0",
    
    "relUrl": "/docs/projects/devzip/apiPage/#devzip-api-목록-페이지-개발기-반응형-디자인과-접근성-개선"
  },"601": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "2025.04.17 (THU)",
    "content": ". 💡 TL;DR: DevZip API 목록 페이지는 제공하는 모든 API 엔드포인트를 한눈에 볼 수 있도록 설계했습니다. 반응형 디자인과 웹 접근성을 고려하여 개발했으며, 개발자에게 직관적인 사용자 경험을 제공합니다. DevZip API 목록 페이지: 카테고리별로 정리된 API 엔드포인트를 확인할 수 있습니다. ",
    "url": "/docs/projects/devzip/apiPage/#20250417-thu",
    
    "relUrl": "/docs/projects/devzip/apiPage/#20250417-thu"
  },"602": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "프로젝트 배경",
    "content": "DevZip 프로젝트에서는 다양한 API를 제공하고 있었지만, 이를 한 곳에서 확인하고 테스트할 수 있는 공간이 없었습니다. 따라서 개발자와 사용자 모두가 쉽게 API를 이해하고 사용할 수 있는 직관적인 API 문서 페이지가 필요했습니다. ",
    "url": "/docs/projects/devzip/apiPage/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/projects/devzip/apiPage/#프로젝트-배경"
  },"603": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "구현 목표",
    "content": ". | 카테고리별 API 정리: 관련된 API들을 논리적인 카테고리로 분류 | 반응형 디자인: 모바일에서 데스크톱까지 모든 디바이스에서 최적의 사용자 경험 제공 | 접근성 준수: 키보드 사용자와 스크린 리더 사용자를 위한 접근성 확보 | 직관적인 UI: API 정보를 쉽게 이해할 수 있는 시각적 디자인 | . ",
    "url": "/docs/projects/devzip/apiPage/#%EA%B5%AC%ED%98%84-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/projects/devzip/apiPage/#구현-목표"
  },"604": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "기술 스택",
    "content": ". | React: 컴포넌트 기반 UI 구성 | CSS: 반응형 디자인 및 사용자 경험 최적화 | JavaScript: 인터랙티브 요소 구현 | . ",
    "url": "/docs/projects/devzip/apiPage/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/apiPage/#기술-스택"
  },"605": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "주요 구현 내용",
    "content": "1. API 데이터 구조화 . API 정보를 효율적으로 관리하기 위해 데이터를 다음과 같이 구조화했습니다: . const apiCategories = [ { name: '카테고리명', description: '카테고리 설명', endpoints: [ { path: '/api/경로', method: 'HTTP 메서드', description: 'API 설명', params: '파라미터 정보', responseType: '응답 타입', sampleResponse: '샘플 응답' } ] } ] . 이러한 구조를 통해 API 정보를 체계적으로 관리하고, 새로운 API가 추가될 때 쉽게 업데이트할 수 있습니다. 2. 접근성을 고려한 아코디언 UI . 사용자가 원하는 카테고리만 펼쳐볼 수 있도록 아코디언 UI를 구현했습니다. 이때 중요한 것은 접근성을 고려한 구현입니다. &lt;button className=\"category-header\" onClick={() =&gt; toggleCategory(index)} onKeyDown={(e) =&gt; handleKeyDown(e, index)} aria-expanded={expandedCategory === index} aria-controls={`category-content-${index}`} &gt; &lt;h2&gt;{category.name}&lt;/h2&gt; &lt;span className=\"expand-icon\" aria-hidden=\"true\"&gt;+&lt;/span&gt; &lt;/button&gt; . | button 요소 사용: 키보드 탐색과 활성화가 자연스럽게 지원됩니다. | aria-expanded: 현재 펼침 상태를 스크린 리더에 알려줍니다. | aria-controls: 버튼이 제어하는 컨텐츠 섹션을 연결합니다. | aria-hidden: 장식용 요소를 스크린 리더에서 숨깁니다. | . 3. 반응형 디자인 구현 . 모든 화면 크기에서 최적의 사용자 경험을 제공하기 위해 CSS 변수와 미디어 쿼리를 활용했습니다. :root { --primary-color: #4a6cf7; --padding-sm: 10px; --padding-md: 20px; --padding-lg: 30px; /* 기타 변수들 */ } @media (max-width: 768px) { .endpoint-header { flex-direction: column; align-items: flex-start; } /* 태블릿용 스타일 */ } @media (max-width: 480px) { :root { --padding-sm: 8px; --padding-md: 15px; --padding-lg: 20px; } /* 모바일용 스타일 */ } . 이렇게 하면 화면 크기에 따라 자동으로 스타일이 조정되어 모든 기기에서 최적의 레이아웃을 제공합니다. 4. HTTP 메서드별 시각적 구분 . GET, POST, PUT, DELETE 등 HTTP 메서드에 따라 색상을 다르게 표시하여 사용자가 직관적으로 API 유형을 구분할 수 있도록 했습니다.method.get { background-color: var(--get-color); } .method.post { background-color: var(--post-color); } .method.put { background-color: var(--put-color); } .method.delete { background-color: var(--delete-color); } . ",
    "url": "/docs/projects/devzip/apiPage/#%EC%A3%BC%EC%9A%94-%EA%B5%AC%ED%98%84-%EB%82%B4%EC%9A%A9",
    
    "relUrl": "/docs/projects/devzip/apiPage/#주요-구현-내용"
  },"606": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "개발 과정에서 마주친 도전과 해결",
    "content": "접근성 문제 . 개발 과정에서 ESLint 접근성 규칙에 의해 다음과 같은 경고가 발생했습니다: . Visible, non-interactive elements with click handlers must have at least one keyboard listener Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role . 이 문제를 해결하기 위해: . | &lt;div&gt; 대신 &lt;button&gt; 요소 사용 | 키보드 이벤트 핸들러 추가 | 적절한 ARIA 속성 추가 | . 반응형 레이아웃 도전 . 작은 화면에서 API 정보가 잘 표시되도록 하는 것이 도전 과제였습니다. 특히 HTTP 메서드와 경로 정보가 긴 경우에 대응해야 했습니다. 미디어 쿼리를 통해 모바일 화면에서는 요소들이 세로로 배치되도록 조정하여 해결했습니다. ",
    "url": "/docs/projects/devzip/apiPage/#%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%9C-%EB%8F%84%EC%A0%84%EA%B3%BC-%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/projects/devzip/apiPage/#개발-과정에서-마주친-도전과-해결"
  },"607": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "결과 및 배운 점",
    "content": "이번 API 목록 페이지 개발을 통해 단순히 기능만 구현하는 것이 아니라, 사용자 경험과 접근성을 함께 고려해야 한다는 점을 다시 한번 깨달았습니다. 특히 다음과 같은 부분에서 성장할 수 있었습니다: . | 접근성의 중요성: 모든 사용자가 콘텐츠에 접근할 수 있도록 하는 것은 선택이 아닌 필수입니다. | 데이터 구조화의 중요성: 잘 설계된 데이터 구조는 UI 개발을 훨씬 수월하게 만들어 줍니다. | CSS 변수의 활용: 테마와 반응형 디자인을 위한 CSS 변수 활용법을 익힐 수 있었습니다. | . ",
    "url": "/docs/projects/devzip/apiPage/#%EA%B2%B0%EA%B3%BC-%EB%B0%8F-%EB%B0%B0%EC%9A%B4-%EC%A0%90",
    
    "relUrl": "/docs/projects/devzip/apiPage/#결과-및-배운-점"
  },"608": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "향후 개선 계획",
    "content": ". | 검색 기능 추가: API를 빠르게 찾을 수 있는 검색 기능 | API 테스트 기능 강화: 실제로 API를 호출하고 결과를 바로 확인할 수 있는 기능 | 문서 버전 관리: API 변경 이력을 볼 수 있는 버전 관리 기능 | . 이번 API 목록 페이지 개발은 사용자 친화적인 문서를 만드는 과정이었고, 좋은 문서가 얼마나 개발자 경험을 향상시킬 수 있는지를 다시 한번 체감했습니다. 앞으로도 계속 사용자 중심의 개발을 이어나가겠습니다. DevZip 프로젝트는 GitHub에서 확인하실 수 있으며, 실제 사이트는 여기에서 확인 가능합니다. ",
    "url": "/docs/projects/devzip/apiPage/#%ED%96%A5%ED%9B%84-%EA%B0%9C%EC%84%A0-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/devzip/apiPage/#향후-개선-계획"
  },"609": {
    "doc": "DevZip API 목록 페이지 개발기",
    "title": "DevZip API 목록 페이지 개발기",
    "content": " ",
    "url": "/docs/projects/devzip/apiPage/",
    
    "relUrl": "/docs/projects/devzip/apiPage/"
  },"610": {
    "doc": "AWS (DVA)",
    "title": "AWS 자격증 - AWS Certified Developer Associate (DVA)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_DVA/#aws-%EC%9E%90%EA%B2%A9%EC%A6%9D---aws-certified-developer-associate-dva",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/#aws-자격증---aws-certified-developer-associate-dva"
  },"611": {
    "doc": "AWS (DVA)",
    "title": "This Page has been written since August 19, 2023.",
    "content": "다음 사이트의 자료를 참고하였습니다. AWS Certified Developer Associate 시험 합격을 위한 모든 것! 덤프 . ",
    "url": "/docs/studies/aws_DA/aws_DVA/#this-page-has-been-written-since-august-19-2023",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/#this-page-has-been-written-since-august-19-2023"
  },"612": {
    "doc": "AWS (DVA)",
    "title": "AWS (DVA)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_DVA/",
    
    "relUrl": "/docs/studies/aws_DA/aws_DVA/"
  },"613": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "AWS Certified Developer Associate - Dump 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#aws-certified-developer-associate---dump-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#aws-certified-developer-associate---dump-1"
  },"614": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "2024.03.27 (WED)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#20240327-wed",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#20240327-wed"
  },"615": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #1",
    "content": "문제 . 한 회사가 Amazon EC2 인스턴스에 애플리케이션을 구현하고 있습니다. 애플리케이션은 들어오는 트랜잭션을 처리해야 합니다. 애플리케이션이 유효하지 않은 거래를 감지하면 애플리케이션은 회사 지원팀에 채팅 메시지를 보내야 합니다. 메시지를 보내려면 애플리케이션이 채팅 API를 사용하여 인증할 액세스 토큰을 검색해야 합니다. 개발자는 액세스 토큰을 저장하는 솔루션을 구현해야 합니다. 액세스 토큰은 저장 및 전송 중에 암호화되어야 합니다. 액세스 토큰은 다른 AWS 계정에서도 액세스할 수 있어야 합니다. 최소한의 관리 오버헤드로 이러한 요구 사항을 충족하는 솔루션은 무엇입니까? . A. AWS Key Management Service(AWS KMS) AWS 관리형 키를 사용하는 AWS Systems Manager Parameter Store SecureString 매개변수를 사용하여 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 매개변수에 리소스 기반 정책을 추가하세요. Parameter Store에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. 암호 해독 플래그가 활성화된 상태로 Parameter Store에서 토큰을 검색합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. B. AWS Key Management Service(AWS KMS) 고객 관리형 키를 사용하여 액세스 토큰을 암호화합니다. Amazon DynamoDB 테이블에 액세스 토큰을 저장합니다. DynamoDB 및 AWS KMS에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. DynamoD에서 토큰 검색EC2 인스턴스에서 AWS KMS를 사용하여 토큰을 해독합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. C. AWS Key Management Service(AWS KMS) 고객 관리형 키와 함께 AWS Secrets Manager를 사용하여 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 보안 비밀에 리소스 기반 정책을 추가하세요. Secrets Manager에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. Secrets Manager에서 토큰을 검색합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. D. AWS Key Management Service(AWS KMS) AWS 관리형 키를 사용하여 액세스 토큰을 암호화합니다. Amazon S3 버킷에 액세스 토큰을 저장합니다. 다른 계정의 액세스를 허용하려면 S3 버킷에 버킷 정책을 추가하세요. Amazon S3 및 AWS KMS에 액세스할 수 있는 권한으로 EC2 인스턴스의 IAM 역할을 업데이트합니다. S3 버킷에서 토큰을 검색합니다. EC2 인스턴스에서 AWS KMS를 사용하여 토큰을 해독합니다. 해독된 액세스 토큰을 사용하여 메시지를 채팅에 보냅니다. 내용 정리 . | AWS KMS(암호화 암호 서명): 데이터를 암호화 할때 사용되는 암호화 Key를 안전하게 관리하는데 목적을 둔 서비스 . | AWS Secrets Manager: 다른 AWS 서비스와 통합되어 암호의 사용을 안전하게 저장 . | . 정답 . 정답: D -&gt; 그런데 커뮤니티 투표 분배는 C가 84%다.. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-1"
  },"616": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #2",
    "content": "내용 체크 . | Amazon SQS: 서버들끼리 사용할 수 있는 메세지 큐를 제공하는 서비스 | 시스템이 처리해야 할 To-Do List | . 정답 (O) . D. 모든 계정에서 이벤트를 수신하도록 기본 계정 이벤트 버스에 대한 권한을 구성합니다. 각 계정에서 Amazon EventBridge 규칙을 생성하여 모든 EC2 인스턴스 수명 주기 이벤트를 기본 계정 이벤트 버스로 보냅니다. 모든 EC2 인스턴스 수명 주기 이벤트와 일치하는 기본 계정 이벤트 버스에 EventBridge 규칙을 추가합니다. SQS 대기열을 규칙의 대상으로 설정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-2",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-2"
  },"617": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #3",
    "content": "내용 체크 . | Amazon Cognito: 웹 및 모바일 앱에 대한 인증과 권한 부여 그리고 사용자 관리를 제공하고 기존의 아이디, 패스워드 방식 이외에도 Facebook, Google 등의 여러 글로벌 회사의 소셜 로그인 기능을 제공하는 서비스. | Cognito는 사용자 풀(user pool)과 자격 증명 풀(identity pool)로 구성되어 있다. | 사용자 풀: 사용자의 가입과 로그인을 제공하는 사용자 저장소 | 자격 증명 풀: 사용자 풀에 저장된 정보를 바탕으로 AWS 인프라의 여러 서비스에 대한 권한을 부여할 수 있는 서비스 | . | . | Amazon S3: 업계 최고의 확장성, 데이터 가용성 및 보안과 성능을 제공하는 객체 스토리지 서비스 | . 정답 (O) . D. Amazon Cognito 자격 증명 접두사 내의 IAM 정책을 사용하여 사용자가 Amazon S3에서 자신의 폴더를 사용하도록 제한합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-3",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-3"
  },"618": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #4",
    "content": "내용 체크 . | AWS Batch: 대규모 데이터 처리를 위한 서비스 . | 작업 대기 열, 컴퓨팅 환경, 작업 정의 등으로 구성 | 작업 정의에서는 컨테이너화된 애플리케이션과 매개 변수를 정의할 수 있다. | . | AWS Step Function: 여러 컴퓨팅 자원들의 수행 순서를 설정할 수 있는 서비스 . | 각 단계가 이전 단계의 출력으로 입력되는 단계로 구성된 워크 플로어를 설계하고 실행할 수 있도록 함으로써, 작업을 보다 쉽게 조정할 수 있게 하는 완전 관리형 서비스 | . | AWS Glue: 완전 관리형 ETL(추출, 변환 및 로드) 서비스 . | 간단하게 여러 데이터 스토어 및 스트림 간에 원하는 데이터를 분류, 정리, 보강, 이동 | 서버리스(관리할 인프라 X) | . | . 정답 (O) . B. AWS 단계 함수 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-4"
  },"619": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #5",
    "content": "내용 체크 . | Amazon DynamoDB . | NoSQL 데이터베이스 | 매우 빠른 쿼리속도 | . | . 정답 (O) . C. Lambda 함수에는 DynamoDB에 쓸 수 있는 IAM 권한이 없습니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-5"
  },"620": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #6",
    "content": "내용 체크 . | AWS CloudFormation: AWS의 대표적인 IaC 기반의 구성 조정 도구 . | 이를 사용하면 VPC, EC2, Lambda 등과 같은 리소스를 수동으로 생성할 필요 없이 리소스들을 템플릿(코드)으로 구성하고 Stack을 생성하여 인프라를 구성할 수 있다. | 인프라 관리 간소화 | 신속하게 인프라 복제 | . | . 정답 (O) . D. CloudFormation 템플릿에서 EC2 인스턴스 유형 목록을 AllowedValues로 사용하여 매개변수를 생성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-6",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-6"
  },"621": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #7",
    "content": "내용 체크 . | BatchGetItem: 아이템을 군집하여 읽는 메서드 | 지수 백오프(Exponential Backoff): 이는 클라이언트가 AWS 서비스에 대해 요청을 보냈을 때, 서비스로부터 응답이 없거나 일시적인 오류가 발생했을 경우, 클라이언트가 다시 시도하기 전에 대기하는 시간을 조정하는 기술입니다. 이 기술은 초기에는 대기 시간을 짧게 시작하고, 매번 실패할 때마다 대기 시간을 지수적으로 늘려가며 요청을 다시 시도합니다. 이는 네트워크 혼잡이나 임시적인 서비스 문제로 인한 부하를 완화하고, 서비스의 가용성과 성능을 향상시킵니다. | 무작위 지연(Randomized Delay): 이는 지수 백오프의 일종으로, 모든 클라이언트가 동시에 다시 시도하는 것을 방지하기 위해 일정 범위 내에서 무작위로 대기 시간을 설정하는 것입니다. 이를 통해 네트워크 트래픽의 집중을 완화하고, 서버 측의 부하를 분산시키는 효과를 얻을 수 있습니다. | . 정답 (X, 오답: (B,C)) . B. 지수 백오프 및 무작위 지연을 사용하여 일괄 작업을 다시 시도합니다. D. 작업이 액세스하는 DynamoDB 테이블의 프로비저닝된 읽기 용량을 늘립니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-7",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-7"
  },"622": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Questoin #8",
    "content": "내용 체크 . | Amazon API Gateway: 개발자가 API를 손쉽게 생성, 게시, 유지관리, 모니터링 및 보안 유지할 수 있는 서비스 | AWS X-Ray: 개발자를 위한 일종의 애플리케이션 분석 및 디버깅 서비스 . | 애플리케이션의 구성(분산 마이크로서비스 등 복잡한 형태)을 시각화한 맵으로 표현해주는 서비스 | . | . 정답 (X, 오답: (C)) . B. 온프레미스 서버에 X-Ray 데몬을 설치하고 실행하여 데이터를 캡처하고 X-Ray 서비스에 전달합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#questoin-8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#questoin-8"
  },"623": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #9",
    "content": "정답 (X, 오답: (D)) . A. AWS Secrets Manager에 API 자격 증명을 저장합니다. AWS SDK를 사용하여 런타임 시 API 자격 증명을 검색합니다. 자격 증명을 사용하여 API 호출을 수행합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-9"
  },"624": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #10",
    "content": "내용 체크 . | Amazon Elastic Container Service(Amazon ECS): 확장성이 뛰어나고 빠른 컨테이너 관리 서비스 . | 컨테이너를 쉽게 실행, 중지하는 등의 관리가 가능하다. | 정답 (O) . A. AWS Systems Manager Parameter Store에서 변수를 검색하도록 애플리케이션을 업데이트하십시오. 각 환경의 각 변수에 대해 Parameter Store의 고유한 경로를 사용하십시오. 각 환경의 AWS Secrets Manager에 자격 증명을 저장합니다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-10",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-10"
  },"625": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #11",
    "content": "내용 체크 . | Amazon Elastic File System(Amazon EFS): 완전관리형 파일 스토리지 서비스 . | 여러 EC2 인스턴스 간에 파일을 공유하고, 파일 시스템의 용량을 자동으로 확장하는 등의 기능을 제공 | . | . 정답 (O) . B. Amazon S3에 저장된 사진의 객체 키와 함께 각 직원의 연락처 정보를 Amazon DynamoDB 테이블에 저장합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-11",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-11"
  },"626": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #12",
    "content": "정답 (O) . B. Amazon Cognito 사용자 풀을 사용하여 사용자 계정을 관리합니다. API에 대한 액세스를 제어하려면 API Gateway에서 Amazon Cognito 사용자 풀 권한 부여자를 생성합니다. Lambda 함수를 사용하여 Amazon S3에 사진을 저장합니다. DynamoDB 테이블에 사진 세부 정보의 일부로 객체의 S3 키를 저장합니다. DynamoDB에 S3 키를 쿼리하여 이전에 업로드한 사진을 검색합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-12",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-12"
  },"627": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #13",
    "content": "내용 체크 . | Amazon SNS: 구독 중인 서비스나 사용자에게 메시지 전달 및 전송을 해주는 서비스 | . 정답 (O) . C. Amazon Simple 알림 서비스(Amazon SNS) 주제를 생성합니다. 특정 속성이 포함된 메시지를 SNS 주제에 게시하도록 Lambda 함수를 구성합니다. 각 파트너의 SNS 주제를 구독하세요. 주제 구독에 적절한 필터 정책을 적용합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-13",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-13"
  },"628": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #14",
    "content": "정답 (X, 오답: (D)) . C. S3 콘솔에서 S3 객체 Lambda 액세스 포인트를 생성합니다. RemovePii 기능을 선택합니다. PII 없이 객체에 액세스하려면 S3 액세스 포인트를 사용하십시오. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-14",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-14"
  },"629": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #15",
    "content": "내용 체크 . | AWS OpsWorks: Chef를 사용하여 모든 형태 및 규모의 애플리케이션을 구성하고 운영하도록 도와주는 구성 관리 서비스 | AWS CodePipeline: 완전관리형 지속적 전달 서비스 . | 소프트웨어를 릴리스하는데 필요한 단계를 모델링, 시각화 및 자동화할 수 있게 도와준다. | . | . 정답 (X, 오답: (D)) . B. 다른 버전의 함수 별칭을 사용하십시오. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-15",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-15"
  },"630": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #16",
    "content": "정답 (X, 오답: (A)) . B. 함수의 메모리를 늘립니다. (CPU 사용률 =&gt; 메모리 증가) . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-16",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-16"
  },"631": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #17",
    "content": "내용 체크 . | AWS Code Deploy: 애플리케이션을 구성하는 파일 군(아티팩트)의 디플로이를 자동화하는 AWS의 관리 서비스 . | 디플로이: 소프트웨어 개발 과정에서 컴파일 코드를 실행 가능한 상태로 만들고, 사용자가 접근 가능한 환경에 배치하는 과정을 의미 | . | . 정답 (X, 오답: ()) . B. ApplicationStop -&gt; BeforeInstall -&gt; AfterInstall -&gt; ApplicationStart . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-17",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-17"
  },"632": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #18",
    "content": "내용 체크 . | Amazon CloudWatch: AWS 리소스와 AWS에서 실시간을 실행 중인 애플리케이션을 모니터링하는 서비스 | . 정답 (O) . B. 외부 결제 처리 API 호출의 실패를 기록하는 사용자 지정 지표를 CloudWatch에 게시합니다. 오류율이 지정된 비율을 초과하면 기존 SNS 주제에 알리도록 CloudWatch 경보를 구성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-18",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-18"
  },"633": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #19",
    "content": "내용 체크 . | API 캐싱: API 실행을 담당하는 프로세스 또는 쓰레드의 실행 없이, 이전의 동일한 요청(Request)의 응답을 그대로 활용하여 클라이언트에게 즉시 응답하는 방법 | 인터페이스 VPC 엔드포인트: Amazon Virtual Private Cloud(VPC)내에서 리소스를 안전하게 액세스할 수 었는 개인적인 연결을 제공 | CORS(교차 원본 리소스 공유): 특정 도메인에서 실행되는 웹 애플리케이션이 다른 도메인의 자원에 액세스할 수 있도록 하는 HTTP 기능 | . 정답 (O) . A. API 게이트웨이에서 API 캐싱을 활성화합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-19",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-19"
  },"634": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "Question #20",
    "content": "내용 체크 . | Amazon RDS: 클라우드에서 관계형 데이터베이스를 간편하게 설정, 운영 및 확장 가능 | . 정답 (O) . A. Amazon DynamoDB 테이블을 생성합니다. 제목을 파티션 키로, 출시 연도를 정렬 키로 구성하는 기본 키를 사용하여 테이블을 구성합니다. 장르를 파티션 키로, 제목을 정렬 키로 사용하는 글로벌 보조 인덱스를 생성합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-20",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/#question-20"
  },"635": {
    "doc": "AWS (DVA) - Dump 1",
    "title": "AWS (DVA) - Dump 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump1/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump1/"
  },"636": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "AWS Certified Developer Associate - Dump 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#aws-certified-developer-associate---dump-2",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#aws-certified-developer-associate---dump-2"
  },"637": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "2024.03.27 (WED)",
    "content": ". 21 ~ 40 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#20240327-wed",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#20240327-wed"
  },"638": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #21",
    "content": "정답 (O) . A. API Gateway API에서 개발 단계를 정의합니다. 다른 개발자에게 엔드포인트가 개발 단계를 가리키도록 지시합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-21",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-21"
  },"639": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #22",
    "content": "정답 (X, 오답: (C)) . A. Redis 인스턴스용 Amazon ElastiCache를 생성합니다. 전송 중인 데이터와 저장 중인 데이터의 암호화를 활성화합니다. 자주 액세스하는 데이터를 캐시에 저장합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-22",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-22"
  },"640": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #23",
    "content": "내용 체크 . | AWS SDK: AWS를 프로그래밍적으로 유기적으로 다루기 위한 개발 도구 | . 정답 (O) . C. 리포지토리를 호스팅할 Amazon S3 버킷을 생성합니다. 기존 .xml 파일을 S3 버킷으로 마이그레이션합니다. AWS SDK를 사용하여 Amazon S3에서 구성 파일을 읽고 쓰도록 애플리케이션 코드를 업데이트합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-23",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-23"
  },"641": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #24",
    "content": "내용 체크 . | AWS Amplify: 사용자 인증, 실시간 데이터, AI/ML, 파일 스토리지 등 백엔드 사용사례를 지원하도록 하는 도구 및 기능 세트 | AWS Elastic Beanstalk: Java, .NET, PHP 등을 사용하여 Apache, Nginx, IIS와 같은 친숙한 서버에서 개발된 웹 애플리케이션 및 서비스를 간편하게 배포하고 조정할 수 있는 서비스 . | 코드를 업로드해서 용량 프로비저닝, 로드 밸런싱, 오토 스케일링, 애플리케이션 상태 모니터링, 배포를 자동으로 처리하도록 구성 | . | EB CLI: 로컬 리포지토리에서 환경 생성, 업데이트 및 모니터링을 단순화하는 대화형 명령을 제공하는 AWS Elastic Beanstalk용 명령줄 인터페이스 | . 정답 (X, 오답: (B)) . A. 서버리스 백엔드와 함께 AWS Amplify를 사용하여 각 웹사이트를 호스팅합니다. 원하는 각 환경에 해당하는 저장소 분기를 연결했습니다. 코드 변경 사항을 원하는 브랜치에 병합하여 배포를 시작하세요. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-24",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-24"
  },"642": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #25",
    "content": "정답 (X, 오답: (B)) . C. 하나 이상의 읽기 전용 복제본을 사용하여 Amazon RDS를 배포합니다. 쿼리가 읽기 전용 복제본의 URL을 사용하도록 애플리케이션 코드를 수정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-25",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-25"
  },"643": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #26",
    "content": "정답 (O) . B. Amazon DynamoDB 테이블을 생성합니다. 각 요청의 고유 식별자를 테이블에 저장합니다. 요청을 처리하기 전에 테이블에서 식별자를 확인하도록 Lambda 함수를 수정합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-26",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-26"
  },"644": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #27",
    "content": "내용 체크 . | ASW ACM: AWS 웹사이트와 애플리케이션을 보호하는 퍼블릭 및 프라이빗 SSL/TCS X.509 인증서와 키를 만들고, 저장하고, 갱신하는 복잡성을 처리 | . 정답 (X, 오답: (B)) . A. 새 AMI를 생성하고 암호화 매개변수를 지정합니다. 암호화된 AMI를 대상 리전에 복사합니다. 암호화되지 않은 AMI를 삭제합니다. 암호화되지 않은 AMI에서는 암호화를 활성화할 수 없습니다. AMI 복사본을 암호화하려면 소스 AMI를 먼저 암호화해야 합니다. 소스가 암호화되지 않으면 AMI 복사본을 암호화할 수 없습니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-27",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-27"
  },"645": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #28",
    "content": "내용 체크 . | Amazon CloudFront: AWS에서 제공하는 CDN(Content Delivery Network) . | CDN: 콘텐츠 전송 네트워크, 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하는 시스템 | . | . 정답 (O) . C. 중앙 S3 버킷에 대한 액세스를 허용하는 CORS(교차 원본 리소스 공유) 구성을 생성합니다. 중앙 S3 버킷에 CORS 구성을 추가합니다. 자주 발생하는 문제입니다. 웹 애플리케이션은 일부 예외를 제외하고 기본적으로 다른 도메인의 리소스에 액세스할 수 없습니다. 액세스할 리소스에 CORS를 구성해야 합니다. -&gt; CORS: Cross-Origin Resource Sharing의 약자로, 출처가 다른 자원들을 공유한다는 뜻으로, 한 출처에 있는 자원에서 다른 출처에 있는 자원에 접근하도록 하는 개념 . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-28",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-28"
  },"646": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Qustion #29",
    "content": "내용 체크 . | Amazon Kinesis: 실시간으로 데이터 스트림을 수집, 처리, 분석해주는 서비스 (샤드 조절을 통해) . | 위 서비스는 완전 관리형이라, 인프라 관리를 하지 않아도 됨 | . | 클릭스트림 데이터: 소비자 행동을 파악하는 데 사용할 수 있는 웹 트래픽 등 | PutRecords API | Amazon SNS: 구독중인 Service 또는 사용자(Client)에 메시지 전달, 전송을 조정 및 관리하는 웹서비스 (알림서비스) | . 정답 (X, 오답: (B)) . A. 지수 백오프로 재시도를 구현합니다. C. 요청 빈도 및/또는 크기를 줄입니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#qustion-29",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#qustion-29"
  },"647": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #30",
    "content": "정답 (O) . B. Amazon Simple Email Service(Amazon SES)를 사용하여 이메일 알림을 보내는 AWS Lambda 함수를 생성합니다. 함수에 대한 Amazon Cognito 사후 인증 Lambda 트리거를 추가합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-30",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-30"
  },"648": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "Question #31",
    "content": "정답 (X, 오답: (A)) . B. PutObject API 작업을 호출할 때 x-amz-server-side-encryption 헤더를 설정합니다. | 이 이후는, 자체 풀이로,,, | . ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-31",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/#question-31"
  },"649": {
    "doc": "AWS (DVA) - Dump 2",
    "title": "AWS (DVA) - Dump 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_c02_dump2/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_c02_dump2/"
  },"650": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS Certified Developer Associate - Section 4 (IAM)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#aws-certified-developer-associate---section-4-iam",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#aws-certified-developer-associate---section-4-iam"
  },"651": {
    "doc": "AWS (DVA) - Section 4",
    "title": "2023.09.14 (THU)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#20230914-thu",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#20230914-thu"
  },"652": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS Identity &amp; Access Management (AWS IAM)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#aws-identity--access-management-aws-iam",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#aws-identity--access-management-aws-iam"
  },"653": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM: Users &amp; Groups",
    "content": ". | IAM에서는 사용자를 생성하고 그룹에 배치하기 때문에, 글로벌 서비스이다. | 루트 어카운트는 기본으로 만들어진다. 이후, 루트는 사용되거나 공유되면 안된다. | 사용자와 그룹을 만들어 사용한다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-users--groups",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-users--groups"
  },"654": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM: 권한",
    "content": ". | 사용자 또는 그룹에게 정책, 또는 IAM 정책이라고 불리는 JSON문서를 지정할 수 있다. | AWS는 필요 이상의 권한을 사용자에게 주지 않는다. | 그룹에게 권한을 부여하는 정책이 있으며, 개인에게는 개인에게만 적용되는 인라인 정책이라는 것을 생성할 수 있다. | IAM 정책 구조 . | 그룹과 사용자들의 정보 보호 . | 비밀번호 정책 . | ex) 길이 제한, 특수문자 등 | . | (중요) 다요소 인증 - MFA . | AWS에서 필수적으로 사용하도록 권장 | 적어도 root를, 최대한 IAM 사용자를 지켜야 함 | 따라서 비밀번호 외, MFA를 이용하는 것이다. | ex) Alice has Password + MFA Token =&gt; 로그인 성공! . | AWS에서 MFA 장치 옵션 (중요) . | 가상 MFA 장치 : 모바일이나 기타 장비로 가능 (Like 모바일 OTP) | U2F 보안 키 (물리) | 하드웨어 키 팝 MFA (물리) | . | . | . | 유저가 AWS에 접근하는 방법 . | AWS Management Console (protected by password + MFA) | AWS Command Line Interface (CLI): protected by access keys | AWS Software Developer Kit (SDK) - for code: protected by access keys . | 다들 각자의 키를 생성하기 때문에, 개인 키는 공유하면 안된다 | . | Access Key ID ~= username | Secret Access Key ~= password | . | . | AWS CLI . | AWS 서비스와 상호 작용할 수 있는 오픈소스 도구 | AWS CLI를 사용하면 Pwershell이나 터미널에서도 AWS에서 제공하는 명령어 기능을 실행할 수 있다. -&gt; 실습 해봄 | CLI 권한은 IAM 권한과 같다. | AWS CloudShell에서도 접속할 수 있다. | . | AWS SDK . | 소프트웨어 개발 키트 | 코딩을 통해 애플리케이션 내에 심어두는 것 | . | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-%EA%B6%8C%ED%95%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-권한"
  },"655": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM Roles",
    "content": "이는 사용자와 유사하지만, 실제 사용자가 사용하는 것이 아니라 AWS 서비스가 사용하는 것을 말한다. ex) EC2 인스턴스가 AWS에서 작업을 수행할 수 있도록, EC2에게 권한을 부여하는 것이다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-roles",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-roles"
  },"656": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM Security Tools",
    "content": ". | IAM 자격 증명 보고서 (계정 레벨) . | 계정에 있는 사용자와 다양한 자격 증명의 상태를 포함 | . | IAM 액세스 관리자 (유저 레벨) . | 사용자의 권한을 관리 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-security-tools",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-security-tools"
  },"657": {
    "doc": "AWS (DVA) - Section 4",
    "title": "IAM 요약",
    "content": ". | Users: mapped to a physical user, has a password for AWS Console | Groups: contains users only | Policies: JSON document that outlines permissions for users or groups | Roles: for EC2 instances or AWS services | Security: MFA + Password Policy | AWS CLI: manage your AWS services using the command-line | AWS SDK: manage your AWS services using a programming language | Access Keys: access AWS using the CLI or SDK | Audit: IAM Credential Reports &amp; IAM Access Advisor | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/#iam-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/#iam-요약"
  },"658": {
    "doc": "AWS (DVA) - Section 4",
    "title": "AWS (DVA) - Section 4",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section4/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section4/"
  },"659": {
    "doc": "AWS (DVA) - Section 5",
    "title": "AWS Certified Developer Associate - Section 5 (EC2 기초)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#aws-certified-developer-associate---section-5-ec2-%EA%B8%B0%EC%B4%88",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#aws-certified-developer-associate---section-5-ec2-기초"
  },"660": {
    "doc": "AWS (DVA) - Section 5",
    "title": "2023.09.19 (TUE) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#20230919-tue-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#20230919-tue-"
  },"661": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스"
  },"662": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2란?",
    "content": "Elastic Compute Cloud = Infrasturcture as a Service . EC2의 작동방식을 알아야, 클라우드 작동 방식을 이해할 수 있다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2란"
  },"663": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스 가상 서버에 사용 가능한 옵션",
    "content": ". | Operating System (OS): Linux, Windows or Mac OS | CPU, RAM 선택 가능 | 스토리지 공간 선택 가능 . | 네트워크를 통해 연결되는 스토리지 (EBS, EFS) | 하드워드를 통해 연결되는 스토리지 (EC2 Instance Store) | . | EC2 인스턴스에 연결할 네트워크 유형도 선택 가능 . | 네트워크 카드 속도 | 사용할 공개 IP | . | 방화벽 규칙: 보안 그룹 | Bootstrap script: EC2 User Data | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EA%B0%80%EC%83%81-%EC%84%9C%EB%B2%84%EC%97%90-%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스-가상-서버에-사용-가능한-옵션"
  },"664": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 User Data",
    "content": "이를 사용해 인스턴스를 Bootstrap 할 수 있다. Bootstrapping: 머신이 시작할 때, 명령을 실행하는 것 . | 이 스크립트는 오직 인스턴스 시작 시 한번만 실행된다. | 작업 . | 업데이트 설치 | 소프트웨어 설치 | 인터넷 파일 다운로드 | 등등 | . | 루트 사용자로 실행된다. (psuedo) . | 예시 . | 해당 빈 칸에, 전달하고 싶은 명령어를 넣으면 된다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-user-data",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-user-data"
  },"665": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 생성 실습",
    "content": "기존 사용하던 계정 말고, 다른 새 계정을 만들어 프리티어로 실습을 진행한다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%83%9D%EC%84%B1-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-생성-실습"
  },"666": {
    "doc": "AWS (DVA) - Section 5",
    "title": "EC2 인스턴스 유형",
    "content": "예시로 'm5.2xlarge' 라는 유형의 인스턴스를 예로 들어본다. | m: 인스턴스 클래스 | 5: 인스턴스 세대 . | AWS가 하드웨어를 계속 개선해서 새로운 세대의 하드웨어를 출시하면 m5 -&gt; m6가 되는 것. | . | 2xlarge: 인스턴스 크기 (클수록 인스턴스에 더 많은 메모리와 CPU를 가지게 됨) | . | 범용 목적 . | 범용의 인스턴스는 웹 서버나 코드 저장소와 같은 다양한 작업에 적합 | 컴퓨팅, 메모리, 네트워킹 간의 균형도 잘맞는다. | . | 컴퓨팅 최적화 인스턴스 . | 컴퓨터 집약적인 작업에 최적화된 인스턴스 | 머신러닝, 전용 게임 서버, 고성능 웹서버 | 컴퓨터 최적화의 모든 인스턴스는 C로 시작하는 이름을 가짐 (C5, C5 등) | . | 메모리 최적화 인스턴스 . | 메모리에서 대규모 데이터셋을 처리하는 유형의 작업에 적합 | R로 시작함 (RAM) | . | 스토리지 최적화 인스턴스 . | 로컬 스토리지에서 대규모의 데이터셋에 액세스할 때 적합 | I, G, H1 등 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ec2-인스턴스-유형"
  },"667": {
    "doc": "AWS (DVA) - Section 5",
    "title": "보안 그룹",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#보안-그룹"
  },"668": {
    "doc": "AWS (DVA) - Section 5",
    "title": "보안 그룹이란?",
    "content": "AWS 클라우드에서 네트워크 보안을 실현하는 데 기본적인 기능 (보안 그룹 = 방화벽) . 보안 그룹을 이용해 EC2 인스턴스의 인바운드 및 아웃바운드 트래픽을 제어 기본적으로 허용 규칙만 사용 . | 인바운드 트래픽: 외부에서 EC2 인스턴스로 들어오는 트래픽을 허용되는지 지정 | 아웃바운드 트래픽: 내부에서 인터넷으로 통신할 수 있는지 지정 . | 보안 그룹은 여러 인스턴스에 연결할 수 있다. (다대다 관계) | SSH 전용의 별도의 보안 그룹을 관리하는 것이 좋다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#보안-그룹이란"
  },"669": {
    "doc": "AWS (DVA) - Section 5",
    "title": "특정 보안 그룹을 다른 보안 그룹에서 참조",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%ED%8A%B9%EC%A0%95-%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%9D%84-%EB%8B%A4%EB%A5%B8-%EB%B3%B4%EC%95%88-%EA%B7%B8%EB%A3%B9%EC%97%90%EC%84%9C-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#특정-보안-그룹을-다른-보안-그룹에서-참조"
  },"670": {
    "doc": "AWS (DVA) - Section 5",
    "title": "포트에 대해 알아야 할 것들",
    "content": ". | 22 = SSH - EC2 인스턴스에 로그인할 때 사용 | 21 = FTP - 파일 전송 프로토콜 용 | 80 = HTTP - 보안이 적용되지 않은 웹사이트에 액세스 | 443 = HTTPS - 보안이 적용된 웹사이트 | 3389 = RDP - 원격 데스크톱 프로토콜 (윈도우 인스턴스 로그인 용) | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#%ED%8F%AC%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B2%83%EB%93%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#포트에-대해-알아야-할-것들"
  },"671": {
    "doc": "AWS (DVA) - Section 5",
    "title": "SSH 접속 실습",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/#ssh-%EC%A0%91%EC%86%8D-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/#ssh-접속-실습"
  },"672": {
    "doc": "AWS (DVA) - Section 5",
    "title": "AWS (DVA) - Section 5",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section5/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section5/"
  },"673": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AWS Certified Developer Associate - Section 6 (EC2 인스턴스 스토리지 / EBS)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#aws-certified-developer-associate---section-6-ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80--ebs",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#aws-certified-developer-associate---section-6-ec2-인스턴스-스토리지--ebs"
  },"674": {
    "doc": "AWS (DVA) - Section 6",
    "title": "2023.09.25 (MON) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#20230925-mon-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#20230925-mon-"
  },"675": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EC2 인스턴스 스토리지",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ec2-인스턴스-스토리지"
  },"676": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨",
    "content": "Elastic Block Store Volume . | 인스턴스가 실행 중인 동안 연결 가능한 네트워크 드라이브 | 인스턴스 종류된 후에도 데이터를 지속할 수 있다. | EBS 볼륨을 생성할 때는 특정 가용 영역에서만 가능하다. | 스냅샷을 이용하면 다른 가용 영역으로 볼륨 옮기기 가능 | . | . EBS 볼륨 = 네트워크 USB 스틱 . | 네트워크 드라이브로 EC2 인스턴스에서 분리될 수 있다. | 볼륨이기에 용량을 미리 결정해야 한다. | 인스턴스에 연결할 수 있어, 필요한 경우에만 연결한다. | . EC2 인스턴스를 통해 EBS 볼륨을 생성하는 경우, 종료 시 삭제 속성 - 기본 설정은 체크가 해제되어 있음 (인스턴스 root는 체크가 되어있음) . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨"
  },"677": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨 실습",
    "content": ". | EBS 볼륨은 특정 가용 영역의 인스턴스에만 부착할 수 있다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨-실습"
  },"678": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 스냅샷",
    "content": ". | EBS 볼륨의 특정 시점에서의 백업 | 스탭샷을 다른 가용 영역 및 다른 리전에 복사할 수 있다. | . 스냅샷의 기능 . | 스냅샷 아카이브 . | 스냅샷을 최대 75% 더 저렴한 아카이브 디어로 옮기는 기능 | . | EBS 스냅샷을 위한 휴지통을 만들기 . | 스냅샷을 영구적으로 삭제하는 대신, 휴지통에 보관 | 실수로 삭제한 경우 복구 가능 (보관 기간 : 하루에서 1년 설정 가능) | . | 스냅샷 완전 초기화 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EC%8A%A4%EB%83%85%EC%83%B7",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-스냅샷"
  },"679": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AMI",
    "content": "Amazon Machine Image = 사용자 지정 EC2 인스턴스 . AMI를 생성하면 부팅과 구성에 시간이 단축된다. EC2 인스턴스의 AMI 처리 . | 인스턴스를 시작하고, 이를 사용자 지정으로 바꾼다. | 인스턴스를 중지시켜, 데이터 무결성을 확보한다. | 다른 AMI에서 인스턴스를 실행할 수 있게 된다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ami",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ami"
  },"680": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EC2 Instance Store",
    "content": "EC2 인스턴스는 가상 머신이지만, 실제로는 하드웨어 서버에 연결되어 있고 물리적으로 연결된 디스크 공간을 갖는다. 따라서, 특정 유형의 EC2 인스턴스는 EC2 인스턴스 스토어라고 블린다. 이 EC2 인스턴스 스토어는 I/O 성능 향상을 위해 활용할 수 있다. EC2 인스턴스 스토어 = 임시 스토리지 장기 스토리지 경우, EBS가 적합 . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ec2-instance-store",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ec2-instance-store"
  },"681": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 볼륨 유형",
    "content": "EBS 볼륨에는 6가지 타입이 있다. | gp2 / gp3 (SSD) : 범용 SSD 볼륨 | io1 / io2 (SSD) : 최고 성능 SSD 볼륨, 미션 크리티컬, 지연 시간 낮음, 대용량의 워크로드에 쓰인다. | st1 (HDD) : 저비용의 HDD 볼륨 | sc1 (HDD) : 가장 비용이 적게 드는 HDD 볼륨 | . 이 중, gp2/gp3, io1/io2만 부팅 볼륨으로 사용될 수 있다. EBS 볼륨 정의 방법 . 크기, 처리량, IOPS(초당 I/O 작업 수) . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%B3%BC%EB%A5%A8-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-볼륨-유형"
  },"682": {
    "doc": "AWS (DVA) - Section 6",
    "title": "시험에선 범용 gp2와 IOPS 프로비저닝이 가장 중요한 내용",
    "content": "gp2/gp3 . 짧은 지연 시간을 자랑하며, 효율적인 비용의 스토리지 . | gp3에선 IOPS와 처리량을 독자적으로 설정할 수 있다. | gp2에선 그 둘이 연결되어 있다. | . IOPS 프로비저닝 . IOPS 성능을 유지할 필요가 있는 주요 비즈니스 애플리케이션이나, 16,000 IOPS 이상을 요구하는 애플리케이션에 적합 . | 일반적으로 데이터베이스 워크로드에 알맞다. | gp2/gp3에 -&gt; io1 또는 io2 볼륨으로 바꾸면 된다. | . io2는 io1과 동일한 비용에 내구성과 기가 당 IOPS의 수가 더 높다. -&gt; io2가 합리적 . st1, sc1 . | 부팅 볼륨 X | 빅데이터, 데이터 웨어하우징 로그 처리에 적합 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#%EC%8B%9C%ED%97%98%EC%97%90%EC%84%A0-%EB%B2%94%EC%9A%A9-gp2%EC%99%80-iops-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D%EC%9D%B4-%EA%B0%80%EC%9E%A5-%EC%A4%91%EC%9A%94%ED%95%9C-%EB%82%B4%EC%9A%A9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#시험에선-범용-gp2와-iops-프로비저닝이-가장-중요한-내용"
  },"683": {
    "doc": "AWS (DVA) - Section 6",
    "title": "EBS 다중 연결",
    "content": "다중 연결 기능을 사용하면 동일한 EBS 볼륨을 동일한 가용영역에 있는 여러 개의 EC2 인스턴스에 첨부할 수 있다. 시험에 나오는 내용 : 하나의 볼륨은 한번에 최대 16개의 EC2 인스턴스에 부착할 수 있다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#ebs-%EB%8B%A4%EC%A4%91-%EC%97%B0%EA%B2%B0",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#ebs-다중-연결"
  },"684": {
    "doc": "AWS (DVA) - Section 6",
    "title": "Amazon EFS (탄력적 파일 시스템)",
    "content": "EFS: 관리형 NFS(네트워크 파일 시스템) 네트워크 파일 시스템이기 때문에, 많은 EC2 인스턴스에 마운트 가능 (서로 다른 가용 영역도 가능) . 특징 . | 가용성이 높다. | 확장성이 높다. | 비용은 gp2 볼륨의 3배이다. | 사용량에 따라 비용을 지불!!!! | . | . 사용처 . | 콘텐츠 관리 | 웹 서비스 | 데이터 공유 | 워드 프레스 | . 호환 . 이 기능은 Window가 아닌 Linux 기반 AMI와만 호환된다. 성능 및 스토리지 클래스 . EFS 스케일에서는 수천 개의 동시 NFS 클라이언트와 10기가바이트 이상의 처리량이 가능하다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/#amazon-efs-%ED%83%84%EB%A0%A5%EC%A0%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/#amazon-efs-탄력적-파일-시스템"
  },"685": {
    "doc": "AWS (DVA) - Section 6",
    "title": "AWS (DVA) - Section 6",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section6/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section6/"
  },"686": {
    "doc": "AWS (DVA) - Section 7",
    "title": "AWS Certified Developer Associate - Section 7 (AWS 기초: ELB + ASG)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#aws-certified-developer-associate---section-7-aws-%EA%B8%B0%EC%B4%88-elb--asg",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#aws-certified-developer-associate---section-7-aws-기초-elb--asg"
  },"687": {
    "doc": "AWS (DVA) - Section 7",
    "title": "2023.11.21 (TUE) ~",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#20231121-tue-",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#20231121-tue-"
  },"688": {
    "doc": "AWS (DVA) - Section 7",
    "title": "고가용성 및 확장성",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1-%EB%B0%8F-%ED%99%95%EC%9E%A5%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#고가용성-및-확장성"
  },"689": {
    "doc": "AWS (DVA) - Section 7",
    "title": "확장성",
    "content": "애플리케이션 시스템이 조정을 통해 더 많은 양을 처리할 수 있다는 의미 . | 수직 확장성 . | 인스턴스 크기 확장 | 하드웨어 제한이 있기 때문에, 한계가 있다. | . | 수평 확장성(탄력성) . | 인스턴스나 시스템의 수를 늘리는 방법 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%ED%99%95%EC%9E%A5%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#확장성"
  },"690": {
    "doc": "AWS (DVA) - Section 7",
    "title": "고가용성",
    "content": "애플리케이션 또는 시스템을 적어도 둘 이상의 AWS의 AZ나 데이터 센터에서 가동중인 것을 의미 . | 고가용성의 목표: 데이터 센터에서의 손실을 막기 위해 (센터 하나가 멈춰도 계속 작동이 가능하게끔) | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#고가용성"
  },"691": {
    "doc": "AWS (DVA) - Section 7",
    "title": "일래스틱 로드 밸런싱(ELB)",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EC%9D%BC%EB%9E%98%EC%8A%A4%ED%8B%B1-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1elb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#일래스틱-로드-밸런싱elb"
  },"692": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서",
    "content": "서버 혹은 서버셋으로 트래픽을 백엔드나 다운스트림 EC2 인스턴스 또는 서버들로 전달하는 역할 = 관리형 로드 밸런서 . | 쉽게 말해, 중재하는 관리자? | 왜 필요한가? . | 부하를 다수의 다운스트림 인스턴스로 분산하기 위해 | 어떤 인스턴스로 트래픽을 보낼 수 없는지도 확인해준다. | 클라우드 내에서 개인 트래픽과 공공 트래픽을 분리할 수 있다. | . | AWS가 관리하며, 어떤 경우에도 작동할 것을 보장함. (고가용성을 책임) | 무조건 쓰는 편이 좋음. | 자체 관리보다 저렴함 | 로드밸런서는 다수의 AWS와 연동됨 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서"
  },"693": {
    "doc": "AWS (DVA) - Section 7",
    "title": "Health Checks",
    "content": "ELB가 EC2 인스턴스의 작동이 올바르게 되고 있는지의 여부를 확인하기 위해 사용된다. | 제대로 작동하지 않으면, 해당 인스턴스로 트래픽을 보낼 수 없기 때문에 Health Checks는 굉장히 중요하다. | Health Checks는 포트와 라우트에서 이뤄진다. | EC2에서 http 200 응답을 주지 않으면, unhealthy하다 판단하고 ELB는 그쪽으로 트래픽을 보내지 않는다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#health-checks",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#health-checks"
  },"694": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서의 Types",
    "content": ". | Classic Load Balancer (v1) - call CLB . | 지금은 권장하지 않음 | . | Application Load Balancer (v2) - call ALB | Network Load Balancer (v2) - call NLB | Gateway Load Balancer - call GWLB | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-types",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서의-types"
  },"695": {
    "doc": "AWS (DVA) - Section 7",
    "title": "로드 밸런서의 보안그룹",
    "content": ". | EC2 인스턴스의 보안 그룹을 로드 밸런서의 보안 그룹으로 연결한다. | 그렇게 되면 EC2 인스턴스는 로드 밸런서에서 온 트래픽만을 허용하게 된다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-%EB%B3%B4%EC%95%88%EA%B7%B8%EB%A3%B9",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#로드-밸런서의-보안그룹"
  },"696": {
    "doc": "AWS (DVA) - Section 7",
    "title": "1. CLB",
    "content": "-&gt; 이제 사용하지 않아, 다루지 않는다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#1-clb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#1-clb"
  },"697": {
    "doc": "AWS (DVA) - Section 7",
    "title": "2. ALB",
    "content": "7계층 - HTTP 전용 로드밸런서 . | 동일 EC2 인스턴스 상의 여러 애플리케이션에 부하를 분산한다. | 컨테이너와 ECS를 사용함 | . | HTTP에서 HTTPS로 트래픽을 자동 리다이렉트를 하려는 경우, 로드 밸런서 레벨에서 가능하다. | 경로 라우팅도 지원 | 뭐리 문자열과 헤더에 기반한 라우팅도 가능 | ALB 하나만으로도 다수의 애플리케이션을 처리할 수 있다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#2-alb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#2-alb"
  },"698": {
    "doc": "AWS (DVA) - Section 7",
    "title": "3. NLB",
    "content": "4계층 - TCP/UDP 트래픽 처리 . | 고성능 (초당 수백만건 요청 처리) | 가용 영역 당 하나의 고정 IP만 있다. | 각 가용 영역에 탄력적 IP를 배정할 수 있다. | 이건 여러 고정 IP가 있는 애플리케이션을 노출해야 할 때 유용 | . | NLB의 대상 그룹이 하는 상태 확인은 TCP, HTTP, HTTPS 프로토콜을 지원한다. | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#3-nlb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#3-nlb"
  },"699": {
    "doc": "AWS (DVA) - Section 7",
    "title": "4. GWLB",
    "content": "배포 및 확장과 AWS의 타사 네트워크 가상 어플라이언스의 플릿 관리에 사용됨 . | 방화벽을 통과하게 하거나, 침입 탐지 및 방지 시스템에 사용된다. | 1). 라우팅 테이블이 수정되면, 모든 사용자 트래픽은 GWLB를 통과 | 2). GWLB는 가상 어플라이언스의 대상 그룹 전반으로 트래픽을 확한 | 3). 모든 트래픽은 어플라이언스에 도달하고 어플라이언스는 트래픽을 분석하고 처리 | 4). 이상이 없다면 다시 GWLB로 보내고, 이상이 있으면 트래픽을 드롭 | 5). 허용된 트래픽은 GWLB에서 애필리케이션으로 보내짐 | 기능 . | 1). 투명 네트워크 게이트웨이 | 2). 로드밸런서 | . | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#4-gwlb",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#4-gwlb"
  },"700": {
    "doc": "AWS (DVA) - Section 7",
    "title": "ELB의 고정 세션 or 세션 밀접성",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/#elb%EC%9D%98-%EA%B3%A0%EC%A0%95-%EC%84%B8%EC%85%98-or-%EC%84%B8%EC%85%98-%EB%B0%80%EC%A0%91%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/#elb의-고정-세션-or-세션-밀접성"
  },"701": {
    "doc": "AWS (DVA) - Section 7",
    "title": "AWS (DVA) - Section 7",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section7/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section7/"
  },"702": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "AWS ALB (Application Load Balancer) 학습 정리",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/"
  },"703": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "목차",
    "content": ". | 개요 | 1. Health Check 기능 . | 동작 방식 | . | 2. Security Group을 통한 보안 설정 | 3. ALB는 HTTP 전용 로드밸런서 . | HTTP → HTTPS 자동 리다이렉션 기능 | 동작 흐름 | . | 4. Target Group 이란? . | 정의 | 주요 개념 | . | 5. 애플리케이션 서버는 Client의 진짜 IP를 직접 볼 수 없다 . | 문제 상황 | 해결: X-Forwarded-For 헤더 | . | 6. Private IP로의 직접 접근 차단 . | 보안 설정 | 이점 | . | 7. ALB를 적절히 설정하면 서비스 배포를 더 좋게 할 수 있다 . | 핵심 아이디어 | . | 학습 요약 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#목차"
  },"704": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "개요",
    "content": "오늘 학습한 AWS ALB(Application Load Balancer)의 핵심 개념들을 정리했습니다. ALB는 HTTP/HTTPS 트래픽을 여러 EC2 인스턴스에 분산시키는 로드밸런서입니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#개요"
  },"705": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "1. Health Check 기능",
    "content": "동작 방식 . | ALB가 EC2 인스턴스들의 상태를 지속적으로 확인 | 정상적인 인스턴스에만 트래픽을 전달 | 문제가 있는 인스턴스는 자동으로 트래픽에서 제외 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#1-health-check-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#1-health-check-기능"
  },"706": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "2. Security Group을 통한 보안 설정",
    "content": ". | ALB 자체에 보안 그룹을 적용할 수 있음 | 들어오는 트래픽의 소스를 제어 | 특정 포트와 프로토콜만 허용 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#2-security-group%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%B3%B4%EC%95%88-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#2-security-group을-통한-보안-설정"
  },"707": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "3. ALB는 HTTP 전용 로드밸런서",
    "content": "HTTP → HTTPS 자동 리다이렉션 기능 . | HTTP로 들어온 요청을 HTTPS로 자동 전환 | ALB에서 리다이렉션 규칙을 설정 | 백엔드 서버의 부하를 줄일 수 있음 | . 동작 흐름 . Client ──HTTP──&gt; ALB ──Load Balance──&gt; EC2 ↑ │ (Private IP) └──True IP─────┘ . | 클라이언트가 HTTP로 요청 | ALB가 HTTPS로 리다이렉션 응답 | 클라이언트가 HTTPS로 재요청 | ALB가 백엔드 EC2로 트래픽 전달 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#3-alb%EB%8A%94-http-%EC%A0%84%EC%9A%A9-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#3-alb는-http-전용-로드밸런서"
  },"708": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "4. Target Group 이란?",
    "content": "정의 . | EC2 인스턴스나 다른 AWS 서비스들의 그룹 | ALB에서 트래픽을 전달받을 대상들의 논리적 그룹 | . 주요 개념 . | 로드밸런서가 트래픽을 분산시킬 대상들을 묶어서 관리 | 각 Target Group마다 별도의 헬스 체크 설정 가능 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#4-target-group-%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#4-target-group-이란"
  },"709": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "5. 애플리케이션 서버는 Client의 진짜 IP를 직접 볼 수 없다",
    "content": "문제 상황 . | 로드밸런서를 통해 들어오는 요청의 경우 | 애플리케이션 서버는 로드밸런서의 Private IP만 확인 가능 | 실제 클라이언트의 IP 주소를 직접 알 수 없음 | . 해결: X-Forwarded-For 헤더 . | 진짜 클라이언트 IP는 X-Forwarded-For 헤더에 들어있음 | 애플리케이션에서 이 헤더를 읽어서 실제 클라이언트 IP를 확인해야 함 | . X-Forwarded-For: 실제클라이언트IP . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#5-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B2%84%EB%8A%94-client%EC%9D%98-%EC%A7%84%EC%A7%9C-ip%EB%A5%BC-%EC%A7%81%EC%A0%91-%EB%B3%BC-%EC%88%98-%EC%97%86%EB%8B%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#5-애플리케이션-서버는-client의-진짜-ip를-직접-볼-수-없다"
  },"710": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "6. Private IP로의 직접 접근 차단",
    "content": "보안 설정 . | 클라이언트는 오직 로드밸런서를 통해서만 접근 가능 | EC2 인스턴스의 보안 그룹에서 ALB에서 오는 트래픽만 허용 | 외부에서 인스턴스로 직접 접근하는 것을 차단 | . 이점 . | 보안 강화: 인스턴스가 직접 노출되지 않음 | 중앙 집중식 관리: 모든 트래픽이 로드밸런서를 경유 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#6-private-ip%EB%A1%9C%EC%9D%98-%EC%A7%81%EC%A0%91-%EC%A0%91%EA%B7%BC-%EC%B0%A8%EB%8B%A8",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#6-private-ip로의-직접-접근-차단"
  },"711": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "7. ALB를 적절히 설정하면 서비스 배포를 더 좋게 할 수 있다",
    "content": "핵심 아이디어 . | ALB의 라우팅 기능을 활용하면 다양한 서비스를 효율적으로 배포 가능 | 하나의 로드밸런서로 여러 서비스를 관리할 수 있음 | . ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#7-alb%EB%A5%BC-%EC%A0%81%EC%A0%88%ED%9E%88-%EC%84%A4%EC%A0%95%ED%95%98%EB%A9%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B0%B0%ED%8F%AC%EB%A5%BC-%EB%8D%94-%EC%A2%8B%EA%B2%8C-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#7-alb를-적절히-설정하면-서비스-배포를-더-좋게-할-수-있다"
  },"712": {
    "doc": "AWS ALB (Application Load Balancer) 학습 정리",
    "title": "학습 요약",
    "content": "오늘 ALB에 대해 학습한 핵심 내용들: . | Health Check: 인스턴스 상태를 자동으로 모니터링 | Security Group: ALB 자체에 보안 그룹 적용 가능 | HTTP 전용: HTTP/HTTPS 트래픽만 처리하는 로드밸런서 | Target Group: 트래픽을 받을 대상들의 논리적 그룹 | X-Forwarded-For: 실제 클라이언트 IP를 확인하는 방법 | 보안 강화: Private IP 직접 접근 차단 | 고급 배포: ALB 설정으로 효율적인 서비스 배포 가능 | . ALB는 HTTP/HTTPS 애플리케이션의 로드밸런싱에 특화된 서비스로, 다양한 보안 기능과 라우팅 기능을 제공합니다. ",
    "url": "/docs/studies/aws_DA/aws_dva_section_elb/#%ED%95%99%EC%8A%B5-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/studies/aws_DA/aws_dva_section_elb/#학습-요약"
  },"713": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/"
  },"714": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "2023.09.11 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#20230911-mon",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#20230911-mon"
  },"715": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "서버리스란?",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%9E%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#서버리스란"
  },"716": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "패러다임의 전환",
    "content": ". | 물리적 머신 | Virtual machines (VM) . | ex) ec2 | 컴퓨터 및 장비 별로 버전 차이 등으로 종속성 문제가 발생하는 단점이 존재 | . | Containerization . | VM의 단점을 해소 | 필요에 따라 서버 증설 등의 여러가지 밑단의 내용들을 신경써야함 | . | Serverless . | AWS 차원에서 모든 리소스들을 추상화함. | 지속적인 스케일링 | 사용한 만큼만 과금 | 유지보수 ZERO | 때문에, 비즈니스 가치에 집중할 수 있다. | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84%EC%9D%98-%EC%A0%84%ED%99%98",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#패러다임의-전환"
  },"717": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "서버리스란?",
    "content": ". | 서버 관리 필요없음 | 사용한 만큼만 지불 | 요청에 맞게 스케일링 | 높은 보안 수준 | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%9E%80-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#서버리스란-1"
  },"718": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "다양한 범주의 서버리스 서비스",
    "content": ". 출처 : AWS . | 대표적으로 AWS Lambda | 네모 표시는 실습 때, 살펴볼 내용 | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B2%94%EC%A3%BC%EC%9D%98-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#다양한-범주의-서버리스-서비스"
  },"719": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda"
  },"720": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda",
    "content": ". | 불필요한 서버 관리 | 자동 확장 | 고가용성 및 보안 | 사용한 만큼만 지불 | . 출처 : AWS . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-1"
  },"721": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "AWS Lambda 사용 사례",
    "content": ". | Web Apps . | 정적 웹사이트 | 복합적 웹앱 | . | Backends . | 앱 &amp; 서비스 | 모바일 | IoT | . | Data Processing . | Real time | MaoReduce | Batch | . | Chatbots . | Powering chatbot loginc | . | etc | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#aws-lambda-사용-사례"
  },"722": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon API Gateway",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-api-gateway",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-api-gateway"
  },"723": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "API Gateway는 API 기반 아키텍처의 관문",
    "content": "API : 응용프로그램과 운영체제 간의 통신을 연결해주는 인터페이스 . API Gateway : 서비스가 많아지면, 버전 관리 및 관리가 매우 힘들어진다. 이를 해소시켜주는 것. (like 정문 역할) . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#api-gateway%EB%8A%94-api-%EA%B8%B0%EB%B0%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B4%80%EB%AC%B8",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#api-gateway는-api-기반-아키텍처의-관문"
  },"724": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon DynamoDB",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb"
  },"725": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Amazon DynamoDB",
    "content": "대규모 성능에 최적화된 완전 관리형 NoSQL 데이터베이스 서비스 . | 서버리스 . | 유지관리 불필요 | 오토 스케일링 | 고가용성 및 내결함성 | . | 높은 성능 . | 초당 수백만의 요청 처리 및 짧은 지연시간 | 다른 AWS 서비스와 통합 | . | 보안 및 엑세스 . | 전송 중 및 저장 시 암호화 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb-1",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#amazon-dynamodb-1"
  },"726": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "Core Concepts - Tables, Items, Attributes, Indexes",
    "content": ". 출처 : AWS . | Primary Key를 잘 설계하는 것이 중요. | Unique하게 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#core-concepts---tables-items-attributes-indexes",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#core-concepts---tables-items-attributes-indexes"
  },"727": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "데이터 베이스 확장",
    "content": ". | SQL . | 수직정 확장 | . | NoSQL . | 수평적 확장 : 다수의 샤드로 수평확장 | . | . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%99%95%EC%9E%A5",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#데이터-베이스-확장"
  },"728": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "실습",
    "content": " ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#실습"
  },"729": {
    "doc": "AWS 강의 - AWS 서버리스로 서버 없이 간단한 웹 애플리케이션 만들기",
    "title": "실습 과정",
    "content": ". | Lambda 생성 | DynamoDB, API Gateway 생성 | . https://catalog.us-east-1.prod.workshops.aws/workshops/600420b7-5c4c-498f-9b80-bc7798963ba3/ko-KR/serverless . ",
    "url": "/docs/studies/aws_DA/aws_lecture1/#%EC%8B%A4%EC%8A%B5-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/studies/aws_DA/aws_lecture1/#실습-과정"
  },"730": {
    "doc": "Backend",
    "title": "백엔드 개발자 학습 로드맵 📚",
    "content": ". ",
    "url": "/docs/studies/backend/backend/#%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%95%99%EC%8A%B5-%EB%A1%9C%EB%93%9C%EB%A7%B5-",
    
    "relUrl": "/docs/studies/backend/backend/#백엔드-개발자-학습-로드맵-"
  },"731": {
    "doc": "Backend",
    "title": "📖 개요",
    "content": "이 로드맵은 백엔드 개발자가 되기 위한 체계적인 학습 순서를 정리한 것입니다. 각 단계를 완성할 때 마다, 체크리스트를 채워가며 학습할 예정입니다. 항목에 대한 추가 글을 작성했다면, 항목에 링크를 걸어놓았습니다. 출처: roadmap.sh - Backend Developer Roadmap . ",
    "url": "/docs/studies/backend/backend/#-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/studies/backend/backend/#-개요"
  },"732": {
    "doc": "Backend",
    "title": "🌟 1단계: 기초 지식 (Foundation)",
    "content": "1.1 인터넷의 작동 원리 . | 인터넷의 작동원리 | 도메인 네임 시스템 (DNS)의 작동 원리 | 브라우저의 작동 원리 | HTTP/HTTPS 프로토콜 이해 | 호스팅의 개념과 종류 | . 1.2 버전 관리 시스템 . | Git 기초 명령어 학습 | GitHub 사용법 익히기 | GitLab, Bitbucket 등 다른 플랫폼 이해 | 브랜치 전략 및 협업 워크플로우 | . 1.3 관계형 데이터베이스 . | 관계형 데이터베이스란? | SQL 기초 | 데이터베이스 설계 | 트랜잭션과 ACID | 인덱스 | Migration | N+1 문제 | . 1.4 API에 대해 . ",
    "url": "/docs/studies/backend/backend/#-1%EB%8B%A8%EA%B3%84-%EA%B8%B0%EC%B4%88-%EC%A7%80%EC%8B%9D-foundation",
    
    "relUrl": "/docs/studies/backend/backend/#-1단계-기초-지식-foundation"
  },"733": {
    "doc": "Backend",
    "title": "🎯 학습 진행 상황",
    "content": "완료한 내용: . | ✅ 1.1 인터넷의 작동 원리 | ✅ 1.2 버전 관리 시스템 | ✅ 1.3 관계형 데이터베이스 | . 다음 학습 예정 내용은 학습 진행에 따라 추가될 예정입니다. ",
    "url": "/docs/studies/backend/backend/#-%ED%95%99%EC%8A%B5-%EC%A7%84%ED%96%89-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/studies/backend/backend/#-학습-진행-상황"
  },"734": {
    "doc": "Backend",
    "title": "Backend",
    "content": " ",
    "url": "/docs/studies/backend/backend/",
    
    "relUrl": "/docs/studies/backend/backend/"
  },"735": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "자료형",
    "content": ". | 우선순위 큐 | . PriorityQueue&lt;Integer&gt; pQ = new PriorityQueue&lt;&gt;(); // 삽입 (큐랑 동일) pQ.add(1); // front 확인 및 제거 pQ.remove(); . | 해시맵 | . HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 1); map.put(\"banana\", 2); // 키값 변경 map.put(\"banana\", 4); // 키가 있는지 확인, 키값 가져오기 (get) String key = \"apple\"; if (map.containsKey(key)) { int value = map.get(key); System.out.println(key + \": \" + value); // apple: 1 } // 키값 삭제 map.remove(\"banana\"); . | 스택 | . Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); . | 큐 | . Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); . | 연결리스트 | . LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // add list.addFirst(1); // 앞에 추가 list.addLast(2); // 뒤에 추가 list.add(3); list.add(1, 10); // index 1에 값 \"10\"추가 // remove list.removeFirst(); list.removeLast(); list.remove(); // 생략시 index 0 제거 list.remove(2); // index 2 제거 list.clear(); // 기타 list.get(1); list.size(); list.contain(1); // 1 검색, boolean list.indexOf(1); // index 1에 있는 값 불러오기, 없으면 -1 . | 해시셋 | . HashSet&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); // 용량이 10인 HashSet 생성 (해시셋은 저장공간을 늘릴 때, 2배로 늘리기 때문에 크기를 알고 있다면 정해주는 것이 Best) HashSet&lt;Integer&gt; set2 = new HashSet&lt;&gt;(10); set.add(1); set.add(1); set.add(2); set.remove(1); // 값 1 제거 set.clear(); if (set.contains(1)) { System.out.println(\"It has 1.\"); } . ",
    "url": "/docs/java/codingTestSyntax/#%EC%9E%90%EB%A3%8C%ED%98%95",
    
    "relUrl": "/docs/java/codingTestSyntax/#자료형"
  },"736": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "문자열",
    "content": ". | 정렬 | . // 기본 정렬 (오름차순) Arrays.sort(arr); // 내림차순 정렬 Arrays.sort(arr, Collections.reverseOrder()); . | StringBuffer | . String str = \"abc\"; StringBuffer sb = new StringBuffer(str); // \"abc\"로 초기화 // reverse (거꾸로, toString) String reversedStr = sb.reverse().toString; . | String to Int | . String str = \"123\"; int a = Integer.parseInt(str); . | int to String int a = 123; String str1 = Integer.toString(a); String str2 = a + \"\"; . | . ",
    "url": "/docs/java/codingTestSyntax/#%EB%AC%B8%EC%9E%90%EC%97%B4",
    
    "relUrl": "/docs/java/codingTestSyntax/#문자열"
  },"737": {
    "doc": "코딩테스트 - Java 문법 정리",
    "title": "코딩테스트 - Java 문법 정리",
    "content": " ",
    "url": "/docs/java/codingTestSyntax/",
    
    "relUrl": "/docs/java/codingTestSyntax/"
  },"738": {
    "doc": "CodingTest",
    "title": "코딩테스트",
    "content": " ",
    "url": "/docs/codingtest/codingtest/#%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/codingtest/codingtest/#코딩테스트"
  },"739": {
    "doc": "CodingTest",
    "title": "This Page has been written since August 08, 2023.",
    "content": " ",
    "url": "/docs/codingtest/codingtest/#this-page-has-been-written-since-august-08-2023",
    
    "relUrl": "/docs/codingtest/codingtest/#this-page-has-been-written-since-august-08-2023"
  },"740": {
    "doc": "CodingTest",
    "title": "CodingTest",
    "content": " ",
    "url": "/docs/codingtest/codingtest/",
    
    "relUrl": "/docs/codingtest/codingtest/"
  },"741": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "content": " ",
    "url": "/docs/projects/devzip/command-stack/",
    
    "relUrl": "/docs/projects/devzip/command-stack/"
  },"742": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "2025.01.05 (SUN)",
    "content": ". ",
    "url": "/docs/projects/devzip/command-stack/#20250105-sun",
    
    "relUrl": "/docs/projects/devzip/command-stack/#20250105-sun"
  },"743": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "릴리즈 노트",
    "content": "| 버전 | 날짜 | 변경 내용 | . | v1.0.7 | 2025.01.19 | 자동 업데이트 → 수동 다운로드 링크로 변경 | . | v1.0.6 | 2025.01.19 | 명령어 편집 기능 추가 (자동완성 지원) | . | v1.0.5 | 2025.01.19 | 명령어 삭제 기능 추가 (ConsoleInput 자동완성) | . | v1.0.3 | 2025.01.19 | 버전 동기화, Electron 서버 포트 8090으로 변경 | . | v1.0.2 | 2025.01.12 | Context 편집 기능 추가 (사이드바에서 인라인 편집) | . | v1.0.1 | 2025.01.05 | Windows 인스톨러 아이콘 256x256으로 재생성 | . 전체 릴리즈 보기 → 소개 사이트 → . ",
    "url": "/docs/projects/devzip/command-stack/#%EB%A6%B4%EB%A6%AC%EC%A6%88-%EB%85%B8%ED%8A%B8",
    
    "relUrl": "/docs/projects/devzip/command-stack/#릴리즈-노트"
  },"744": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "들어가며",
    "content": "개발자의 하루는 수많은 작업의 연속이다. 기능 구현, 버그 수정, 코드 리뷰, 문서 작성까지. 하지만 기존의 할 일 관리 앱들은 개발자의 사고방식과 맞지 않는 경우가 많다. 우리는 터미널에서 명령어를 실행하고, 프로세스 상태를 확인하며, 작업을 Context 단위로 전환하는 데 익숙하다. 그래서 Command Stack을 만들게 되었다. “Control your life’s runtime with a project-based, developer-centric scheduler”라는 슬로건처럼, 개발자에게 친숙한 OS와 터미널 메타포를 활용한 프로젝트 기반 스케줄러다. ",
    "url": "/docs/projects/devzip/command-stack/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0",
    
    "relUrl": "/docs/projects/devzip/command-stack/#들어가며"
  },"745": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "프로젝트 개요",
    "content": "Command Stack은 개발자의 사고방식을 그대로 반영한 개인 관리 시스템이다. 할 일을 ‘명령어(Command)’로, 프로젝트를 ‘Context’로 표현하며, Unix 스타일의 상태 시스템을 사용한다. 일반적인 투두 리스트가 아닌, 마치 작업 관리자(Task Manager)에서 프로세스를 관리하듯이 나의 작업들을 제어할 수 있다. 각 작업은 실행 중(EXECUTING), 성공(EXIT_SUCCESS), 중단(SIGKILL) 등의 상태를 가지며, Context별로 그룹화되어 관리된다. ",
    "url": "/docs/projects/devzip/command-stack/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/command-stack/#프로젝트-개요"
  },"746": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "주요 기능",
    "content": "터미널 중심 작업 관리 . Command Stack의 핵심은 개발자에게 친숙한 터미널 메타포다. 각 작업은 ‘명령어(Command)’로 표현되며, Unix 스타일의 상태 시스템을 사용한다. | EXECUTING: 현재 진행 중인 작업 | EXIT_SUCCESS: 성공적으로 완료된 작업 | SIGKILL: 중단되거나 취소된 작업 | . 이런 상태 표현은 개발자에게 직관적이며, 작업의 생명주기를 명확하게 파악할 수 있게 해준다. Console 명령어 인터페이스 . GUI 폼 대신 터미널처럼 명령어를 입력해서 작업을 관리할 수 있다. 브라우저의 개발자 도구 Console을 열고 명령어를 입력하면 즉시 일정이 추가되거나 수정된다. // 새로운 작업 추가 addCommand({ title: \"API 문서 작성\", context: \"backend-api\", deadline: \"2025-01-10\", type: \"documentation\" }); // 작업 상태 변경 updateCommand(\"cmd-123\", { status: \"EXIT_SUCCESS\" }); // Context별 작업 조회 listCommands(\"backend-api\"); // 오늘의 작업 목록 getTodayCommands(); . 마우스 클릭 없이 키보드만으로 빠르게 작업을 추가하고 관리할 수 있다. 반복적인 작업을 스크립트로 자동화하거나, 외부 도구와 연동하여 작업을 자동으로 생성하는 것도 가능하다. Context 기반 작업 분류 . 모든 Command는 Context로 그룹화된다. Context는 프로젝트, 업무 영역, 또는 관심사별로 작업을 묶는 단위다. 예를 들어: . | backend-api: 백엔드 API 개발 관련 작업 | devops: 배포 및 인프라 관련 작업 | personal: 개인 공부 및 사이드 프로젝트 | . Context 전환을 통해 현재 집중하고 있는 영역의 작업만 모아볼 수 있으며, 마치 터미널에서 디렉토리를 이동하듯 자연스럽게 작업 영역을 전환할 수 있다. 이중 스케줄 뷰 . Command Stack은 두 가지 방식으로 작업을 시각화한다. 캘린더 그리드 뷰는 마감일을 중심으로 작업을 배치한다. 각 날짜에 어떤 작업이 예정되어 있는지 한눈에 파악할 수 있으며, 데드라인이 다가오는 작업을 놓치지 않게 해준다. 타임라인 뷰는 주/월/년 단위로 작업의 흐름을 보여준다. 장기 프로젝트의 진행 상황을 파악하거나, 특정 기간 동안 완료한 작업을 확인할 때 유용하다. 간편한 Command 생성 . 새로운 작업을 추가하는 것은 폼 기반 인터페이스를 통해 간단하다. 작업 내용, 마감일, Context, 타입을 선택하면 즉시 Command Stack에 추가되며, 선택한 뷰에 자동으로 반영된다. ",
    "url": "/docs/projects/devzip/command-stack/#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/devzip/command-stack/#주요-기능"
  },"747": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "실전 활용 예시",
    "content": "프로젝트별 작업 관리 . 새로운 프로젝트를 시작할 때 먼저 Context를 생성한다. 예를 들어 e-commerce Context를 만들고, 다음과 같은 Command들을 추가할 수 있다: . | 상품 목록 API 구현 - EXECUTING | 결제 모듈 통합 - 마감일: 2025-01-15 | 배포 스크립트 작성 - 마감일: 2025-01-20 | . 각 작업의 상태를 업데이트하면서 프로젝트 진행 상황을 한눈에 파악할 수 있다. 일일 스프린트 계획 . 매일 아침 캘린더 뷰를 확인하여 오늘 해야 할 작업들을 점검한다. EXECUTING 상태인 작업들을 우선적으로 처리하고, 완료되면 EXIT_SUCCESS로 변경한다. 타임라인 뷰로 전환하여 이번 주에 완료해야 할 작업들을 확인하고, 우선순위를 조정할 수 있다. ",
    "url": "/docs/projects/devzip/command-stack/#%EC%8B%A4%EC%A0%84-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/projects/devzip/command-stack/#실전-활용-예시"
  },"748": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "기술 스택",
    "content": "Command Stack은 모던한 웹 기술 스택으로 구성되어 있다. Frontend . | React 18 with Vite - 빠른 개발 환경과 최적화된 빌드 | TypeScript - 타입 안정성과 개발 생산성 | Tailwind CSS - 유틸리티 우선 스타일링 | . Backend . | Spring Boot 3.x - 안정적인 Java 기반 서버 | Java 17+ - 최신 Java 기능 활용 | Gradle - 의존성 관리 및 빌드 자동화 | . 전체 코드베이스는 TypeScript가 71%로 가장 많은 비중을 차지하며, Java가 16.5%를 담당한다. ",
    "url": "/docs/projects/devzip/command-stack/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/command-stack/#기술-스택"
  },"749": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "시작하기",
    "content": "macOS 앱 빌드 . macOS에서 네이티브 앱으로 사용하려면 로컬에서 빌드해야 한다: ./build.sh . 빌드 스크립트가 자동으로 프론트엔드와 백엔드를 빌드하고, macOS 앱으로 패키징한다. 플랫폼별 설치 . GitHub Releases 페이지에서 플랫폼별 인스톨러를 다운로드할 수 있다: . | macOS: .dmg 파일 | Windows: .exe 파일 | Linux: .AppImage 또는 .deb 파일 | . 개발 환경 실행 . 소스 코드를 직접 실행하려면: . Backend 실행: . cd backend ./gradlew bootRun . Frontend 실행: . cd frontend npm install npm run dev . ",
    "url": "/docs/projects/devzip/command-stack/#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/projects/devzip/command-stack/#시작하기"
  },"750": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "마무리",
    "content": "Command Stack은 개발자의 사고방식을 그대로 반영한 작업 관리 도구다. 터미널에서 명령어를 실행하듯 작업을 관리하고, Context를 전환하며 집중력을 유지할 수 있다. Unix 스타일의 상태 시스템과 이중 스케줄 뷰를 통해 프로젝트 진행 상황을 명확하게 파악할 수 있으며, Console 명령어 인터페이스로 키보드만으로 빠르게 작업을 추가하고 관리할 수 있다. 앞으로 CLI 인터페이스 추가, 단축키 시스템 강화, Git 통합 등 개발자를 위한 더 많은 기능을 추가할 예정이다. ",
    "url": "/docs/projects/devzip/command-stack/#%EB%A7%88%EB%AC%B4%EB%A6%AC",
    
    "relUrl": "/docs/projects/devzip/command-stack/#마무리"
  },"751": {
    "doc": "Command Stack - 개발자를 위한 터미널 스타일 스케줄러",
    "title": "Links",
    "content": ". | Command Stack GitHub 저장소 | 데모 사이트 | . ",
    "url": "/docs/projects/devzip/command-stack/#links",
    
    "relUrl": "/docs/projects/devzip/command-stack/#links"
  },"752": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "Conflux - 개인화된 통합 알림 관제 센터",
    "content": " ",
    "url": "/docs/projects/devzip/conflux/",
    
    "relUrl": "/docs/projects/devzip/conflux/"
  },"753": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "2025.12.28 (SAT)",
    "content": ". ",
    "url": "/docs/projects/devzip/conflux/#20251228-sat",
    
    "relUrl": "/docs/projects/devzip/conflux/#20251228-sat"
  },"754": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "들어가며",
    "content": "개발하다 보면 하루에도 수십 번씩 여러 도구들의 알림을 확인하게 된다. GitHub의 PR 알림, Jira의 티켓 업데이트, Sentry의 에러 알림, Slack 메시지까지. 브라우저 탭을 하나씩 열어가며 확인하다 보면 집중력이 흐트러지고, 정작 중요한 알림을 놓치기도 한다. 이런 문제를 해결하기 위해 Conflux를 만들게 되었다. Conflux는 흩어진 개발 도구의 알림을 하나의 타임라인으로 통합하는 개인화된 관제 센터다. ",
    "url": "/docs/projects/devzip/conflux/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0",
    
    "relUrl": "/docs/projects/devzip/conflux/#들어가며"
  },"755": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "프로젝트 개요",
    "content": "Conflux는 “Where all streams merge”라는 슬로건처럼 여러 알림 스트림을 하나로 합치는 것을 목표로 한다. 단순한 알림함을 넘어서, Private 서버의 상태를 감시하고 배치 작업 결과를 수신하는 나만의 관제 탑 역할을 한다. 현재 Beta 버전으로 개발이 진행 중이며, 데스크톱 앱과 웹 버전 모두 지원한다. ",
    "url": "/docs/projects/devzip/conflux/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/conflux/#프로젝트-개요"
  },"756": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "주요 기능",
    "content": "통합 인박스 . 더 이상 브라우저 탭을 헤매지 않아도 된다. GitHub의 PR이나 Push 알림, Jira의 티켓 업데이트, Slack 메시지, Sentry의 에러 로그까지 모든 알림이 한곳에 모인다. 특히 Focus View 기능을 통해 ‘빌드 성공’ 같은 일상적인 소음은 필터링하고, 나에게 멘션된 메시지나 Critical Error 같은 중요한 알림만 모아볼 수 있다. 보안 능동 감시 . 내가 운영하는 API 서버가 정상적으로 동작하는지 Conflux가 대신 감시한다. 등록한 API 엔드포인트를 1분마다 체크하여 상태를 모니터링하며, 서버가 응답하지 않거나 5xx 에러를 반환하는 순간 즉시 데스크톱 알림을 보낸다. 단순한 URL 호출뿐만 아니라 Authorization Header나 API Token이 필요한 Private 서버도 안전하게 설정하여 감시할 수 있다. 예를 들어 내부 Admin API처럼 인증이 필요한 엔드포인트도 Bearer Token을 설정해두면 지속적으로 헬스 체크가 가능하다. 크로스 플랫폼 지원 . macOS와 Windows의 시스템 트레이에 상주하는 데스크톱 앱을 제공하며, 네이티브 알림으로 실시간 업데이트를 받을 수 있다. 만약 설치가 불가능한 환경이라면 브라우저만 있으면 웹 대시보드를 통해 동일한 기능을 사용할 수 있다. ",
    "url": "/docs/projects/devzip/conflux/#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/devzip/conflux/#주요-기능"
  },"757": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "실전 활용 예시",
    "content": "배치 작업 알림 . 파이썬 스크립트나 배치 작업이 끝났을 때 간단한 curl 명령으로 내 PC로 알림을 보낼 수 있다. curl -X POST http://localhost:8080/api/webhook/custom \\ -H \"Content-Type: application/json\" \\ -d '{ \"title\": \"데이터 백업 완료\", \"message\": \"총 50GB 백업 성공. 소요시간: 120s\", \"status\": \"success\" }' . 이렇게 하면 장시간 걸리는 작업을 실행해두고 다른 일을 하다가도, 작업이 완료되면 바로 알림을 받을 수 있다. Private API 감시 . 보안 토큰이 필요한 내부 서버를 감시하려면 설정 메뉴에서 다음과 같이 입력한다: . | Target URL: https://api.my-service.com/health | Method: GET | Headers: Authorization: Bearer my-secret-token | Interval: 60s | . 이렇게 설정해두면 1분마다 자동으로 Health Check를 수행하고, 문제가 발생하면 즉시 알려준다. ",
    "url": "/docs/projects/devzip/conflux/#%EC%8B%A4%EC%A0%84-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/projects/devzip/conflux/#실전-활용-예시"
  },"758": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "기술 스택",
    "content": "Conflux는 현대적이고 안정적인 기술 스택으로 구성되어 있다. | Backend: Spring Boot 3.4 | Frontend: React 18 | Desktop: Electron | Design: Linear-style Dark Mode UI | . Spring Boot로 안정적인 백엔드 API 서버를 구축하고, React로 반응형 UI를 만들었다. 그리고 Electron을 통해 데스크톱 앱으로 패키징하여 네이티브 알림 기능을 제공한다. ",
    "url": "/docs/projects/devzip/conflux/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/conflux/#기술-스택"
  },"759": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "시작하기",
    "content": "현재는 소스 코드를 통해 직접 실행할 수 있다. 먼저 백엔드를 실행한다: . cd conflux-backend ./gradlew bootRun . 그 다음 데스크톱 앱을 실행하거나: . cd conflux-client npm run electron . 웹 버전으로 실행할 수 있다: . cd conflux-client npm start . 로컬에서 외부 웹훅을 받으려면 ngrok을 사용하면 된다. ",
    "url": "/docs/projects/devzip/conflux/#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/projects/devzip/conflux/#시작하기"
  },"760": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "마무리",
    "content": "Conflux는 개발자의 집중력을 지키고 중요한 알림을 놓치지 않게 도와주는 개인 관제 센터다. 아직 Beta 버전이지만, 기본적인 통합 알림과 헬스 체크 기능은 모두 동작한다. 앞으로 더 많은 서비스 통합과 사용자 정의 필터링 규칙 등을 추가할 계획이다. ",
    "url": "/docs/projects/devzip/conflux/#%EB%A7%88%EB%AC%B4%EB%A6%AC",
    
    "relUrl": "/docs/projects/devzip/conflux/#마무리"
  },"761": {
    "doc": "Conflux - 개인화된 통합 알림 관제 센터",
    "title": "Links",
    "content": ". | Conflux GitHub 저장소 | 데모 사이트 | . ",
    "url": "/docs/projects/devzip/conflux/#links",
    
    "relUrl": "/docs/projects/devzip/conflux/#links"
  },"762": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/cpp/cpp/",
    
    "relUrl": "/docs/cpp/cpp/"
  },"763": {
    "doc": "C++",
    "title": "This Page has been written since December 12, 2024.",
    "content": " ",
    "url": "/docs/cpp/cpp/#this-page-has-been-written-since-december-12-2024",
    
    "relUrl": "/docs/cpp/cpp/#this-page-has-been-written-since-december-12-2024"
  },"764": {
    "doc": "db오류",
    "title": "오류",
    "content": "- [Server] Plugin mysql_native_password reported: ''mysql_native_password' is deprecated and will be removed in a future release. Please use caching_sha2_password instead'` . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%EC%98%A4%EB%A5%98",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#오류"
  },"765": {
    "doc": "db오류",
    "title": "원인 #1",
    "content": "원인은 MySQL 8.0이상 부터의 보안 정책과 관련되었다. SSL/TLS . SSL/TLS은 클라이언트와 서버 프로그램이 네트워크로 통신하는 과정에서 도청 및 간섭, 위변조 방지를 위해서 서로 신뢰할 수 있는 전자 서명이 포함된 인증서를 사용하는 암호화 통신 프로토콜 . [!info] Content . | 이 내용은 클라이언트(애플리케이션이나 PC 등)에서 MySQL을 SSL/TLS 방식으로 접속시에 TLS1.0 또는 1.1 버전으로 접속한다면 다음과 같은 에러가 발생되면서 접속이 불가능함을 의미 | . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%EC%9B%90%EC%9D%B8-1",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#원인-1"
  },"766": {
    "doc": "db오류",
    "title": "해결",
    "content": ". | 이와 다른 부분이였다. 다음날 다시 접속하니 해결,,? 되었다.. | . ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/#해결"
  },"767": {
    "doc": "db오류",
    "title": "db오류",
    "content": "[!question] 갑자기 잘되던 AWS RDS로의 접속이 안된다. ",
    "url": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/",
    
    "relUrl": "/docs/java/SpringBoot/db%EC%98%A4%EB%A5%98/"
  },"768": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "Project - DevZip",
    "content": " ",
    "url": "/docs/projects/devzip/devzip/#project---devzip",
    
    "relUrl": "/docs/projects/devzip/devzip/#project---devzip"
  },"769": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "Project has been written since July 3, 2024.",
    "content": ". DevZip은 제가 개발한 프로젝트들의 모음Zip입니다! . ",
    "url": "/docs/projects/devzip/devzip/#project-has-been-written-since-july-3-2024",
    
    "relUrl": "/docs/projects/devzip/devzip/#project-has-been-written-since-july-3-2024"
  },"770": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "프로젝트 개요",
    "content": "DevZip은 다양한 실험적 아이디어와 실서비스 프로젝트를 한곳에 모아놓은 플랫폼입니다. 방명록, 농담 API, 물리 퀴즈 등 재미있는 실험 프로젝트부터 트레이스보드, 트렌드챗 같은 실용적인 서비스까지, 생각한 아이디어를 직접 구현하고 선보이는 공간입니다. 주요 기능 바로가기: . | 방명록 | 농담 | API 문서 | 대시보드 (관리자) | 트레이스보드 (관리자) | 트렌드챗 | 물리 퀴즈 | . DevZip 로그 대시보드 화면 . ",
    "url": "/docs/projects/devzip/devzip/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/devzip/#프로젝트-개요"
  },"771": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "주요 기능",
    "content": "1. 트레이스보드 . 웹사이트 분석을 위한 경량화된 솔루션으로, 구글 애널리틱스보다 가볍고 개발자 친화적인 인터페이스를 제공합니다. | 방문자 지표: 고유 방문자 수, 페이지뷰, 세션 지속 시간, 이탈률 등 | 사용자 행동 차트: 이벤트 유형별, 디바이스별 사용 분포 시각화 | 실시간 이벤트 로그: 사용자 활동을 시간순으로 확인 | . 실시간 이벤트 로그 화면 . 2. TrendChat . | Python 스크립트를 이용한 트렌드 데이터 자동 수집 | 수집된 트렌드 정보를 REST API로 제공 | 개발자들이 관심 있는 주제와 기술 트렌드를 한눈에 파악 | . 3. API 목록 페이지 . | DevZip에서 제공하는 모든 API 엔드포인트를 카테고리별로 정리 | 반응형 디자인과 웹 접근성을 고려한 사용자 친화적 인터페이스 | 직관적인 HTTP 메서드 구분으로 빠른 API 이해 가능 | . DevZip API 목록 페이지 . ",
    "url": "/docs/projects/devzip/devzip/#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/devzip/devzip/#주요-기능"
  },"772": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "개발 타임라인",
    "content": "| 시기 | 주요 내용 | . | 2024년 7월 초 | 프로젝트 시작, AWS 환경 구축(EC2, RDS), 도메인 구매(devzip.site), SpringBoot + React 개발환경 설정 | . | 2024년 7월 중순 | 메인 페이지 레이아웃 디자인, 게스트북 기능 구현, 데이터베이스 연동 | . | 2024년 12월 | 대시보드 기본 UI 구현 및 1차 개발 완료 | . | 2025년 2월 | TrendChat 개발: Python 스크립트 자동화로 트렌드 데이터 수집, JSON 파일 저장 시스템 구현 | . | 2025년 4월 | 트레이스보드 개발: 방문자 지표, 사용자 행동 차트, 실시간 이벤트 로그 기능 구현 | . | 2025년 7월 | API 목록 페이지 개발: 반응형 디자인과 접근성 개선 | . ",
    "url": "/docs/projects/devzip/devzip/#%EA%B0%9C%EB%B0%9C-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8",
    
    "relUrl": "/docs/projects/devzip/devzip/#개발-타임라인"
  },"773": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "기술 스택",
    "content": ". | 프론트엔드: React, Next.js, CSS | 백엔드: SpringBoot, Node.js, Express | 데이터베이스: MySQL(RDS) | 인프라: AWS EC2, AWS RDS, GitHub Actions | 기타 도구: Python, pm2 | . ",
    "url": "/docs/projects/devzip/devzip/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/devzip/#기술-스택"
  },"774": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "주요 도전 과제와 해결책",
    "content": ". | IP 주소 수집 이슈 - AWS 로드 밸런서 설정 조정으로 X-Forwarded-For 헤더를 활용해 해결 | 데이터 수집 자동화 - GitHub Actions와 pm2를 활용한 Python 스크립트 자동화로 해결 | 배포 프로세스 안정성 - 단일 작업에서 4단계 파이프라인으로 개선하여 에러 추적 용이 | 사용자 행동 추적 개인정보 보호 - IP 주소 마스킹 처리 등 개인정보 보호 방안 구현 | . ",
    "url": "/docs/projects/devzip/devzip/#%EC%A3%BC%EC%9A%94-%EB%8F%84%EC%A0%84-%EA%B3%BC%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0%EC%B1%85",
    
    "relUrl": "/docs/projects/devzip/devzip/#주요-도전-과제와-해결책"
  },"775": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "Links",
    "content": ". | DevZip 사이트 방문 . | GitHub 저장소 . | . ",
    "url": "/docs/projects/devzip/devzip/#links",
    
    "relUrl": "/docs/projects/devzip/devzip/#links"
  },"776": {
    "doc": "사이드 프로젝트 - DevZip",
    "title": "사이드 프로젝트 - DevZip",
    "content": " ",
    "url": "/docs/projects/devzip/devzip/",
    
    "relUrl": "/docs/projects/devzip/devzip/"
  },"777": {
    "doc": "entityManagerFactory 에러",
    "title": "entityManagerFactory 에러",
    "content": "[!question] 스프링부트 프로젝트에서 게시판을 만들고 있던 중, 게시판 작성 내용을 DB에 저장하는 컨트롤러를 만들던 중 오류가 발생하였다. 오류 . ```bash ********* APPLICATION FAILED TO START ************* . Description: . Parameter 0 of constructor in Service required a bean named ‘entityManagerFactory’ that could not be found. Action: . Consider defining a bean named ‘entityManagerFactory’ in your configuration.&gt;) . ### 초기 해결 방법 `EntityManagerFactory`를 수동으로 설정하는 방법을 채택 ```java @Configuration @EnableTransactionManagement public class JpaConfig { @Autowired private DataSource dataSource; @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() { LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean(); factory.setDataSource(dataSource); factory.setPackagesToScan(\"entity\"); factory.setJpaVendorAdapter(new HibernateJpaVendorAdapter()); return factory; } @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(entityManagerFactory); return transactionManager; } } . | 는 다른 곳이였다… (아래는 해결) | . # JPA 비활성화를 주석처리 ... # spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration . ",
    "url": "/docs/java/SpringBoot/entityManagerFactory_%EC%97%90%EB%9F%AC/",
    
    "relUrl": "/docs/java/SpringBoot/entityManagerFactory_%EC%97%90%EB%9F%AC/"
  },"778": {
    "doc": "Facade 패턴",
    "title": "Facade 패턴",
    "content": "[!NOTE] Facade 패턴 == 드라이브 스루 창구 . | Facade 패턴은 드라이브 스루 창구 처럼 이용자가 제품 제작과 포장 등 여러 기능들을 볼 수 없듯이, 여러 기능을 하나의 창구를 통해 간단하게 사용할 수 있도록 하는 패턴 | . ",
    "url": "/docs/java/facadePattern/",
    
    "relUrl": "/docs/java/facadePattern/"
  },"779": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "Project - 토이 프로젝트 - 게임 서버",
    "content": " ",
    "url": "/docs/projects/gameServer/gameServer/#project---%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8---%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/projects/gameServer/gameServer/#project---토이-프로젝트---게임-서버"
  },"780": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "Project has been written since Aug 19, 2023.",
    "content": ". ",
    "url": "/docs/projects/gameServer/gameServer/#project-has-been-written-since-aug-19-2023",
    
    "relUrl": "/docs/projects/gameServer/gameServer/#project-has-been-written-since-aug-19-2023"
  },"781": {
    "doc": "토이 프로젝트 - 게임 서버",
    "title": "토이 프로젝트 - 게임 서버",
    "content": " ",
    "url": "/docs/projects/gameServer/gameServer/",
    
    "relUrl": "/docs/projects/gameServer/gameServer/"
  },"782": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "GameAdvisor: 당신의 게임 플레이를 돕는 AI 조언자!",
    "content": "안녕하세요! 오늘은 새롭게 시작하는 사이드 프로젝트, GameAdvisor를 소개하고자 합니다. GameAdvisor는 복잡한 게임 상황에 어려움을 겪는 신규 플레이어나 숙련도를 높이고 싶은 게이머들을 위한 실시간 플레이 가이드 데스크톱 애플리케이션입니다. ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#gameadvisor-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EA%B2%8C%EC%9E%84-%ED%94%8C%EB%A0%88%EC%9D%B4%EB%A5%BC-%EB%8F%95%EB%8A%94-ai-%EC%A1%B0%EC%96%B8%EC%9E%90",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#gameadvisor-당신의-게임-플레이를-돕는-ai-조언자"
  },"783": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "🚀 프로젝트 목표",
    "content": "GameAdvisor의 핵심 목표는 게임 화면을 분석하여 현재 상황을 설명해주고, 최적의 플레이 방법에 대한 조언을 제공하는 것입니다. 이를 통해 신규 플레이어들이 게임에 더 쉽게 적응하고, 기존 플레이어들은 한 단계 더 성장할 수 있도록 돕는 똑똑한 게임 비서가 되고자 합니다. ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#-프로젝트-목표"
  },"784": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "🏛️ 아키텍처",
    "content": "GameAdvisor는 클라이언트-서버 아키텍처를 기반으로 설계되었습니다. 🌐 백엔드 . | Spring Boot를 기반으로 하는 강력하고 확장 가능한 서버입니다. | 게임 상황 데이터를 분석하고, 플레이어에게 제공할 조언을 생성하는 RESTful API를 제공하는 것을 목표로 합니다. | 향후 정교한 상황 분석 알고리즘을 탑재하여 사용자에게 실시간 맞춤 가이드를 제공하는 핵심 두뇌 역할을 담당하게 됩니다. | . 💻 클라이언트 . | JavaFX를 사용하여 풍부하고 직관적인 사용자 경험을 제공하는 데스크톱 애플리케이션입니다. | 사용자는 클라이언트를 통해 실시간으로 게임 상황에 대한 설명과 추천 플레이를 제공받을 수 있습니다. | 깔끔하고 현대적인 UI를 통해 누구나 쉽게 사용할 수 있도록 설계될 예정입니다. | . ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#%EF%B8%8F-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#️-아키텍처"
  },"785": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "💡 현재 진행 상황",
    "content": "현재 GameAdvisor 프로젝트는 초기 설정 단계에 있습니다. | 백엔드: Spring Boot 애플리케이션의 기본 구조가 준비되어 서버가 실행될 수 있는 환경이 구축되었습니다. | 클라이언트: JavaFX 애플리케이션이 성공적으로 실행되어 기본 화면을 띄우는 것까지 확인되었습니다. | . 이제 막 첫걸음을 뗀 단계이지만, 견고한 아키텍처 위에서 빠르게 기능을 확장해나갈 준비가 되었습니다. ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#-%ED%98%84%EC%9E%AC-%EC%A7%84%ED%96%89-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#-현재-진행-상황"
  },"786": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "🛠️ 기술 스택",
    "content": ". | Backend: Java, Spring Boot, Gradle | Client: Java, JavaFX, Gradle | Database: PostgreSQL (예정) | API: REST API | . ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#%EF%B8%8F-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#️-기술-스택"
  },"787": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "🗺️ 향후 개발 계획",
    "content": "앞으로 다음과 같은 기능들을 순차적으로 개발해나갈 예정입니다. | 데이터베이스 모델링 및 구축: 게임, 게임 내 이벤트, 상황별 데이터, 추천 가이드 등을 저장할 스키마를 설계하고 데이터베이스를 구축합니다. | 핵심 API 개발: 게임 화면 분석 요청 및 분석 결과(가이드) 전송을 위한 API를 개발합니다. | 클라이언트 UI/UX 고도화: 분석된 게임 상황과 추천 가이드를 효과적으로 보여줄 수 있는 UI를 구현합니다. | 백엔드-클라이언트 연동: 클라이언트에서 분석이 필요한 데이터를 백엔드 API로 전송하고, 수신된 가이드를 화면에 표시합니다. | 상황 분석 알고리즘 구현: 이미지 처리 또는 게임 로그 분석을 통해 현재 게임 상황을 판단하고, 그에 맞는 플레이 가이드를 생성하는 초기 버전의 알고리즘을 개발합니다. | . ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#%EF%B8%8F-%ED%96%A5%ED%9B%84-%EA%B0%9C%EB%B0%9C-%EA%B3%84%ED%9A%8D",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#️-향후-개발-계획"
  },"788": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "맺음말",
    "content": "프로젝트 진행 상황은 블로그를 통해 꾸준히 공유하겠습니다. 감사합니다! . ",
    "url": "/docs/projects/gameadvisor/gameadvisor/#%EB%A7%BA%EC%9D%8C%EB%A7%90",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/#맺음말"
  },"789": {
    "doc": "GameAdvisor - 게임 플레이 비서",
    "title": "GameAdvisor - 게임 플레이 비서",
    "content": " ",
    "url": "/docs/projects/gameadvisor/gameadvisor/",
    
    "relUrl": "/docs/projects/gameadvisor/gameadvisor/"
  },"790": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "🚀 GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "content": "이번 글에서는 GitHub Actions를 사용하여 배포 과정을 네 단계로 나누어 관리하는 방법을 리뷰합니다. ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-github-actions%EB%A1%9C-4%EB%8B%A8%EA%B3%84-%EB%B0%B0%ED%8F%AC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-github-actions로-4단계-배포-파이프라인-구성하기"
  },"791": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "✅ 목표",
    "content": "기존에는 배포 프로세스가 하나의 Job으로 구성되어 에러 발생 시 원인 파악이 어려웠습니다. 👉 이를 해결하기 위해 4단계로 분리하여 배포 파이프라인을 구축했습니다. ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-목표"
  },"792": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "🛠️ 배포 파이프라인 구조",
    "content": "전체 배포 과정은 아래처럼 4단계(Job)로 나누어 구성했습니다. | 📝 Checkout Code . | 코드 레포지토리에서 소스 코드 가져오기 | . | 🛑 Stop Existing Services . | 기존 실행 중인 서버 및 프로세스 중지 | . | 🏗️ Clean &amp; Build Project . | 빌드 폴더 정리 및 프로젝트 빌드 수행 | . | 🚀 Deploy &amp; Restart Services . | 빌드된 코드 배포 및 PM2 서비스 재시작 | . | . ",
    "url": "/docs/projects/devzip/githubActions-jobs/#%EF%B8%8F-%EB%B0%B0%ED%8F%AC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#️-배포-파이프라인-구조"
  },"793": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "🎯 배포 과정 플로우",
    "content": "📝 Checkout Code ──▶ 🛑 Stop Existing Services ──▶ 🏗️ Clean &amp; Build Project ──▶ 🚀 Deploy &amp; Restart Services . | Job별로 실행 로그가 분리되어 문제 추적이 용이합니다. | 이전 단계가 실패하면 다음 단계가 자동으로 중단되어 안정성이 높아집니다. | . ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-%EB%B0%B0%ED%8F%AC-%EA%B3%BC%EC%A0%95-%ED%94%8C%EB%A1%9C%EC%9A%B0",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-배포-과정-플로우"
  },"794": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "📝 간단한 예시 코드 (YAML)",
    "content": "name: Deploy Pipeline on: push: branches: [ master ] jobs: checkout: name: 📝 Checkout Code runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 stop_services: name: 🛑 Stop Existing Services runs-on: ubuntu-latest needs: checkout steps: - name: Stop services on server uses: appleboy/ssh-action@v0.1.6 with: host: $ username: $ key: $ script: | pm2 stop all pm2 delete all ./gradlew --stop build: name: 🏗️ Clean &amp; Build Project runs-on: ubuntu-latest needs: stop_services steps: - name: Build project uses: appleboy/ssh-action@v0.1.6 with: host: $ username: $ key: $ script: | git pull origin master ./gradlew clean build deploy: name: 🚀 Deploy &amp; Restart Services runs-on: ubuntu-latest needs: build steps: - name: Deploy and restart services uses: appleboy/ssh-action@v0.1.6 with: host: $ username: $ key: $ script: | pm2 start server.json . ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%8B%9C-%EC%BD%94%EB%93%9C-yaml",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-간단한-예시-코드-yaml"
  },"795": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "✅ 변경 전과 후 비교",
    "content": "| 구분 | 변경 전 | 변경 후 | . | 구조 | 단일 Job | 4단계 Job 분리 | . | 에러 추적 | 어려움 | 쉬움 (어느 단계에서 실패했는지 바로 확인) | . | 유지보수성 | 낮음 | 높음 (단계별 수정 및 테스트 용이) | . | 안정성 | 낮음 (모든 과정 일괄 실행) | 높음 (각 단계 완료 후 다음 단계 실행) | . ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-%EB%B3%80%EA%B2%BD-%EC%A0%84%EA%B3%BC-%ED%9B%84-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-변경-전과-후-비교"
  },"796": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "🚀 마무리",
    "content": "🔑 배포 과정을 단계별로 나누니: ✅ 디버깅이 쉬워지고 ✅ 안정적인 배포 환경을 구축할 수 있었습니다. 배포 자동화를 개선하고 싶다면 Job 분리를 적극 추천!!! . ",
    "url": "/docs/projects/devzip/githubActions-jobs/#-%EB%A7%88%EB%AC%B4%EB%A6%AC",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/#-마무리"
  },"797": {
    "doc": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "title": "GitHub Actions로 4단계 배포 파이프라인 구성하기",
    "content": " ",
    "url": "/docs/projects/devzip/githubActions-jobs/",
    
    "relUrl": "/docs/projects/devzip/githubActions-jobs/"
  },"798": {
    "doc": "Hoooon22's Portfolio",
    "title": "안녕하세요,김지훈입니다.",
    "content": "\"문제를 발견하고, 해결하고, 서비스로 만드는\" 개발자입니다. 사용자가 겪는 불편함을 기술로 해결하는 것에 가치를 두고, 직접 기획부터 배포까지 경험하며 성장하고 있습니다. 🔧 풀스택 경험 ☁️ AWS 인프라 🚀 사이드 프로젝트 연락하기 GitHub DevZip ",
    "url": "/",
    
    "relUrl": "/"
  },"799": {
    "doc": "Hoooon22's Portfolio",
    "title": "핵심 역량",
    "content": "🏗️ 풀스택 개발 경험 . 프론트엔드(React, Next.js)부터 백엔드(Spring Boot, Node.js), 데이터베이스(MySQL)까지 전 영역을 경험했습니다. 서비스 전체를 이해하고 협업할 수 있습니다. ☁️ AWS 클라우드 인프라 . EC2, RDS, S3, Route53 등을 활용해 직접 서비스를 배포하고 운영했습니다. 비용 최적화와 서버 관리 경험을 보유하고 있습니다. 🎯 문제 해결 중심 개발 . 실제 사용자의 불편함을 발견하고 해결하는 것을 좋아합니다. DevZip, 퐁당 등 직접 기획하고 운영하는 서비스를 통해 이를 실천하고 있습니다. ",
    "url": "/",
    
    "relUrl": "/"
  },"800": {
    "doc": "Hoooon22's Portfolio",
    "title": "대표 프로젝트",
    "content": "운영 중 DevZip - 개발 프로젝트 플랫폼 . 2024.01 ~ 현재 (개인 프로젝트) . 다양한 실험적 아이디어와 실서비스를 한곳에 모아놓은 개인 개발 플랫폼입니다. 실시간 채팅, 방명록, 트렌드 분석 등 다양한 기능을 직접 구현하고 운영하고 있습니다. 이 프로젝트를 통해 ... 기획 → 개발 → 배포 → 운영까지 전 과정을 혼자 수행하며, 실제 서비스를 만들고 유지하는 역량을 갖추었습니다. 운영 중인 서비스 . | Command Stack 터미널 스타일의 개발자용 스케줄러 - 할 일을 명령어처럼 관리 . Conflux 통합 알림 관제 센터 - 흩어진 개발 도구 알림을 하나로 . Next.js React Node.js MySQL AWS | 사이트 방문 GitHub 상세 보기 서비스 종료 퐁당 매거진 - 청소년 진로 웹매거진 . 2022.06 ~ 2023.06 (팀 프로젝트) . 청소년에게 다양한 직업을 소개하는 웹매거진 서비스의 풀스택 개발을 담당했습니다. 실제 사용자를 대상으로 서비스를 운영하며 피드백을 반영하는 경험을 했습니다. 이 프로젝트를 통해 ... 비개발자 팀원과 협업하며 요구사항 분석 → 설계 → 구현 과정을 경험했고, 실서비스 배포와 운영을 통해 책임감 있는 개발을 배웠습니다. Spring Boot React Node.js MySQL AWS GitHub 상세 보기 ",
    "url": "/",
    
    "relUrl": "/"
  },"801": {
    "doc": "Hoooon22's Portfolio",
    "title": "그 외 프로젝트",
    "content": "GameAdvisor . 2025 (개발중) 게임 화면을 실시간 분석하여 최적의 전략을 제안하는 데스크톱 애플리케이션 . Spring Boot JavaFX OpenCV 상세 보기 GitHub 어린이집 CCTV 영상처리 . 2022 아동학대 방지를 위한 CCTV 영상 분석 및 효율적 반출 시스템 (졸업 프로젝트) . Python OpenCV React GitHub VR 화학실험실 . 2022 안전사고 예방과 과학 교육을 위한 VR 가상 실험실 환경 . Unity C# Blender GitHub GitHub Summary Extension . 2024 OpenAI API를 활용해 GitHub 레포지토리를 자동 요약하는 Chrome Extension . JavaScript OpenAI API ",
    "url": "/",
    
    "relUrl": "/"
  },"802": {
    "doc": "Hoooon22's Portfolio",
    "title": "기술 스택",
    "content": "💻 Backend . Java Spring Boot Node.js 🎨 Frontend . React Next.js JavaScript 🗃️ Database . MySQL ☁️ Infra . AWS Linux Git ",
    "url": "/",
    
    "relUrl": "/"
  },"803": {
    "doc": "Hoooon22's Portfolio",
    "title": "학력 및 경험",
    "content": "🎓 동국대학교 컴퓨터공학과 . 2018.03 ~ 2023.02 졸업 전공 교과목을 통해 자료구조, 알고리즘, 운영체제, 데이터베이스 등 CS 기초를 탄탄히 다졌습니다. 🔬 인간-로봇 상호작용 연구실 . 2019.07 ~ 2021.04 학부연구생 시각/청각 장애인을 위한 접근성 연구에 참여하며, 사회적 가치를 담은 기술 개발을 경험했습니다. ",
    "url": "/",
    
    "relUrl": "/"
  },"804": {
    "doc": "Hoooon22's Portfolio",
    "title": "문제의 본질을 파악하고 해결하는 개발자",
    "content": "언제든 편하게 연락 주세요! . momo990305@gmail.com GitHub ",
    "url": "/",
    
    "relUrl": "/"
  },"805": {
    "doc": "Hoooon22's Portfolio",
    "title": "Hoooon22's Portfolio",
    "content": "Backend Developer . ",
    "url": "/",
    
    "relUrl": "/"
  },"806": {
    "doc": "★ Java",
    "title": "Java",
    "content": " ",
    "url": "/docs/java/java/#java",
    
    "relUrl": "/docs/java/java/#java"
  },"807": {
    "doc": "★ Java",
    "title": "This Page has been written since July 22, 2024.",
    "content": " ",
    "url": "/docs/java/java/#this-page-has-been-written-since-july-22-2024",
    
    "relUrl": "/docs/java/java/#this-page-has-been-written-since-july-22-2024"
  },"808": {
    "doc": "★ Java",
    "title": "★ Java",
    "content": " ",
    "url": "/docs/java/java/",
    
    "relUrl": "/docs/java/java/"
  },"809": {
    "doc": "Live Chat 프로젝트 개발일지",
    "title": "📝 Live Chat 프로젝트 개발일지",
    "content": "1. 들어가며: 왜 실시간 채팅 프로젝트인가? . 현대 웹 애플리케이션에서 실시간 상호작용은 사용자 경험을 극대화하는 핵심 요소입니다. 다양한 서비스에 손쉽게 통합할 수 있는 독립적인 실시간 채팅 기능을 구현하여, 서비스 운영자와 사용자, 또는 사용자 간의 원활한 소통 채널을 제공하는 것을 목표로 Live Chat 프로젝트를 시작했습니다. 이 프로젝트를 통해 어떤 웹 서비스든 쉽게 가져다 쓸 수 있는 범용성 높은 채팅 모듈 개발을 목표로 합니다. 최종 구현 화면 . 2. 기술 스택 선택: WebSocket과 STOMP . 실시간 양방향 통신을 위해 WebSocket을 기술 기반으로 선택했습니다. 하지만 순수 WebSocket API(Plain WebSocket)는 메시지 형식이나 통신 흐름을 직접 모두 구현해야 하는 부담이 있었습니다. 고민의 지점: . | 구현의 복잡성: 누가 메시지를 보내고, 누가 받는지, 어떤 종류의 메시지인지 등을 모두 직접 파싱하고 관리해야 했습니다. | 통신 프로토콜의 부재: 일관성 있는 메시지 포맷을 유지하기 위한 별도의 프로토콜 설계가 필요했습니다. | . 해결책: . 이러한 복잡성을 줄이고 개발 생산성을 높이기 위해, WebSocket 위에서 동작하는 상위 프로토콜인 STOMP(Simple Text Oriented Messaging Protocol)를 도입하기로 결정했습니다. Spring에서는 @EnableWebSocketMessageBroker 어노테이션 하나로 STOMP 기반의 메시지 브로커 기능을 손쉽게 활성화할 수 있었습니다. WebSocketConfig.java의 핵심 설정은 다음과 같습니다. @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) { // 1. 구독(Subscribe) 경로 설정 registry.enableSimpleBroker(\"/topic\"); // 2. 발행(Publish) 경로 설정 registry.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { // 3. 웹소켓 연결 Endpoint 설정 registry.addEndpoint(\"/ws-livechat\").setAllowedOriginPatterns(\"*\").withSockJS(); } } . 고민과 결정의 결과: . | /topic (구독): 클라이언트가 메시지를 수신할 채널의 prefix입니다. 특정 채팅방의 주제(topic)를 구독하면, 해당 방의 메시지를 받을 수 있습니다. | /app (발행): 클라이언트가 서버로 메시지를 보낼 때 사용하는 prefix입니다. 이 경로로 들어온 메시지는 @MessageMapping 어노테이션이 붙은 컨트롤러 메서드로 라우팅됩니다. | /ws-livechat (연결): 최초 웹소켓 연결을 위한 Endpoint입니다. withSockJS()를 추가하여 WebSocket을 지원하지 않는 브라우저에서도 유사한 경험을 제공할 수 있도록 호환성을 높였습니다. | . 이처럼 STOMP를 도입함으로써, ‘발행/구독(Pub/Sub)’ 모델을 직관적으로 사용할 수 있게 되어 채팅방별 메시지 분리, 메시지 브로드캐스팅 등의 로직을 매우 간단하게 구현할 수 있었습니다. 3. 메시지 처리 흐름 설계 . STOMP로 통신 기반을 다진 후, 클라이언트가 보낸 메시지를 서버에서 어떻게 처리하고 다시 클라이언트로 전달할지 구체적인 흐름을 설계했습니다. LiveChatMessageController.java 와 LiveChatMessageRequest.java DTO는 이러한 고민의 결과물입니다. 고민의 지점: . | 메시지 라우팅: /app/livechat/message 경로로 들어온 메시지를 어떻게 특정 채팅방 구독자들에게만 전달할 것인가? | 데이터 처리: 클라이언트가 보낸 원본 데이터를 그대로 사용할 것인가, 아니면 서버에서 필요한 형태로 가공할 것인가? | 메시지 영속성: 실시간으로 주고받는 메시지를 데이터베이스에 저장해야 하는가? | . 설계 및 구현: . // LiveChatMessageController.java @MessageMapping(\"/livechat/message\") public void message(LiveChatMessageRequest messageRequest) { // 1. 채팅방 존재 여부 확인 LiveChatRoom room = liveChatRoomRepository.findById(messageRequest.getRoomId()) .orElseThrow(() -&gt; new RuntimeException(\"Chat room not found\")); // 2. DTO를 Entity로 변환 및 저장 LiveChatMessage chatMessage = new LiveChatMessage(); chatMessage.setLiveChatRoom(room); chatMessage.setSenderName(messageRequest.getSenderName()); chatMessage.setMessage(messageRequest.getMessage()); LiveChatMessage savedMessage = liveChatMessageRepository.save(chatMessage); // 3. 해당 채팅방 구독자들에게 메시지 브로드캐스팅 messagingTemplate.convertAndSend(\"/topic/room/\" + messageRequest.getRoomId(), savedMessage); } . | DTO 도입: LiveChatMessageRequest 라는 DTO를 만들어 클라이언트와 서버 간의 데이터 규격을 명확히 했습니다. 이를 통해 API 스펙과 데이터베이스 모델(Entity)을 분리하여 유연성을 확보했습니다. | 메시지 저장: 컨트롤러 내부에 // For simplicity, we're not creating a full service layer for this part yet. 라는 주석을 남긴 것을 발견했습니다. 이는 MVP(Minimum Viable Product) 개발 방식으로, 우선 핵심 기능을 컨트롤러에 빠르게 구현하고 추후 서비스 레이어로 분리하여 리팩토링하겠다는 의사결정의 흔적입니다. 이런 접근은 초기 개발 속도를 높이는 데 큰 도움이 됩니다. | 브로드캐스팅: SimpMessageSendingOperations를 사용하여 /topic/room/{roomId} 경로를 구독하고 있는 모든 클라이언트에게 메시지를 전송합니다. STOMP 덕분에 이 과정이 매우 간단해졌습니다. | . 4. 인증 및 안정성 강화 . 초기 구현 이후, 인증(Authentication) 문제를 해결하고 안정성을 높이는 과정을 진행했습니다. | Principal 객체 null 처리: 웹소켓 연결 시, 인증된 사용자의 정보를 가져오는 Principal 객체가 null이 되는 문제를 해결했습니다. 이는 웹소켓 연결 컨텍스트에 Spring Security의 인증 정보가 제대로 전달되지 않았을 때 발생하는 문제로, JWT 토큰을 웹소켓 핸드셰이크 과정에서 검증하는 로직을 추가하여 해결했을 것으로 추측됩니다. | 비로그인 사용자 접근 제어: 로그인하지 않은 사용자가 채팅방에 접근하려고 할 때, 알림을 표시하고 입장을 막는 기능을 추가하여 서비스 안정성을 높였습니다. | 연결 상태 표시: 클라이언트가 웹소켓 서버와 정상적으로 연결되었는지 알 수 있도록 UI에 연결 상태를 표시하는 기능을 추가하여 사용자 경험을 개선했습니다. | . 5. 결론 및 향후 과제 . 이번 Live Chat 기능 개발을 통해 STOMP를 활용한 효율적인 실시간 메시징 시스템의 기반을 구축했습니다. 특히, MVP 방식으로 빠르게 핵심 기능을 구현하고 점진적으로 리팩토링하는 전략은 매우 유효했습니다. 남은 과제: . | 서비스 레이어 분리: 현재 컨트롤러에 있는 비즈니스 로직을 별도의 서비스 레이어로 분리하여 역할과 책임을 명확히 해야 합니다. | 보안 강화: 개발 편의를 위해 setAllowedOriginPatterns(\"*\")로 설정했던 CORS 정책을 실제 서비스 도메인에 맞게 강화해야 합니다. | 상태 관리 고도화: 현재 접속자 목록, 사용자별 읽음 처리 등 실시간 상태 관리를 위한 로직을 Redis 등을 활용하여 고도화할 필요가 있습니다. | 기타 등등 … | . ",
    "url": "/docs/projects/devzip/livechat_development_log/#-live-chat-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80",
    
    "relUrl": "/docs/projects/devzip/livechat_development_log/#-live-chat-프로젝트-개발일지"
  },"810": {
    "doc": "Live Chat 프로젝트 개발일지",
    "title": "Live Chat 프로젝트 개발일지",
    "content": " ",
    "url": "/docs/projects/devzip/livechat_development_log/",
    
    "relUrl": "/docs/projects/devzip/livechat_development_log/"
  },"811": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "AI 시대의 새로운 개발 패러다임: MCP(Model Control Protocol) 서버 이해하기",
    "content": " ",
    "url": "/docs/studies/ai/mcp_server/#ai-%EC%8B%9C%EB%8C%80%EC%9D%98-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%B0%9C-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-mcpmodel-control-protocol-%EC%84%9C%EB%B2%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/studies/ai/mcp_server/#ai-시대의-새로운-개발-패러다임-mcpmodel-control-protocol-서버-이해하기"
  },"812": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "Table of contents",
    "content": ". | 들어가며 | MCP 서버란 무엇인가? | 현재 사용중인 MCP 서버 . | 1. Desktop Commander | 2. GitHub 통합 | 3. Sequential Thinking | . | AI 시대의 개발자 역량 . | 1. 효과적인 프롬프트 엔지니어링 | 2. MCP 도구 활용 능력 | 3. AI 협업 전략 | . | 결론 | 참고자료 | . ",
    "url": "/docs/studies/ai/mcp_server/#table-of-contents",
    
    "relUrl": "/docs/studies/ai/mcp_server/#table-of-contents"
  },"813": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "들어가며",
    "content": "현대 소프트웨어 개발 환경에서 AI의 역할이 점점 더 중요해지고 있습니다. 특히 Cursor와 같은 AI 기반 IDE들이 등장하면서, 개발자들은 AI와 함께 효율적으로 협업하는 방법을 배워야 하는 시대가 되었습니다. 이러한 맥락에서 MCP(Model Control Protocol) 서버의 역할과 중요성에 대해 알아보고자 합니다. ",
    "url": "/docs/studies/ai/mcp_server/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0",
    
    "relUrl": "/docs/studies/ai/mcp_server/#들어가며"
  },"814": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "MCP 서버란 무엇인가?",
    "content": "MCP 서버는 AI 모델과 개발 환경 사이의 중개자 역할을 하는 프로토콜 서버입니다. 이는 다음과 같은 주요 기능들을 제공합니다: . | 명령어 실행 및 관리 . | 터미널 명령어 실행 | 프로세스 관리 | 파일 시스템 조작 | . | 파일 시스템 작업 . | 파일 읽기/쓰기 | 디렉토리 생성 및 관리 | 코드 검색 및 편집 | . | 외부 서비스 통합 . | GitHub 연동 | 웹 검색 | API 호출 관리 | . | . ",
    "url": "/docs/studies/ai/mcp_server/#mcp-%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80",
    
    "relUrl": "/docs/studies/ai/mcp_server/#mcp-서버란-무엇인가"
  },"815": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "현재 사용중인 MCP 서버",
    "content": "1. Desktop Commander . | 파일 시스템 관리 | 프로세스 실행 및 모니터링 | 코드 검색 및 편집 기능 | . 2. GitHub 통합 . | 저장소 관리 | 이슈 및 PR 생성 | 코드 변경 관리 | . 3. Sequential Thinking . | 복잡한 문제 해결을 위한 단계별 사고 프로세스 | 문제 분석 및 해결 방안 도출 | 피드백 기반 개선 | . ",
    "url": "/docs/studies/ai/mcp_server/#%ED%98%84%EC%9E%AC-%EC%82%AC%EC%9A%A9%EC%A4%91%EC%9D%B8-mcp-%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/studies/ai/mcp_server/#현재-사용중인-mcp-서버"
  },"816": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "AI 시대의 개발자 역량",
    "content": "현대 개발자에게 요구되는 새로운 핵심 역량은 다음과 같습니다: . 1. 효과적인 프롬프트 엔지니어링 . | 명확하고 구체적인 지시사항 작성 | AI의 강점을 활용한 문제 해결 | 제약사항과 요구사항의 명확한 전달 | . 2. MCP 도구 활용 능력 . | 적절한 MCP 서버 기능 선택 | 효율적인 워크플로우 구성 | AI와의 효과적인 협업 | . 3. AI 협업 전략 . | AI의 제안을 검토하고 개선하는 능력 | AI의 한계 이해와 보완 | 지속적인 학습과 적응 | . ",
    "url": "/docs/studies/ai/mcp_server/#ai-%EC%8B%9C%EB%8C%80%EC%9D%98-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%97%AD%EB%9F%89",
    
    "relUrl": "/docs/studies/ai/mcp_server/#ai-시대의-개발자-역량"
  },"817": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "결론",
    "content": "AI 시대의 개발자는 단순히 코드를 작성하는 것을 넘어, AI 도구들과 효과적으로 협업하는 방법을 익혀야 합니다. MCP 서버는 이러한 협업을 가능하게 하는 핵심 인프라이며, 개발자는 이를 잘 활용하여 생산성을 극대화할 수 있습니다. 앞으로의 개발자는 자신의 프로그래밍 실력뿐만 아니라, AI에게 전달하는 프롬프트의 품질과 MCP 서버와 같은 도구들을 얼마나 잘 활용하는지가 성공의 핵심 요소가 될 것입니다. 이는 단순한 도구 사용을 넘어, AI와 함께 성장하고 발전하는 새로운 개발 패러다임의 시작을 의미합니다. ",
    "url": "/docs/studies/ai/mcp_server/#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/studies/ai/mcp_server/#결론"
  },"818": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "참고자료",
    "content": ". | Cursor IDE 공식 문서 | MCP 서버 기술 문서 | AI 협업 개발 모범 사례들 | . ",
    "url": "/docs/studies/ai/mcp_server/#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/studies/ai/mcp_server/#참고자료"
  },"819": {
    "doc": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "title": "AI 시대의 새로운 개발 패러다임 - MCP 서버",
    "content": " ",
    "url": "/docs/studies/ai/mcp_server/",
    
    "relUrl": "/docs/studies/ai/mcp_server/"
  },"820": {
    "doc": "오브젝트",
    "title": "Obejct &amp; OOP",
    "content": " ",
    "url": "/docs/studies/object/object/#obejct--oop",
    
    "relUrl": "/docs/studies/object/object/#obejct--oop"
  },"821": {
    "doc": "오브젝트",
    "title": "This Page has been written since August 08, 2023.",
    "content": "참고 서적 : “오브젝트”, 조영호 . ",
    "url": "/docs/studies/object/object/#this-page-has-been-written-since-august-08-2023",
    
    "relUrl": "/docs/studies/object/object/#this-page-has-been-written-since-august-08-2023"
  },"822": {
    "doc": "오브젝트",
    "title": "오브젝트",
    "content": " ",
    "url": "/docs/studies/object/object/",
    
    "relUrl": "/docs/studies/object/object/"
  },"823": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "DevZip - 물리 퀴즈 개발 과정",
    "content": " ",
    "url": "/docs/projects/devzip/physics-quiz/#devzip---%EB%AC%BC%EB%A6%AC-%ED%80%B4%EC%A6%88-%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/#devzip---물리-퀴즈-개발-과정"
  },"824": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "개요",
    "content": "DevZip의 물리 퀴즈는 사용자가 직접 시뮬레이션을 조작하며 물리 개념을 직관적으로 학습할 수 있도록 만든 인터랙티브 콘텐츠입니다. 과거 Unity와 C#을 이용해 ‘VR 화학 실험실’을 만들며 얻은 교육용 시뮬레이션 개발 경험을 바탕으로, 이번에는 웹 환경에서 Matter.js 물리 엔진을 사용해 구현했습니다. 단순히 정답을 맞히는 것을 넘어, 각 문제에 연동된 물리 엔진을 통해 선택이 어떤 결과로 이어지는지 시각적으로 보여주는 데 중점을 뒀습니다. ",
    "url": "/docs/projects/devzip/physics-quiz/#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/#개요"
  },"825": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "주요 기능",
    "content": ". | 인터랙티브 시뮬레이션: Matter.js 물리 엔진을 기반으로 자유 낙하, 포물선 운동, 진자 운동, 위성 궤도 운동 등을 구현했습니다. | 개념 학습: 각 퀴즈는 물리 법칙과 관련된 질문으로 구성되며, 정답과 함께 상세한 해설을 제공합니다. | 반응형 디자인: 사용자의 화면 크기에 맞춰 시뮬레이션 캔버스의 크기가 동적으로 조절됩니다. | . ",
    "url": "/docs/projects/devzip/physics-quiz/#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/#주요-기능"
  },"826": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "개발 과정 요약",
    "content": "물리 퀴즈 기능은 사용자가 시뮬레이션을 통해 물리 법칙을 직관적으로 이해하게 만드는 데 초점을 맞춰 개발했습니다. 초기에는 matter-js를 이용해 기본적인 시뮬레이션 로직을 구현하고, 퀴즈의 기본 구조를 잡았습니다. 개발 중 시뮬레이션이 실행되지 않는 버그가 있었지만, 초기 단계에서 해결하여 안정적인 기반을 마련했습니다. 이후, 시뮬레이션의 정확도를 높이고 코드를 정리하는 리팩토링을 여러 차례 진행했습니다. 특히 4번 문제의 원형 운동과 같이 복잡한 계산은 실제 물리 현상에 가깝도록 수학적 모델을 적용해 개선했습니다. 또한, React의 렌더링 효율을 높이기 위해 useCallback을 제거하고 useEffect 의존성을 수정하는 코드 최적화도 함께 진행했습니다. 사용자 경험을 개선하기 위해 화면 크기에 따라 캔버스가 조절되는 반응형 기능을 추가하고, 사용자가 오답을 선택했을 때 재시도할 수 있는 기능을 구현했습니다. ",
    "url": "/docs/projects/devzip/physics-quiz/#%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/#개발-과정-요약"
  },"827": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "기술 스택",
    "content": ". | Frontend: React | Physics Engine: matter-js | . ",
    "url": "/docs/projects/devzip/physics-quiz/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/#기술-스택"
  },"828": {
    "doc": "DevZip - 물리 퀴즈",
    "title": "DevZip - 물리 퀴즈",
    "content": " ",
    "url": "/docs/projects/devzip/physics-quiz/",
    
    "relUrl": "/docs/projects/devzip/physics-quiz/"
  },"829": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "Project - 퐁당 웹 매거진 프로젝트",
    "content": " ",
    "url": "/docs/projects/pongdang/pongdang/#project---%ED%90%81%EB%8B%B9-%EC%9B%B9-%EB%A7%A4%EA%B1%B0%EC%A7%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#project---퐁당-웹-매거진-프로젝트"
  },"830": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "Project has been written since July 1, 2023.",
    "content": ". 퐁당 웹 매거진은 온라인 매거진 플랫폼으로, 다양한 기사와 인터뷰를 웹에서 쉽게 접근할 수 있도록 제작된 프로젝트입니다. ",
    "url": "/docs/projects/pongdang/pongdang/#project-has-been-written-since-july-1-2023",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#project-has-been-written-since-july-1-2023"
  },"831": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "프로젝트 개요",
    "content": "퐁당은 웹 매거진 플랫폼으로, 사용자들에게 큐레이션된 콘텐츠를 제공합니다. 특히 인터뷰 중심의 콘텐츠를 쉽게 접근하고 검색할 수 있는 인터페이스를 제공하여 사용자 경험을 향상시키는 데 중점을 두었습니다. 퐁당 웹 매거진 로고 . ",
    "url": "/docs/projects/pongdang/pongdang/#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#프로젝트-개요"
  },"832": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "주요 기능",
    "content": "1. 반응형 메인 페이지 . | 모바일과 데스크톱 모두에서 최적화된 사용자 경험 제공 | 콘텐츠 슬라이더를 통한 주요 기사 하이라이트 | 직관적인 카테고리 내비게이션 | . 메인 페이지 레이아웃 . 2. 고급 검색 기능 . | 키워드 기반 콘텐츠 검색 | 타이틀 및 내용 기반 검색 알고리즘 | 검색 결과 실시간 정렬 | . 검색 결과 화면 . 3. 인터뷰 페이지 . | 인터뷰 콘텐츠 전용 레이아웃 | 인터뷰이별 카테고리화 | 관련 인터뷰 추천 시스템 | . 4. 보안 및 접근성 . | 국내 사용자 접근 최적화를 위한 해외 IP 차단 | AWS WAF 활용한 보안 시스템 구축 | 웹 접근성 가이드라인 준수 | . ",
    "url": "/docs/projects/pongdang/pongdang/#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#주요-기능"
  },"833": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "개발 타임라인",
    "content": "| 시기 | 주요 내용 | . | 2023년 7월 초 | 프로젝트 시작, 기본 레이아웃 및 CSS 설계 | . | 2023년 7월 중순 | 폰트 적용 및 부트스트랩 라이브러리 통합 | . | 2023년 8월 | 메인페이지 1차 완성, 슬라이드 및 애니메이션 효과 구현 | . | 2023년 10월 | 검색 기능 개발, 검색용 DB 설계 및 구현 | . | 2023년 12월 | 검색 페이지 완성, 라우팅 구현 | . | 2024년 1월 | 보안 강화 - AWS WAF 적용하여 해외 IP 차단 | . ",
    "url": "/docs/projects/pongdang/pongdang/#%EA%B0%9C%EB%B0%9C-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#개발-타임라인"
  },"834": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "기술 스택",
    "content": ". | 프론트엔드: React, CSS, Bootstrap | 백엔드: Spring Boot | 데이터베이스: MySQL | 인프라: AWS EC2, AWS WAF | 버전 관리: Git, GitHub | . ",
    "url": "/docs/projects/pongdang/pongdang/#%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#기술-스택"
  },"835": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "주요 도전 과제와 해결책",
    "content": ". | 반응형 디자인 구현 - 다양한 디바이스 크기에 맞춘 CSS 미디어 쿼리 적용 | 검색 알고리즘 최적화 - MySQL 쿼리 튜닝을 통한 검색 속도 향상 | 그라데이션 효과와 클릭 이벤트 충돌 - pointer-events CSS 속성을 활용하여 이미지 위에서의 이벤트 처리 문제 해결 | 보안 강화 - AWS WAF의 Web ACLs를 활용하여 해외 IP 차단 구현 | . ",
    "url": "/docs/projects/pongdang/pongdang/#%EC%A3%BC%EC%9A%94-%EB%8F%84%EC%A0%84-%EA%B3%BC%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0%EC%B1%85",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#주요-도전-과제와-해결책"
  },"836": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "Links",
    "content": "퐁당 웹 매거진 사이트 . 퐁당 웹 매거진 Instagram . 퐁당 웹 매거진 프로젝트 Ver.01 제작 일지 . 퐁당 웹 매거진 프로젝트 Ver.01 Github(private) . 퐁당 웹 매거진 프로젝트 Ver.02 제작 일지 . 퐁당 웹 매거진 프로젝트 Ver.02 Github(public) . ",
    "url": "/docs/projects/pongdang/pongdang/#links",
    
    "relUrl": "/docs/projects/pongdang/pongdang/#links"
  },"837": {
    "doc": "퐁당 웹 매거진 프로젝트",
    "title": "퐁당 웹 매거진 프로젝트",
    "content": " ",
    "url": "/docs/projects/pongdang/pongdang/",
    
    "relUrl": "/docs/projects/pongdang/pongdang/"
  },"838": {
    "doc": "Projects",
    "title": "Project",
    "content": "Project has been written since July 1, 2023. ",
    "url": "/docs/projects#project",
    
    "relUrl": "/docs/projects#project"
  },"839": {
    "doc": "Projects",
    "title": "Projects",
    "content": " ",
    "url": "/docs/projects",
    
    "relUrl": "/docs/projects"
  },"840": {
    "doc": "Study",
    "title": "공부",
    "content": "This Page has been written since July 17, 2023. ",
    "url": "/docs/studies#%EA%B3%B5%EB%B6%80",
    
    "relUrl": "/docs/studies#공부"
  },"841": {
    "doc": "Study",
    "title": "📚 학습 영역",
    "content": "🖥️ 백엔드 개발 (Backend) . 백엔드 개발자가 되기 위한 체계적인 학습 로드맵입니다. (진행중) 인터넷의 기본 작동 원리부터 고급 아키텍처 패턴까지 단계별로 학습할 수 있습니다. 🤖 인공지능 (AI) . 인공지능과 머신러닝 관련 학습 내용입니다. ☁️ AWS Developer Associate (AWS_DA) . AWS 개발자 자격증 취득을 위한 학습 내용입니다. 📖 객체지향 개발 (Object) . 객체지향 프로그래밍과 설계 패턴에 관한 학습 내용입니다. ",
    "url": "/docs/studies#-%ED%95%99%EC%8A%B5-%EC%98%81%EC%97%AD",
    
    "relUrl": "/docs/studies#-학습-영역"
  },"842": {
    "doc": "Study",
    "title": "Study",
    "content": " ",
    "url": "/docs/studies",
    
    "relUrl": "/docs/studies"
  },"843": {
    "doc": "AWS 기초 - 1",
    "title": "AWS 기초 - 1",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_1/",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/"
  },"844": {
    "doc": "AWS 기초 - 1",
    "title": "2023.08.19 (SAT)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_1/#20230819-sat",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#20230819-sat"
  },"845": {
    "doc": "AWS 기초 - 1",
    "title": "1. 온프라미스와 AWS 용어 비교",
    "content": "AWS는 아마존에서 온프레미스를 클라우드 서비스로 만든 것이다. 온프라미스(On-premise)란, 기업의 서버를 클라우드 같은 원격 환경에서 운영하는 방식이 아닌, 자체적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식이다. – . 온프라미스 용어 = 클라우드 용어 . | 방화벽 = 보안그룹 | ACL = NACL . | ACL(Access Control List) : 허가되지 않은 이용자가 라우터나 네트워크의 특정 자원을 접근하려고 하는 것을 차단한다. | . | 관리자 권한 = IAM | L4, 로드 밸런서 = ELB(일라스틱 로드 밸런서), 탄력적인 로드 밸련서, ALB, … . | 로드 밸런서 : 서버에 가해지는 부사(=로드)를 분산(=밸런싱)해주는 장치 또는 기술 | . | 네트워크 = VPC . | VPC는 Virtual Private Cloud로, 정의한 논리적으로 격리된 가상 네트워크에서 AWS 리소스를 시작할 수 있다. | . | 서버 = EC2(일라스틱 컴퓨트 클라우드), C2 | NAS = EFS(탄력적인 파일 시스템) . | NAS란, 네트워크 연결 스토리지로, 네트워크를 통해 효과적으로 협업할 수 있도록 데이터를 지속적으로 사용할 수 있게 하는 파일 전용 스토리지 디바이스이다. | 많은 곳에서 NAS를 사용하는 이유 : 확장 가능하며, 저렴한 스토리지를 제공하기 때문. | . | . | 디스크 = EBS (탄력적인 블록 스토어 저장장치) | DB = RDS (관계형 데이터 베이스) | . ",
    "url": "/docs/studies/aws_DA/summary_1/#1-%EC%98%A8%ED%94%84%EB%9D%BC%EB%AF%B8%EC%8A%A4%EC%99%80-aws-%EC%9A%A9%EC%96%B4-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#1-온프라미스와-aws-용어-비교"
  },"846": {
    "doc": "AWS 기초 - 1",
    "title": "2. AWS의 기본 구성",
    "content": ". | 사용자가 서비스를 사용하는 과정 . | 특정 서비스에 연결하려면 도메인 질의를 한다. | DNS 서비스가 응답을 한다. | 해당 도메인을 IP로 변환하여 서버에 연결한다. | 서버의 디스크의 데이터를 읽는다.(?) | 따로 요청한 데이터를 디비에서 읽어온다. | 스토리지에 저장된 이미지나 파일들을 다운받아 사용한다. | . | AWS 용어로 치환 가능하다. | Route53이 도메인에 대한 응답을 한다. (참고로 DNS포트가 53이라, Route53이다.) | 서버 EC2로 접속한다. | 로컬 디스크인 EBS에서 데이터를 읽는다. | 비지니스적으로 요청한 데이터가 있으면, Amazon DB에서 읽어온다. | S3 등등 | . | . ",
    "url": "/docs/studies/aws_DA/summary_1/#2-aws%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#2-aws의-기본-구성"
  },"847": {
    "doc": "AWS 기초 - 1",
    "title": "3. 온프레미스, 클라우드, 하이브리드…",
    "content": ". | 온 프레미스 : 일반 데이터 센터, 물리 서버로 운영하는 데이터 센터 | 하이브리드 : 클라우드 + 온프레미스 | 클라우드 : AWS, AZURE, GCP 등 유료서비스 | 멀티클라우드 : 여러 개의 퍼블릭 클라우드를 사용하는 경우 | . ",
    "url": "/docs/studies/aws_DA/summary_1/#3-%EC%98%A8%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#3-온프레미스-클라우드-하이브리드"
  },"848": {
    "doc": "AWS 기초 - 1",
    "title": "4. AZ",
    "content": "AZ란, 가용영역으로 한 리전에 여러 AZ가 존재한다. ex) 서울 리전, 도쿄 리전. 아마존 서버가 존재하는 곳이다. AZ끼리는 전용선으로 연결되어 있기 때문에, 빠르게 데이터를 주고 받을 수 있다. ",
    "url": "/docs/studies/aws_DA/summary_1/#4-az",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#4-az"
  },"849": {
    "doc": "AWS 기초 - 1",
    "title": "5. AWS 엣지 인프라 서비스",
    "content": "(1). AWS Outposts . 클라우드를 온프라미스에서도 쓸 수 있도록 확장한 것. (2). AWS Local Zones . 대형 메트로 센터를 사용한 엣지 서비스 . 엣지 컴퓨팅 : 정보 저장 및 컴퓨팅 능력을 사용자에게 더 가까이 제공하는 프로세스 . (3). AWS Wavelength . 5G 네트워크 엣지 서비스 통신사에서 클라우드 서비스 하는 것이다. ",
    "url": "/docs/studies/aws_DA/summary_1/#5-aws-%EC%97%A3%EC%A7%80-%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_1/#5-aws-엣지-인프라-서비스"
  },"850": {
    "doc": "AWS 기초 - 2",
    "title": "AWS 기초 - 2",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_2/",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/"
  },"851": {
    "doc": "AWS 기초 - 2",
    "title": "2023.09.04 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_2/#20230904-mon",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#20230904-mon"
  },"852": {
    "doc": "AWS 기초 - 2",
    "title": "1. 서버",
    "content": "(1). EC2 . | Elastic Compute Cloud의 줄임말이다. | C가 2개여서 EC2이다. | . (2). 인스턴스 패밀리 . | AWS 인스턴스 : 가상 컴퓨팅 환경으로 애플리케이션을 배포, 관리 및 확장하는데 도움이 되는 수많은 추가 기능 제공 | 인스턴스 표기법 . | | 인스턴스 패밀리 : M, T, C, X, R, IO, … (각 기능이 다르다.) | 인스턴스 세대 : 인스턴스 패밀리에 따라, 1~5세대 | 인스턴스 크기 : 인스턴스 패밀리 및 세대에 따라 다양한 크기 제공 | . | . ",
    "url": "/docs/studies/aws_DA/summary_2/#1-%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#1-서버"
  },"853": {
    "doc": "AWS 기초 - 2",
    "title": "2. EC2 요금",
    "content": ". | 온디맨드 인스턴스 | 예약 인스턴스 | Savings Plan | 스팟 인스턴스 | . ",
    "url": "/docs/studies/aws_DA/summary_2/#2-ec2-%EC%9A%94%EA%B8%88",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#2-ec2-요금"
  },"854": {
    "doc": "AWS 기초 - 2",
    "title": "3. 대표적인 컨테이너 관리형 서비스",
    "content": ". | . | ECS . | 간편 관리형 서비스 | AWS 전용이다. | 컨테이너가 소수일 때 커맨드로 관리 가능하지만, 많아지면 관리가 힘들어져 관리형 서비스를 사용한다. | ECS는 AWS에서 인프라를 관리해주며, 확장 등이 쉽게 가능하다. | . | . | . | EKS . | 쿠버네티스 사용의 관리 리소스가 포함됨 | 관리시간이 줄어듬 | 마스터노드의 관리를 AWS가 해줌 | 사용자는 워커노드만 관리하면 된다. | . | 워커노드 : 배포하고자 하는 어플리케이션의 실제 실행을 수행 - 마스터 서버로는 API 서버로 명령만 내릴 수 있다. - 별도의 AWS VPC에 마스터 서버가 구성된다. (사용자는 접근 불가) | . | . | . ",
    "url": "/docs/studies/aws_DA/summary_2/#3-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B4%80%EB%A6%AC%ED%98%95-%EC%84%9C%EB%B9%84%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#3-대표적인-컨테이너-관리형-서비스"
  },"855": {
    "doc": "AWS 기초 - 2",
    "title": "4, 람다",
    "content": ". | 대표적인 서버리스 컴퓨팅 (이 또한 관리형 서비스) | 서버 처리가 이벤트 방식이다. (람다는 이벤트 발생 시 트래픽 처리됨) | 사용자가 확장 등을 고려할 필요가 없다. | 거의 모든 것이 자동으로 처리된다. | . ",
    "url": "/docs/studies/aws_DA/summary_2/#4-%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_2/#4-람다"
  },"856": {
    "doc": "AWS 기초 - 3",
    "title": "AWS 기초 - 3",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_3/",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/"
  },"857": {
    "doc": "AWS 기초 - 3",
    "title": "2023.09.04 (MON)",
    "content": ". ",
    "url": "/docs/studies/aws_DA/summary_3/#20230904-mon",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#20230904-mon"
  },"858": {
    "doc": "AWS 기초 - 3",
    "title": "스토리지, 데이터 베이스",
    "content": " ",
    "url": "/docs/studies/aws_DA/summary_3/#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#스토리지-데이터-베이스"
  },"859": {
    "doc": "AWS 기초 - 3",
    "title": "1. AWS 스토리지 옵션",
    "content": "(1). Options . | S3 : 오브젝트 스토리지, 일반 스토리지 | S3 Glacier : S3 중 장기 보관용으로 저렴하다. | EFS : 공유 파일 스토리지, NAS와 같다. | NAS란, 네트워크를 통해 효과적으로 협업할 수 있도록 데이터를 지속적으로 사용할 수 있게 하는 파일 전용 스토리지 디바이스 | . | Storage Gateway | EBS - EC2에서 사용하는 디스크 저장소 | . ",
    "url": "/docs/studies/aws_DA/summary_3/#1-aws-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/studies/aws_DA/summary_3/#1-aws-스토리지-옵션"
  },"860": {
    "doc": "TIL",
    "title": "Today I Learned",
    "content": "TIL has been written since July 1, 2023. ",
    "url": "/docs/tils#today-i-learned",
    
    "relUrl": "/docs/tils#today-i-learned"
  },"861": {
    "doc": "TIL",
    "title": "TIL",
    "content": " ",
    "url": "/docs/tils",
    
    "relUrl": "/docs/tils"
  },"862": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "content": " ",
    "url": "/docs/java/SpringBoot/toby_1-1/",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/"
  },"863": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "2024.09.24 (TUE)",
    "content": ". ",
    "url": "/docs/java/SpringBoot/toby_1-1/#20240924-tue",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#20240924-tue"
  },"864": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "스프링의 핵심 철학",
    "content": "객체지향 프로그래밍이 제공하는 오브젝트에 집중한다. 스프링은 객체지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지는 않는다. -&gt; 하지만 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할지에 대한 기준을 알려준다. ",
    "url": "/docs/java/SpringBoot/toby_1-1/#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%B2%A0%ED%95%99",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#스프링의-핵심-철학"
  },"865": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "오브젝트의 동일성과 동등성",
    "content": ". | 직접 생성한 팩토리 오브젝트는 오브젝트를 만들 때, 매번 다른 오브젝트가 생성된다. | . DaoFactory factory = new DaoFactory(); UserDao dao1 = factory.userDao(); UserDao dao2 = factroy.userDao(); System.out.println(dao1); System.out.println(dao2); . 출력: example.dao.UserDao@118f375 example.dao.UserDao@117a8bd . | 하지만, 스프링 컨텍스트로부터 가져온 오브젝트는 동일하다. | . ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); UserDao dao3 = context.getBean(\"userDao\", UserDao.class); UserDao dao4 = context.getBean(\"userDao\", UserDao.class); System.out.println(dao3); System.out.println(dao4); . 출력: example.dao.UserDao@ee22f7 example.dao.UserDao@ee22f7 . 오브젝트 팩토리와 스프링의 애플리케이션 컨텍스트의 동작방식에 차이가 있기 때문이다. | 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다. | 애플리케이션 컨텍스트는 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너이다. | 그러면서 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 싱글톤 레지스트리란? . | . | 왜 싱글톤으로 빈을 만들까? . | 스프링은 주로 “자바 엔터프라이즈 기술”을 사용하는 서버환경이기 때문이다. | 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구된다. | 아무리 자바의 성능이 좋아도 요청 한 번에 여러 오브젝트를 만들면,,, 서버 XoX,,, | . | 싱글톤 레지스트리는 private와 스태틱 메소드 만을 사용해야하는 비정상적인 클래스가 아닌 평범한 클래스도 싱글톤으로 사용이 가능하다. | 그럴 수 있는 이유는, 오브젝트의 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다. XML을 이용한 의존관계 설정정보\\ . | . | &lt;beans&gt;를 루트 엘리먼트로 사용한다. | 해당 beans안에는 여러개의 bean이 들어갈 수 있다. | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-1/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#오브젝트의-동일성과-동등성"
  },"866": {
    "doc": "토비의 스프링 1권 1장 - 오브젝트와 의존관계",
    "title": "1장 요약",
    "content": ". | 스프링이 왜 IoC 컨테이너인지, DI 프레임워크인지 설명해주는 파트였다. | 각종 의존관계를 코드로 설명해주어, IoC와 DI에 대한 설명이 좋았다. | 스프링이란, 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크 | . ",
    "url": "/docs/java/SpringBoot/toby_1-1/#1%EC%9E%A5-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-1/#1장-요약"
  },"867": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "토비의 스프링 1권 2장 - 테스트",
    "content": " ",
    "url": "/docs/java/SpringBoot/toby_1-2/",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/"
  },"868": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "2024.09.29 (SUN)",
    "content": ". ",
    "url": "/docs/java/SpringBoot/toby_1-2/#20240929-sun",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#20240929-sun"
  },"869": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "스프링이 개발자에게 제공하는 가장 중요한 가치",
    "content": ". | 객체지향 | 테스트 | . 스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 애플리케이션은 점점 복잡해져 가는데, 그렇게 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 것이 테스트 기술이다. +) 또한 테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법 중 하나! . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%EC%A4%91%EC%9A%94%ED%95%9C-%EA%B0%80%EC%B9%98",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#스프링이-개발자에게-제공하는-가장-중요한-가치"
  },"870": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "테스트는 가능한 작게",
    "content": ". | 작은 단위의 테스트 (단위 테스트 / unit test) . | 테스트를 한꺼번에 너무 몰아서 많은 것을 하면, 테스트 수행 과정도 복잡해진다. | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9E%91%EA%B2%8C",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#테스트는-가능한-작게"
  },"871": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "테스트의 효율 향상을 위한 방법",
    "content": ". | 테스트 검증의 자동화 | . | 수정 전 System.out.prinln(user2.getName()); System.out.prinln(user2.getPassWord()); System.out.prinln(user2.getId() + \" 조회 성공\"); . | 수정 후 (자동화) if (!user.getName().equals(user2.getName())) { System.out.println(\"테스트 실패 (name)\"); // ... } . | . 개발자의 눈으로 일일히 확인할 필요 없이, 테스트를 실패하였는지 성공하였는지를 확인한다. | 테스트의 효율적인 수행과 결과 관리 . | JUnit을 활용한 단위 테스트 | 테스트의 수가 많아지면, IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것도 좋다. | ex). 이클립스 (run -&gt; Run As -&gt; JUnit Test) | . | “항상 네거티브 테스트를 먼저 만들라” . | 개발자는 흔히 “내가 할 떄는 잘됐는데”가 내장되어있을 수 있다.. | . | TDD : 테스트 주도 개발 . | 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법 | “실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.” | . | . | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%9A%A8%EC%9C%A8-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#테스트의-효율-향상을-위한-방법"
  },"872": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "JUnit 활용",
    "content": "@Before . | 매번 테스트마다 중복된 메소드를 불러온다면, @Before 애노테이션으로 설정해준다면, 각 테스트 메소드에서 코드를 실행하기 전에 @Before을 먼저 실행시킨다. | . public class UserDaoTest { private UserDao dao; @Before public void setUp() { ApplicationContext context = new GenericXmlApplicationContext(\"applicationContext.xml\"); this.dao = context.getBean(\"userDao\", UserDao.class); } @Test public void addAndGet() throws SQLException { // 각 테스트 메소드에 반복적으로 나타났던 코드를 제거하고 이를 @Before 에 옯겨 놓는다. // ... } @Test public void count() throws SQLException { // 각 테스트 메소드에 반복적으로 나타났던 코드를 제거하고 이를 @Before 에 옯겨 놓는다. // ... } // ... } . | JUnit이 제공하는 @Before 애노테이션, @Test 메소드가 실행되기 전에 먼저 실행되어야 하는 메소드를 정의한다. | . 테스트를 위한 애플리케이션 컨텍스트 관리 . | 애플리케이션 컨텍스트를 매 테스트마다 생성하는 것은 불필요하기 때문에, 스태틱 변수에 저장하는 등의 방법이 필요하다. | 그런 방법들 보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 이용하는 것이 더 편리하다. (@RunWith, @ContextConfiguration) | 매 테스트 메소드가 실행되기 전에 한번씩 실행되며, 모두 새로운 테스트 오브젝트를 만들어 사용한다. (애플리케이션 컨텍스트 재사용) | 여러 개의 테스트 클래스에게도 공유 가능 | . | . @Autowired . | 스프링 DI에 사용되는 특별한 애노테이션 | @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내 빈을 찾는다. | 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. | 일반적으로 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능 | ‼️‼️ 단, 같은 타입의 빈이 두 개 이상 있는 경우는 타입만으로 결정할 수 없다. | 선택할 수 없는 경우에는, 변수의 이름과 같은 이름의 빈이 있는지 확인 . | 이름으로도 찾을 수 없으면, 예외 발생 | . | . | . | 이를 통해서, 자신이 사용하는 오브젝트의 클래스가 무엇인지 알 필요가 없다는 장점이 있다. | . 학습 테스트 . | JUnit 자신에 대한 테스트를 통해, 테스트를 학습 테스트로 사용해 볼 수 있다. | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#junit-%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#junit-활용"
  },"873": {
    "doc": "토비의 스프링 1권 2장 - 테스트",
    "title": "2장 요약",
    "content": ". | 테스트는 자동화되어야 하며, 빠르게 실행되어야 한다. | main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다. | 테스트하기 쉬운 코드가 좋은 코드다. | . ",
    "url": "/docs/java/SpringBoot/toby_1-2/#2%EC%9E%A5-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/java/SpringBoot/toby_1-2/#2장-요약"
  }
}
